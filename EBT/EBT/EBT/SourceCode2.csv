46,"private JPanel centerPanel = null;

 private JLabel desLabel = null;
 private JLabel changeLabel = null;
 private JLabel fromLabel = null;
 private JLabel toLabel = null;
 private JTextArea desText = null;
 private JTextField c Speculate Gui public SpeculateGui()
 {

super(""Speculate GUI"");

container = getContentPane();

setSize(800, 600);

this. eventServerIP =
 JOptionPane
. showInputDialog(""Please Enter the IP Address of eventserverSubmit Listener public void actionPerformed(ActionEvent e) {

 if ( e. getSource() == submitButton) {

sendQueryTO Server();

 }

 if ( e. getSource() == fetchButton) {


System. out. println(""Fetch Button Pressed void sendQueryTO Server()
 {

String ip = this. eventServerIP;
int PortNo = 1701;

Socket socket;
try {

 socket = new Socket( ip, PortNo);

 OutputStream os = socket. getOutputStream();
 OutputStreampublic void pullValueFromDOORS()
 {

String serverIP = new String( doors serverIP); //""140.192.37.150"";

String[] attribute = { ""Value"", ""Attribute"" };

String projectName = this. projNameText. get public static void main(String[] args)
 {
new SpeculateGui();
 }"
47,"Impact Report private String serverIP = "" local host"";
private JPanel centerPanel = null;
private JPanel driverPanel = new JPanel();
private JPanel driverInnerPanel = null;
private JPanel impactPanel = null;
private JPanel impactInnerP public ImpactReport()
{
super(""Search Result GUI"");
container = getContentPane();
setSize(800, 250);
panel = new JPanel();

panel. setLayout( null);

this. serverIP =
 JOptionPane
. showIn public static void main(String [] args)
 {

ImpactReport im = new ImpactReport();



 } public Vector searchDate()
 {

dateVector = new Vector();
dateVector. add(""Select Query Date"");
Socket server;
String line = new String();


try
{

 server = new Socket( serverIP,1701);
 if ( server. isC public void searchQueryID(String date)
 {

pairVector = new Vector();

queryStringCombo. removeAllItems();

queryStringCombo. addItem(""Select Query String"");

Socket server;
String line = new String(); Select Actions public void actionPerformed(ActionEvent e)
{

 if ( dateCombo == (JComboBox) e. getSource())
 {
date = (String) dateCombo. getSelectedItem();
searchQueryID( date);
 }
} Button Actionspublic void actionPerformed(ActionEvent e) {

 if ( submitButton == e. getSource()) {

for ( int i = 0; i < pairVector. size(); i++) {

 Pair pair = (Pair) pairVector. get( i);

 if ( pair
. get public void impactReport(String id)
 {

// super(""Impact Report"");

container = getContentPane();

setSize(1020, 740);

this. queryID = id;

System. out. println(""Impact Report Constructor ..... ID "" + public Vector getConstraintFromDataBase()
 {

Vector v = new Vector();

Socket server;
String line = new String();


try
{
 server = new Socket( serverIP,1701);

 if ( server. isConnected() )
 {
Bufferedpublic Vector getDriverFromDataBase()
 {

Vector v = new Vector();

 Socket server;
String line = new String();


try
{
 server = new Socket( serverIP,1701);

 if ( server. isConnected() )
 {
Buffered"
48,"Constraint Inner Panelprivate String serverIP = "" local host"";
 private JLabel performanceModelLabel = null;
 private JLabel projectNameLabel = null;
 private JLabel modulePathLabel = null;
 private JLabel requirementIdLabel = null;
 private JLabel public ConstraintInnerPanel(
String performanceModelName,
String projectName,
String modulePath,
String requirementId,
String description,
String logic,
String units,
String value,
String impactedValueprivate void set goalLabelValues(
String attribute,
String logic,
String value,
String units)
 {
goalLabel. setText(
 ""Goal : "" + attribute + """" + logic + """" + value + "" "" + units);

 }public Vector getValuesFromDataBase()
 {

Vector v = new Vector();

Socket server;
String line = new String();


try
{
 server = new Socket( serverIP,1701);

 if ( server. isConnected() )
 {
BufferedRprivate void set impactedLabelValue(
String attribute,
String value,
String impactedValue,
String units,
String logic)
 {

if ( impactedValue != null)
{

 double value1 = Double. parseDouble( value);
 dpublic JPanel getPanel()
 {
return panel;
 }"
49,"Constraints Description private String projectName = null;
 private String modulePath = null;
 private String requirementID = null;

 private String value = null;
 private String logic = null;
 private String units = null;
 private String description = null;
 public ConstraintsDescription(
String projectName,
String modulePath,
String requirementID)
 {

this. projectName = projectName;
this. modulePath = modulePath;
this. requirementID = requirementID;

 }public String getDescription() {
return this. description;
 }public String getLogic() {
return this. logic;
 }public String getModulePath() {
return this. modulePath;
 }public String getProjectName() {
return this. projectName;
 }public String getRequirementID() {
return this. requirementID;
 }public String getUnits() {
return this. units;
 }public String getValue() {
return this. value;
 }public void setDescription(String description) {
this. description = description;
 }public void setLogic(String logic) {
this. logic = logic;
 }public void setModulePath(String modulePath) {
this. modulePath = modulePath;
 }public void setProjectName(String projectName) {
this. projectName = projectName;
 }public void setRequirementID(String requirementID) {
this. requirementID = requirementID;
 }public void setUnits(String units) {
this. units = units;
 }public void setValue(String units) {
this. value = units;
 }public String getImpactedConstraint() {
return this. impactedConstraint;
 }public void setImpactedConstraint(String impactedConstraint) {
this. impactedConstraint = impactedConstraint;
 }public String getAttribute() {
return this. attribute;
 }public void setAttribute(String attribute) {
this. attribute = attribute;
 }public String getPerformanceModelName() {
return this. performanceModelName;
 }public void setPerformanceModelName(String performanceModelName) {
this. performanceModelName = performanceModelName;
 } public String toString() {

String str =
 ""\ nProject Name = ""
+ this. projectName
+ ""\ n""
+ ""Module Path = ""
+ this. modulePath
+ ""\ n""
+ ""Requirement ID = ""
+ this. requirementID
+ ""\ n""
 public boolean equals(Object o) {

if (!( o instance of ConstraintsDescription))
 return false;

ConstraintsDescription cd = (ConstraintsDescription) o;

if ( cd. projectName. equalsIgnoreCase( this. projectNapublic int hashCode() {

int hashCode = 0;

if ( hashCode == 0) {
 int result = 17;
 result = 37 * result + this. projectName. hashCode();
 result = 37 * result + this. modulePath. hashCode();
 result = 37 * "
50,"Driver Description private String projectName = null;
 private String modulePath = null;
 private String requirementID = null;

 private String description = null; // Description of the requirement.
 private String changedArrtibute = null;
 private Strinpublic DriverDescription(
String projectName,
String modulePath,
String requirementID,
String description,
String changedAttribute,
String fromAttribute,
String toAttribute)
 {

this. projectName = projecpublic String getChangedAttribute()
 {
return changedAttribute;
 }public String getDescription()
 {
return description;
 }public String getFromAttribute()
 {
return fromAttribute;
 } public String getModulePath()
 {
return modulePath;
 }public String getProjectName()
 {
return projectName;
 } public String getRequirementID()
 {
return requirementID;
 } public String getToAttribute()
 {
return toAttribute;
 } public void setChangedAttribute(String changedAttribute)
 {
this. changedAttribute = changedAttribute;
 } public void setDescription(String description)
 {
this. description = description;
 } public void setFromAttribute(String fromAttribute)
 {
this. fromAttribute = fromAttribute;
 } public void setModulePath(String modulePath)
 {
this. modulePath = modulePath;
 } public void setProjectName(String projectName)
 {
this. projectName = projectName;
 } public void setRequirementID(String requirementID)
 {
this. requirementID = requirementID;
 } public void setToAttribute(String toAttribute)
 {
this. toAttribute = toAttribute;
 } public String createKey()
 {
String key =
 this. projectName + this. modulePath + ""\\"" + this. requirementID;

return key. toLowerCase();

 } public boolean equals(Object o)
 {
if (!( o instance of DriverDescription))
 return false;

DriverDescription dd = (DriverDescription) o;

if ( dd. projectName. equalsIgnoreCase( this. projectName)
 && ddpublic String toString()
 {

String str =
 ""\ nProject Name = ""
+ this. projectName
+ ""\ n""
+ ""Module Path = ""
+ this. modulePath
+ ""\ n""
+ ""Requirement ID = ""
+ this. requirementID
+ ""\ n""
public int hashCode()
 {

int hashCode = 0;

if ( hashCode == 0)
{
 int result = 17;
 result = 37 * result + this. projectName. hashCode();
 result = 37 * result + this. modulePath. hashCode();
 result = 37 "
51,"Driver Inner Panel private JLabel projectNameLabel = null;
 private JLabel modulePathLabel = null;
 private JLabel requirementIdLabel = null;
 private JLabel desLabel = null;
 private JLabel changeLabel = null;
 private JLabel fromLabel = null;String projectName,
String modulePath,
String requirementID,
String description,
String changeAttribute,
String fromValue,
String toValue) {

panel = new JPanel();

panel. setBackground(Color.LIGHTpublic JPanel createPanel() {

return panel;
 }"
52,"Pair private String queryID;
 private String queryString; public Pair(String queryID, String queryString) {

this. queryID = queryID;
this. queryString = queryString;

 } public String getQueryID() {
return this. queryID;
 } public String getQueryString() {
return this. queryString;
 } public void setQueryID(String queryID) {
this. queryID = queryID ;
 } public void setQueryString(String queryString) {
this. queryString = queryString;
 } public String toString(){


return ""Query ID: ""
+ this. queryID
+ ""\ n""
+""Query String : ""
+ this. queryString
+ ""\ n"";


 }"
53,"Performance Modelprivate String name = null;
 private Vector driverVector = null;
 private Vector constraintVector = null;

 private long queryID = 0;

 public static int count = 0; public PerformanceModel(String name, long queryID)
 {
this. name = name;
this. queryID = queryID;

this. driverVector = new Vector();
this. constraintVector = new Vector();
 } public Vector getConstraints()
 {
return constraintVector;
 } public Vector getDrivers()
 {
return driverVector;
 } public String getName()
 {
return name;
 } public void setName(String name)
 {
this. name = name;
 } public void addDriver(DriverDescription driver)
 {

if ( driverVector. contains( driver))
{
}
else
 this. driverVector. add( driver);

 } public void removeDriver(DriverDescription driver)
 {
this. driverVector. remove( driver);
 } public boolean containsDriver(DriverDescription driver)
 {
return this. driverVector. contains( driver);
 } public void addConstraint(ConstraintsDescription constraint)
 {
this. constraintVector. add( constraint);
 } public boolean containsConstraint(ConstraintsDescription constraint)
 {
return this. constraintVector. contains( constraint);
 } public void removeConstraint(ConstraintsDescription constraint)
 {
this. constraintVector. remove( constraint);
 } public DriverDescription getDriver(DriverDescription driver)
 {
DriverDescription dd = null;

for ( int i = 0; i < this. driverVector. size(); i++)
{
 dd = (DriverDescription) this. driverVector. get( i) public ConstraintsDescription getConstraint(ConstraintsDescription constraint)
 {
ConstraintsDescription cd = null;

for ( int i = 0; i < this. constraintVector. size(); i++)
{
 cd = (ConstraintsDescription) thispublic long getQueryID()
 {
return this. queryID;
 } public void setQueryID( long id)
 {
this. queryID = id;
 } public String toString()
 {
return ""performance modelName = ""
 + this. name
 + ""\ n""
 + ""Query ID = ""
 + this. queryID
 + ""\ n""
 + ""Drivers = ""
 + this. driverVector
 + ""\ n""
 + ""Constraints = ""
 + this."
54,"eventserver public static void main(String args[])
 {

ThreadPool pool = new ThreadPool(1);

 int port = defaultPort;
 try
 {
 ServerSocket ss = new ServerSocket( port);
 for( int i=0; i<4; i++)
 {
p public final static int defaultPort = 1701;
 ServerSocket theServer;"
55,"eventserver Threadstatic private int count = 0;
 private int taskNumber;
 protected Done done;
 ServerSocket theServer;

 private Connection conn;
 private Statement stmt;
 private ResultSet rs;

 private EventParser ep;
 private int id; EventServerThread(ServerSocket ss)
 {
 theServer = ss;
 count++;
 taskNumber = count;
 ep = new EventParser();
 } public void run()
 {

 while( true)
 {
 try
 {

Socket client = theServer. accept();
BufferedReader input = new BufferedReader( new InputStreamReader( client. getInputStream()));
PrintWriter output = new P public String getNextID()
 {

try
{
Class. forName("" sun. jdbc. odbc.jdbcodbcDriver"");
this. conn = DriverManager. getConnection("" jdbc: odbc:EBT"",""EBT"",""EBT"");
this. stmt = connpublic String searchDate()
 {

String dateString = new String();
Vector dateVector = new Vector();

try
{

 Class. forName("" sun. jdbc. odbc.jdbcodbcDriver"");
 Connection conn = DriverManager. getConnectio public String searchQueryID(String date)
 {
Vector queryVector = new Vector();

String searchQuery = new String();

try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 conn = DriverManager. getpublic String getConstraintFromDataBase(String queryID)
 {

String ConstString = new String();


try
{

 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");

 conn = DriverManager. getConnection("" j public String getDriverFromDataBase(String queryID)
 {

String driverString = new String();

try
{

 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");

 conn = DriverManager. getConnection("" jdbc "
56,"Event Parser private Connection conn;
 private ResultSet rs;
 private Statement stmt; //EventParser Constructor
 // initializes the Database connection
 public EventParser()
 {
try
{
 Class. forName("" sun. jdbc. odbc.JdbcOdbcDriver"");
 this. conn = DriverManager. getConnection("" jdbc: odbc: public void updateEvent(String str, String ID)
 {

String mProject;
String mEvent;
String mType;
String mNum;
String mrequirement ;
String mModule;
String mSQL;
String mDate;
String mReqtext;
//Check if a subscription exists
 public boolean CheckSubscription(String str)
 {

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Message type = tokens. nextToken();
String SubscriberName = tokens. next //Insert a subscription into the ""Subscription"" table
 public void AddSubscription(String str, int ID)
 {

// Parse the message string and get the fields

StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //DeleteSubscription from the ""Subscription"" table
 public void DeleteSubscription(String str, int ID)
 {
// Parse the message string and get the fields
StringTokenizer tokens = new StringTokenizer( str, ""|"");
String Messag //Speculate method will receive a string from the Speculative GUI
 // tool and parse it using CallBack class to identify the
 // performance models
 public void speculate(String str)
 {
System. out. println(""Speculate"");
CallBack public void impactReport(String str)
 {
CallBack cb = new CallBack();
cb. parseImpactReport( str);
 }// end impactReport()"
57,"Event Notifier // Variables to process the requirement
 private String requirement No;//Requirement No.
 private String ProjName; //Project name
 private String ModPath;//Modular path
 private String requirement Text;/ public EventNotifier(String rno, String proj, String mod, String rtext,String eID, String em, String eventType)
 {
requirement No = rno;//Requirement number
ProjName = proj;// project name
ModPath = mo // finds the subscribers for this requirement
 public void IdentifySubscribers()
 {
String mSQL;
// Create an SQL statement that will limit the selection as much as possible
// If a subscription is to a specific requirement - check for requi //Reads the result from IdentifySubscribers method selection
 // and adds each result into ActualSubscribers Vector.
 void ProcessResultSet()
 {

String sName, sReqno, sModule, sKey1, sKey2;
try
{
 System. o // Send messages to all subscribers listed in ActualSubscriber Vector
// Possible that a sort routine can be added later so that all notification to
// the same subscribermanager can be batched.This is not implemented yet.

 public void Dispatch public String getErrorMessage()
 {
 return errMsg;

 } public boolean Contains(String ContextString, String SearchString)
 {
int cLen = ContextString. length();
int sLen = SearchString. length();
if (SearchString. length() == 0)
 return false;

for ( int i = 0"
58,"Subscribed Model private String SubscriberName;
private String SubscriberReqno;
private String SubscriberModule;
private String SubscriberKeyword1;
private String SubscriberKeyword2;public SubscribedModel(String sn, String sr, String sm, String sk1, String sk2)
{
SubscriberName = sn;
SubscriberReqno = sr;
SubscriberModule = sm;
SubscriberKeyword1 = sk1;
SubscriberKeyword2 = s public String GetSubscriberName() { return SubscriberName;} public String GetSubscriberReqno() { return SubscriberReqno;} public String GetSubscriberModule() { return SubscriberModule;} public String GetSubscriberKeyword1() { return SubscriberKeyword1;} public String GetSubscriberKeyword2() { return SubscriberKeyword2;}"
59,"Done /**
* The number of Worker object
* threads that are currently working
* on something.
*/
 private int _ activeThreads = 0;

 /**
* This boolean keeps track of if
* the very first thread has started
* or not. This prevents this objec /**
* This method can be called to block
* the current thread until the ThreadPool
* is done.
*/

 synchronized public void waitDone()
 {
try {
 while ( _ activeThreads>0 ) {
wait();
 }
} catch ( InterruptedException/**
* Called to wait for the first thread to
* start. Once this method returns the
* process has begun.
*/

 synchronized public void waitBegin()
 {
try {
 while ( !_ started ) {
wait();
 }
} catch ( InterruptedException e/**
* Called by a Worker object
* to indicate that it has begun
* working on a workload.
*/
 synchronized public void workerBegin()
 {
_ activeThreads++;
_ started = true;
notify();
 } /**
* Called by a Worker object to
* indicate that it has completed a
* workload.
*/
 synchronized public void workerEnd()
 {
_ activeThreads--;
notify();
 } /**
* Called to reset this object to
* its initial state.
*/
 synchronized public void reset()
 {
_ activeThreads = 0;
 }"
60,"Thread Pool /**
* The threads in the pool.
*/
protected Thread threads[] = null;
/**
* The backlog of assignments, which are waiting
* for the thread pool.
*/
Collection assignments = new ArrayList(3);
/**
* A Done object that is /**
 * The constructor.
 *
 * @param sizeHow many threads in the thread pool.
 */
public ThreadPool( int size)
{

threads = new WorkerThread[ size];

for ( int i=0; i< threads. length; i++)
{
thr /**
* Add a task to the thread pool. Any class
* which implements the Runnable interface
* may be assigned. When this task runs, its
* run method will be called.
*
* @param r An object that implements the Runnable interface
*/
 pub /**
* Get a new work assignment.
*
* @return A new assignment
*/
 public synchronized Runnable getAssignment()
 {
try {
 while ( ! assignments. iterator(). hasNext() )
wait();

 Runnable r = (Runnable) assignments./**
* Called to block the current thread until
* the thread pool has no more work.
*/
 public void complete()
 {
done. waitBegin();
done. waitDone();
 } protected void finalize()
 {
done. reset();
for ( int i=0; i< threads. length; i++) {
 threads[ i]. interrupt();
 done. workerBegin();
 threads[ i]. destroy();
}
done. waitDone();
 }
}"
61,"Worker Thread /**
* True if this thread is currently processing.
 */
public boolean busy;
/**
 * The thread pool that this object belongs to.
 */
public ThreadPool owner; /**
 * The constructor.
 *
 * @param o the thread pool
 */
WorkerThread(ThreadPool o)
{
owner = o;
} /**
 * Scan for and execute tasks.
 */
public void run()
{
Runnable target = null;

do
{
target = owner. getAssignment();
if ( target!=null)
{
 target. run();
 owner. done. worker"
62,"Call Back private Hash table requirementDescTable = new Hash table();

 private Hash table constraintDescTable = new Hash table();

 private Hash table performanceModelTable = new Hash table();

 private PerformanceModel performance model= nullpublic void parseSpeculateInformation(String str)
 {

System. out. println(""Received String = "" + str);

Connection conn = null;

Statement stmt = null;

DriverDescription dd = null;

String eventType = null; // public void identifyPerformanceModels()
 {

Connection conn = null;
ResultSet rs = null;
Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;

Enumeration subscriberTableEnumeration = nu public void pullInformationFromDoors()
 {

String serverIP = ""140.192.37.150"";

String[] attribute = { ""Value"", ""Logic"", ""Units"", ""Attribute"" };

String subscriberName = null;

Vector constraints = n public void insertValuesInDataBase()
 {

Connection conn = null;

Statement stmt = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector = null;

ConstraintsDescription cd = null;
 public void createExecuteString()
 {

Connection conn = null;

Statement stmt = null;

ResultSet rs = null;

StringBuffer sb = null;

String subscriberName = null;

DriverDescription dd = null;
Vector driverVector public void parseImpactReport(String str)
 {

Connection conn = null;

Statement stmt = null;

Vector constraintsVector = null;
Vector driversVector = null;

ConstraintsDescription constraint = null;

int driverLoop"
63,"Doors Thread static private int count = 0;
 private int taskNumber;
 protected Done done;
 ServerSocket theServer;

 private Connection conn;
 private Statement stmt;
 private ResultSet rs; DOORsThread(ServerSocket ss)
 {
 theServer = ss;
 count++;
 taskNumber = count;
 } public void run()
 {

 while( true)
 {
 try
 {

Socket client = theServer. accept();
BufferedReader input = new BufferedReader( new InputStreamReader( client. getInputStream()));
PrintWriter output = new P"
64,"DOORs Thread Pool public final static int defaultPort = 2347;
 ServerSocket theServer;
 // static int numberOfThreads = 3; //@param argsNo arguments are used.
 public static void main(String args[])
 {

ThreadPool pool = new ThreadPool(1);

 int port = defaultPort;
 try
 {
 ServerSocket ss = new ServerSocket( port);
 for"
65,"About Dialog public AboutDialog(JFrame parent, boolean modal) {

 super ( parent, modal);
 
 getContentPane (). setLayout ( new BorderLayout ());
 setTitle (""About"");
 setName ("" aboutDialog"");
 
 private JTextArea text;"
66,"Config Dialog public ConfigDialog(Notification_Processing parent, boolean modal) {
 
super ( parent, modal);
 setTitle(""Config Dialog Box"");
 getContentPane (). setLayout ( new GridLayout(5,2));

private void closeDialog(WindowEvent evt) {
setVisible ( false);
dispose ();
}// event listener for ""Ok"" button 
private void okButtonActionPerformed (ActionEvent evt) {
 
 if( UserName. getText(). equals("""") || DSN. getText(). equals("""") || EventServerIP. getText(). equa// event listener for ""Cancel"" button
private void cancelButtonActionPerformed (ActionEvent evt) {
setVisible ( false);
dispose (); 
} // configuration entries
private JLabel UserNameLabel; 
private JTextField UserName;
private JLabel DSN Label; 
private JTextField DSN;
private JLabel EventServerIP Label; 
private JTextField EventSe"
67,"Event Detail Dialog private GridBagLayout grid bag;
private GridBagConstraints c;

// objects in top panel
private JPanel topPanel;
private JLabel modelLabel;
private JLabel typeLabel;
private JTextField modelField;
p public EventDetailDialog(EventsProcessor parent, boolean modal,Notification_Event nEvt, boolean mode)
{

super ( parent, modal);
 setTitle(""Event Details"");
 getContentPane (). setLayout (private void closeDialog(WindowEvent evt)
{
setVisible ( false);
dispose ();
} // event listener for ""Ok/Update"" button
private void okButtonActionPerformed (ActionEvent evt)
{

 if ( displayMode == true)
 {

// m_ parent.DeleteEvent( m_Evt. m_SubscriberName, m_ // event listener for ""Cancel"" button
private void cancelButtonActionPerformed (ActionEvent evt)
{
setVisible ( false);
dispose ();
} private void LeftListClicked(MouseEvent e){

 if (!LeftList. isSelectionEmpty()) {

 int index = LeftList. getSelectedIndex();
 Requirement requirement= (Requirement) m_Evt. m_LeftSideprivate void RightListClicked(MouseEvent e){

 if (!RightList. isSelectionEmpty()) {

 int index = RightList. getSelectedIndex();
 Requirement requirement= (Requirement) m_Evt. m_RightS"
68,"Events Processor // event list
 private JList eventList;
 private DefaultListModel listModel;
 private ArrayList events;

 // popup menu
 private JPopupMenu popup;

 // Subscriber name
 String m_SubscriberName;

 // list of requirements to be d public EventsProcessor(Notification_Processing parent, boolean modal, String SubsName)
 {

 setTitle(""EventsProcessor"");

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEve void exitApplication() {
m_ parent.UpdateDisplayList();
 this. setVisible( false);
 this. dispose();
} // action for "" double click on Event List""
 private void doubleClickEventList (MouseEvent evt)
 {

int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
Notification // action for ""Open First Record"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index =0;
 try
 {
Notification_Event nEvt1 = (Notificati / action for ""View Current Record"" in popup menu
 private void popupViewActionPerformed (ActionEvent evt)
 {
int index = eventList. getSelectedIndex();
if ( index != -1)
{
 try
 {
N void DeleteEvent(String SubscriberName, String EventID)
 {

try
{

 int i, j=-1;
 for ( i=0; i< events. size(); i++)
 {
Notification_Event nEvt = (Notification_Event) events. get( i);
i void DeleteRelatedEvents()
 {

while ( m_Deleterequirement List. size()!=0)
{

 Requirement requirement= (Requirement)( m_Deleterequirement List. get(0));

 m_Deleterequirement List. remove(0);
void AddSubscription(String SubscriberName, Requirement requirement )
 {

String SubscriberDependency = ""Requirements"";

String Message = ""ADD_SUBSCRIPTION""+""|"";
Message += m_UserName + ""|"";
Message += Subscribervoid DeleteSubscription(String SubscriberName, Requirement requirement )
 {
String Message = ""REMOVE_SUBSCRIPTION""+""|"";
Message += SubscriberName + ""|"";
Message += requirement . m_RequirementID + "","";
Message += req void UpdateDisplayList()
 {

listModel. removeAllElements();

for ( int j=0; j< events. size(); j++)
{

 Notification_Event nEvt = (Notification_Event) events. get( j);

 String displayStri // Passes a CHECK_SUBSCRIPTION message to the eventserver and waits for a response
private boolean Check_Subscription(String ip,
 int PortNo,
 String SubscriberName,
 String Requirement // Takes an event string returned from the eventserver and
// extracts True or False response
private boolean Analyze_CheckSubscription(String str)
{
StringTokenizer tokens = new StringTokenizer( str,""|"");
String Messag"
69,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
} public Object clone() throws CloneNotSupportedException
 {

Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 nEvt. m_RightSide = new ArrayLis public void ParseEvent(String TextLine)
 {

 StringTokenizer LineSt; // Tokenizer for the line

int i=0;

LineSt = new StringTokenizer(TextLine, ""|"");

m_SubscriberName = LineSt. nextToken// Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" m_SubscriberName: ""+ m_SubscriberName);
 System. out. println("" m_EventI"
70,"Notification Processing // member variables for menu
 private JMenuBar menuBar;

 // subscriber list
 private JList SubscriberList;
 private DefaultListModel listModel;

 // popup menu

 private JPopupMenu popup;

 // database and eventserver information
 S public Notification_Processing()
 {

setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);

addWindowListener( new WindowAdapter()
{
 public void windowClosing(WindowEvent evt)
 {
try
public static void main(String args[])
 {
try
{
 Notification_Processing mainFrame = new Notification_Processing();
 mainFrame. setSize(600, 400);
 mainFrame. setLocation(100, 100);
 mainFrame. void exitApplication()
{
try
{
int reply = JOptionPane. showConfirmDialog( this,
""Do you really want to exit?"",
""No // action for ""Open log database""
 private void openMenuItemActionPerformed (ActionEvent evt)
 {
new ConfigDialog( this, true). show();

 if( m_DSN. equals("""") || m_EventServerIP. equals("""") || m_// action for ""Close log database""
 private void saveMenuItemActionPerformed (ActionEvent evt)
 {
try
{
 m_ conn. close();
 m_DSN="""";
 m_EventServerIP="""";
 m_EventServerPort="""";

 // action for "" exit""
 private void exitMenuItemActionPerformed (ActionEvent evt)
 {
exitApplication();
 } // action for ""Open Events"" in popup menu
 private void popupOpenActionPerformed (ActionEvent evt)
 {
openEventsMenuItemActionPerformed( evt);
 } // action for ""Open Events""
 private void openEventsMenuItemActionPerformed (ActionEvent evt)
 {
if (! listModel. isEmpty())
{
 int index = SubscriberList. getSelectedIndex();
 if ( index != -1)
 // action for "" double click on Subscriber List""
 private void doubleClickSubscriberList (MouseEvent evt)
 {
if (! listModel. isEmpty())
{
 int index = SubscriberList. getSelectedIndex();
 if ( index != -1 // action for ""About""
 private void aboutMenuItemActionPerformed (ActionEvent evt)
 {
new AboutDialog ( this, true). show();
 } void UpdateDisplayList()
 {
listModel. removeAllElements();

 String mSQL = ""SELECT distinct SubscriberName FROM EventDetails"";

try
{
 rs = stmt. executeQuery( mSQL);
 while ( rs. next())
 {
 "
71,"Requirementpublic String m_RequirementID ="""";
public String m_Project ="""";
public String m_ModulePath="""";
public String m_Content = """";
public String m_RegFlag = ""N""; public Requirement()
{

} public Object clone() throws CloneNotSupportedException
 {

Requirement requirement= (Requirement) super. clone();
return requirement ;
 } public void ReadValues(String RequirementID, String Project, String ModulePath, String Content, String RegFlag)
 {
this. m_RequirementID = RequirementID;
this. m_Project = Project;
this. m_ModulePath public void ParseRequirement(String TextLine)
 {

 StringTokenizer LineSt;
LineSt = new StringTokenizer(TextLine, "","");
m_RequirementID=LineSt. nextToken();
m_Project=LineSt. "
72,"Balance /**
 * Symbol represents what will be placed on the stack.
 */
private static class Symbol
{
public chartoken;
public int theLine;

public Symbol( char tok, int line )
{
token = /**
 * Constructor.
 * @param inStream the stream containing a program.
 */
public Balance( Reader inStream )
{
errors = 0;
tok = new Tokenizer( inStream );
}/**
 * Print an error message for unbalanced symbols.
 * @return number of errors detected.
 */
public int checkBalance( )
{
char ch;
Symbol match = null;
Stack pendingTokens = new Stack( );

 private Tokenizer tok;
private int errors; /**
 * Print an error message if clSym does not match opSym.
 * Update errors.
 */
private void checkMatch( Symbol opSym, Symbol clSym )
{
if( opSym. token == '(' && clSym. token != ')' ||
 /**
 * main routine for balanced symbol checker.
 * Slightly different from text.
 * If no command line parameters, standard input is used.
 * Otherwise, files in command line are used.
 */
public static void main( St"
73,"Constraints String id;
 String name;
 double value;
 String logic; Constraints(String id, String name, double value, String logic){
this. id = id;
this. name = name;
this. value = value;
this. logic = logic;
 } public String toString(){
 String temp;
 temp = ""ID = "" + id + "", Name = "" + name +"", value = "" + value + "", Logic = "" + logic;
 return temp;
 } /**
* Returns the id.
* @return int
*/
 public String getId() {
return id;
 } /**
* Returns the logic.
* @return String
*/
 public String getLogic() {
return logic;
 } /**
* Returns the name.
* @return String
*/
 public String getName() {
return name;
 } /**
* Returns the value.
* @return double
*/
 public double getValue() {
return value;
 } /**
* Sets the id.
* @param id The id to set
*/
 public void setId(String id) {
this. id = id;
 } **
* Sets the logic.
* @param logic The logic to set
*/
 public void setLogic(String logic) {
this. logic = logic;
 } /**
* Sets the name.
* @param name The name to set
*/
 public void setName(String name) {
this. name = name;
 } /**
* Sets the value.
* @param value The value to set
*/
 public void setValue( double value) {
this. value = value;
 }"
74,"database QueryConnection conn=null;
 ResultSet rs=null;
 Statement stmt=null;
 String mSQL="""";

 Vector structVector = new Vector(); // for holding the dummy variable objects used in executeStructure()
 Variable v;// create this object and /**
 * Construct a connection object.
 * @param Returns an object of type Connection
 */
 public Connection getConnection()
 {
System. out. println("" in get Connection"");
Connection connect=null;
try
{
 Class. fo /**
* Returns GraphId as int
* @param graphName performance modelHandler calls this method with graphName
* as parameter, performance modelHandler parse the EventServer message and get the
* graphName
*/
 public int get /**
* Copy data from one set of columns to other in table Variable
* @param graphId is the id of graph for which you want to save the
* current state of variables
*/
 public void saveCurrentModel( int graphId)
 {

conn = this. getConnect/**
* Injects new value into Variable table, using Data stored in
* Vector of Variable object
* @param graphId is the id of graph
* @param Vector var is the Vector that stores the Object of type Variable
*/
 public void injectVa /**
* this method will pick up the structure id from SPE Structure
* If DependentStructureId is 0 then select StructureID
* and invoke the executeStructure method on Selected
* StructureId
* Who Invokes this method: performance model // this method is about executing the structure
 // based on StructureId find all the data related to given StructureId
 // and using the equation in string format call the method equationParser.
 //I am passing Vector that has all the data abou public void solveStructure( int StructureId, Vector vr)
 {
System. out. println(""Inside solveStructure()&&&&&&&&&&&&&&&&&&&&&&&"");

Connection conn1 = this. getConnection();
System. out. println("" in solveStru public void solveStructureEquation()
 {
System. out. println(""Inside solveStructureEquation()%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"");

//Based on that result find out the equation and replace the name by its value
System public void getTrackVariableName()
 {
System. out. println(""Inside getTrackVariableName()$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"");
//This will get the variable name from SPE Graph and find the same name in variable
// and inse public void setCalculatedValues()
 {
System. out. println(""Inside setCalculatedValues()>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"");
// and at matching location put the calculated values
System. out. println("" enter calcValue // this method creates the token for each variable name in the string
 // and store that variable into vector
 // it also creates the vector called varValues
 // varValues has values of each variable stored in varName
 //So equation has variable n public Vector getImpactReport()
 {
//This SPE Graph works on the assumption that each model tracks
// the effect of changes on one variable
Vector report = new Vector();
report. add( trackVariableName);
report. add(Stri"
75,"Driver String id;
 double valueFrom;
 double valueTo;
 String name; Driver(String id, double valueFrom, double valueTo, String name)
 {
this. id = id;
this. valueFrom = valueFrom;
this. valueTo = valueTo;
this. name = name;
 } public String toString()
 {
String temp;
temp = ""ID = "" + id + "", valueFrom = "" + valueFrom + "", valueTo = "" + valueTo + "", Name = "" + name;
return temp;
 } /**
* Returns the id.
* @return int
*/
 public String getId()
 {
return id;
 } /**
* Returns the name.
* @return String
*/
 public String getName()
 {
return name;
 } /**
* Returns the value.
* @return double
*/
 public double getValueFrom()
 {
return valueFrom;
 } public double getValueTo()
 {
return valueTo;
 } /**
* Sets the id.
* @param id The id to set
*/
 public void setId(String id)
 {
this. id = id;
 } **
* Sets the name.
* @param name The name to set
*/
 public void setName(String name)
 {
this. name = name;
 } **
* Sets the value.
* @param value The value to set
*/
 public void setValueFrom( double value)
 {
this. valueFrom = valueFrom;
 } public void setValueTo( double value)
 {
this. valueTo = valueTo;
 }"
76,"Evaluatorprivate static final int EOL = 0;
private static final int VALUE = 1;
private static final int OPAREN= 2;
private static final int CPAREN= 3;
private static final int EXP = 4;
private static final int MULT= private static class Precedence
{

public int inputSymbol; // refers to the precedence level of operator
public int topOfStack; // stores the operator in the form of integer

public Precedence( int inSymbol, int // PrecTable matches order of Token enumeration
private static Precedence [ ] precTable = new Precedence[ ]
{

new Precedence( 0, -1 ),// EOL
new Precedence( 0,0 ),// VALUE
new Precedence( 100private static class Token
{

public Token( ) { this( EOL ); }

public Token( int t ) { this( t, 0 ); }

public Token( int t, double v ) {

 System. out. println("" INSIDE Token.Token()"");
 private static class EvalTokenizer {

public EvalTokenizer( StringTokenizer is ) {
 System. out. println(""INSIDE EvalTokenizer"");
 str = is;
} /**
 * Find the next token, skipping blanks, and return it.
 * For VALUE token, place the processed value in currentValue.
 * Print error message if input is unrecognized.
 */
public Token getToken /**
 * Construct an evaluator object.
 * @param s the string containing the expression.
 */
public Evaluator( String s ) {

opStack = new Stack( );
postfixStack = new Stack( );
str = new StringTokeni // The only publicly visible routine
/**
 * Public routine that performs the evaluation.
 * Examine thepostfix machine to see if a single result is
 * left and if so, return it; otherwise print error.
 * @return the result. private Stack opStack; // Operator stack for conversion
private Stack postfixStack;// Stack for postfix machine that stores the numbers could be values or result
private StringTokenizer str; // StringTokenizer stream, conte /**
 * Internal method that hides type-casting.
 * Changed the method to support double
 */
private double postFixTopAndPop( ) {
 System. out. println(""INSIDE postFixTopAndPop method"");
 System /**
 * Another internal method that hides type-casting.
 */
private int opStackTop( ) {
return ( (Integer) ( opStack. peek( ) ) ). intValue( );
} /**
 * After a token is read, use operator precedence parsing
 * algorithm to process it; missing opening parentheses
 * are detected here.
 */
private void processToken( Token lastToken ) {

System. out. printl /*
 * topAndPop the postfix machine stack; return the result.
 * If the stack is empty, print an error message.
 */
private double getTop( ) { // change to support double
 System. out. println(""INSIDE GET TOP/**
 * Internal routine to compute x^ n.
 */
private static double pow( double x, double n ) {
 System. out. println(""INSIDE pow"");

if( x == 0 ) {
 if( n == 0 ){
System. out. /**
 * Process an operator by taking two items off the postfix
 * stack, applying the operator, and pushing the result.
 * Print error if missing closing parenthesis or division by 0.
 */
private void binaryOp( int topOp/**
 * Simple main to exercise Evaluator class.
 */
public static void main( String [ ] args ) {



String str;
BufferedReader in = new BufferedReader( new InputStreamReader( System. in ) );

try {
 "
77,"Model Driver String msg=""""; public ModelDriver(String text)
 {
this. msg = text;
init();
 } public void init()
 {

System. out. println(""MODEL DRIVER CLASS 1/10"");
performance modelHandler pmh = new performance modelHandler( msg);
System. out. println(""MODEL DRIVER CLASS 2/10"");
 pmh. messageParser"
78,"Notification Event public String m_SubscriberName = """";
public String m_EventID = """";
public String m_Message type = """";
public String m_EventType = """";
public int m_NumberOfRequirements = 0;
public String m_EventTim // constructor
public Notification_Event()
{
 m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();
}// end of class Notification_Event public Object clone() throws CloneNotSupportedException
 {

// create new object with the same type
Notification_Event nEvt = (Notification_Event) super. clone();
 nEvt. m_LeftSide = new ArrayList();
 npublic void ParseEvent(String TextLine)
 {

String msg = TextLine;

if( msg. startsWith(""Re-execute"") )
{

 ModelDriver md = new ModelDriver( msg );
 md. init();

//ToDo:
// divert all the calls fo // Set the other members before calling this function

 public void ParseLeftAndRightLists(String LeftLine, String RightLine)
 {

m_LeftSide = new ArrayList();
 m_RightSide = new ArrayList();

if ( m_Eve //Comment Added by Amit Uchat
 //This method displays the contents of two array list to console
public void DisplayValues()
{
 System. out. println(""\ r\ nValues of the event:\ r\ n"");
 System. out. println("" "
79,"performance model Handler String strES; // string received from eventserver
 String impactReport;// string to be send to eventServer

 String commandStr; // represent the command ex. execute, re - execute etc
 String eventId;// refers to the eventId
 String performance model Handler(String msg)
 {
this. strES = msg;
 } public void messageParser()
 {
System. out. println(""INSIDE PARSER"");

mainSto = new StringTokenizer( strES,""|""); // current ex will have 10 tokens in mainSto


tempStr1 = mainSto. nextToken();
//Re-execut public String generateReport()
{
 System. out. println(""INSIDE generateReport"");

 mainSto = new StringTokenizer( strES,""|""); // current ex will have 10 tokens in mainSto
 /*
""ImpactReport|1015818161020| int grId; public int getId(){
 // get GraphId
 System. out. println(""database start"");
 int grId = database. getGraphId( modelName);
 return grId;
 } public void saveModel( int id)
 {
// save current model
database. saveCurrentModel( id);
 } public void insertData( int id){
// inject data into model
database. injectVariables( id, variable);
 } public void execute( int id){
// inject data into model
database. executeModel( id, variable);
 }"
80,"Requirement public String m_RequirementID ="""";
public String m_Project ="""";
public String m_ModulePath="""";
public String m_Content = """";
public String m_RegFlag = ""N"";public Requirement() {// empty constructor

} public Object clone() throws CloneNotSupportedException {

Requirement requirement= (Requirement) super. clone();

return requirement ; 
 } public void ReadValues(String RequirementID, String Project, String ModulePath, String Content, String RegFlag) {
this. m_RequirementID = RequirementID;
this. m_Project = Project;
this. m_ModulePathpublic void ParseRequirement(String TextLine) {

 StringTokenizer LineSt;
LineSt = new StringTokenizer(TextLine, "","");

m_RequirementID=LineSt. nextToken();
m_Project=Line"
81,"subscribermanager Socket aSocket;
 int ID;
 String EventLog;

 Connection conn;
 ResultSet rs;
 Statement stmt; // constructor, this object will be created in the main method of these class
 SubscriberListener() { } // constructor, this object will be created in the main method of these class
 SubscriberListener(Socket socket, int ID, String ELog)
 {

 this. aSocket = socket;
this.ID = ID;
this.EventLog = ELog;

try
{
public void sendImpactReportToEventServer(String text)
 {

//String impactReport = text;
System. out. println(""WOW IN SEND REPORT"");
System. out. println(""The IR = ""+ text);
String serverIP = ""140. // run method will be execute from the main method when u say Thread. start() in main
 public void run()
 {

System. out. println(""Inside Run method"");

String str="""";
try
{
 // set up for reading the byte data in to characte // start of class from here
 public static void main(String[] args)
 {
// default port number
int port = 1705;
// the message coming from eventserver
String LogName = ""EventLog"";
//LogName is the database name used to log t"
82,"Tokenizer /**
 * Constructor.
 * @param inStream the stream containing a program.
 */
public Tokenizer( Reader inStream )
{
errors = 0;
ch = '\0';
currentLine = 1;
in = new PushbackReader /**
 * Gets current line number.
 * @return current line number.
 */
public int getLineNumber( )
{
return currentLine;
} /**
 * Gets error count.
 * @return error count.
 */
public int getErrorCount( )
{
return errors;
} /**
 * Get the next opening or closing symbol.
 * Return false if end of file.
 * Skip past comments and character and string constants
 */
public char getNextOpenClose( )
{
while( nextChar( ) )
{
 /**
 * Return true if ch can be part of a Java identifier
 */
private static final boolean isIdChar( char ch )
{
return Character. isJavaIdentifierPart( ch );
}/**
 * Return an identifier read from input stream
 * First character is already read into ch
 */
private String getRemainingString( )
{
String result = """" + ch;

for( ; nextChar( ); result += ch )
 /**
 * Return next identifier, skipping comments
 * string constants, and character constants.
 * Place identifier in currentIdNode. word and return false
 * only if end of stream is reached.
 */
public String getNe /**
 * nextChar sets ch based on the next character in the input stream.
 * putBackChar puts the character back onto the stream.
 * It should only be used once after a nextChar.
 * Both routines adjust currentLine if necess private void putBackChar( )
{
if( ch == '\ n' )
currentLine--;
try
{ in. unread( ( int) ch ); }
catch( IO Exception e ) { }
} /**
 * Precondition: We are about to process a comment; have already seen
 * comment-start token
 * Post condition: Stream will be set immediately after
 * comment-ending token
 */
private/**
 * Precondition: We are about to process a quote; have already seen
 * beginning quote.
 * Post condition: Stream will be set immediately after
 * matching quote
 */
private void skip /**
 * After the opening slash is seen deal with next character.
 * If it is a comment starter, process it; otherwise put back
 * the next character if it is not a new line.
 */
private void processSlash( )
{
ifpublic static final int SLASH_SLASH = 0;
public static final int SLASH_STAR= 1;

private PushbackReader in;// The input stream
private char ch;// Current character
private int currentLine;//"
83,"Variable String id = """"; // requirement id ex WB10
 String type= """"; // type of requirement ex Driver or Constraints
 String name= """"; // requirement name which is same as variable name in graph
 double value= 0.0; // value of variable
 double speculat //General Constructor to initialize all the members
 Variable(String id, String type, String name, double value, double speculateValue, String logic, String project_ path)
 {
this. id = id;
this. type = type;
this.//Constructor to Add driver related members
 Variable(String id, String type, String name, double value, double speculateValue)
 {
this. id = id;
this. type = type;
this. name = name;
this. value = value;
this //Constructor to Add constraints related members
 Variable(String id, String type, String name, double value, String logic){
this. id = id;
this. type = type;
this. name = name;
this. value = value;
this. logicpublic String toString()
 {
String temp;
temp = ""ID = "" + id + "", Type = "" + type + "", Name = "" + name +"", value = "" + value +
 "", SpeculateValue = "" + speculateValue + "", Logic = "" + logic + "", Project_Path = "" + project_ path /**
* Returns the id.
* @return int
*/
 public String getId()
 {
return id;
 } /**
* Returns the logic.
* @return String
*/
 public String getLogic()
 {
return logic;
 } /**
* Returns the name.
* @return String
*/
 public String getName()
 {
return name;
 } /**
* Returns the value.
* @return double
*/
 public double getValue() {
return value;
 } /**
* Sets the id.
* @param id The id to set
*/
 public void setId(String id) {
this. id = id;
 } /**
* Sets the logic.
* @param logic The logic to set
*/
 public void setLogic(String logic) {
this. logic = logic;
 } /**
* Sets the name.
* @param name The name to set
*/
 public void setName(String name) {
this. name = name;
 } /**
* Sets the value.
* @param value The value to set
*/
 public void setValue( double value) {
this. value = value;
 } /**
* Returns the speculateValue.
* @return double
*/
 public double getSpeculateValue() {
return speculateValue;
 } /**
* Sets the speculateValue.
* @param speculateValue The speculateValue to set
*/
 public void setSpeculateValue( double speculateValue) {
this. speculateValue = speculateValue;
 } /**
* Returns the type.
* @return String
*/
 public String getType() {
return type;
 } /**
* Sets the type.
* @param type The type to set
*/
 public void setType(String type) {
this. type = type;
 } /**
* Returns the project_ path.
* @return String
*/
 public String getProject_ path() {
return project_ path;
 } /**
* Sets the project_ path.
* @param project_ path The project_ path to set
*/
 public void setProject_ path(String project_ path) {
this. project_ path = project_ path;
 }"
84,"White Board Execution Graph //Driver data members
 double avgShapeSize_Original;
 double avgShapeSize_Speculate;

 // constraints data members
 double avgTextSize;
 double writeTime;
 double noShapes;
 double noTextItems;
 double bandWidth public WhiteBoardExecutionGraph(Vector driver, Vector constraints){
this. driver = driver;
this. constraints = constraints;
 }// end of constructor public String toString(){
 String result;

 result = "" avgShapeSize_Original = "" + avgShapeSize_Original +
"",\ navgShapeSize_Speculate = "" + avgShapeSize_Speculate +
"",\ navgTextSize = "" + avgTextSizepublic void injectDrivers(){
System. out. println(""\ t\ tINSIDE INJECT DRIVERs METHOD"");
//To Do: Run for loop for more then one drivers
//To Do: have a case insensitive check for driver name and then populate the data member public void injectConstraints(){
System. out. println(""\ t\ tINSIDE INJECT CONSTRAINTs METHOD"");

//To Do: have a case insensitive check for constraints name and then populate the data member
//System. out. println( const public double timeToBroadcastShapeBefore(){
System. out. println(""\ t\ t\ tINSIDE timeToBroadcastShapeBefore METHOD"");

double targetResponse time_ temp = 0.00;

 for( int i=0; i< noShapes; i++ public double timeToBroadcastShapeAfter(){
System. out. println(""\ t\ t\ tINSIDE timeToBroadcastShapeAfter METHOD"");

double targetResponse time_ temp = 0.00;

 for( int i=0; i< noShapes; i++){ public double timeToBroadcastText(){
System. out. println(""\ t\ t\ tINSIDE timeToBroadcastText METHOD"");

double targetResponse time_ temp = 0.00;

 for( int i=0; i< noTextItems; i++){

 target public double writeTime(){
System. out. println(""\ t\ t\ tINSIDE writeTime METHOD"");

System. out. println(""\ t\ t\ t\ tTotal time to write = "" + writeTime);

System. out. println(""\ t\ t\ tLEAVING w public double targetResponseTimeBefore(){
System. out. println(""\ t\ tINSIDE targetResponseTimeBefore METHOD\ n"");

targetResponse time = timeToBroadcastShapeBefore() +
timeToBroadcastText()public double targetResponseTimeAfter(){
System. out. println(""\ t\ tINSIDE targetResponseTimeAfter METHOD\ n"");

targetResponse time = timeToBroadcastShapeAfter() +
timeToBroadcastText() + w"
85,"Decompose Model public DecomposeModel(EBT em)
{
super( em);
MinimumNoRects = 3;
 }// Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(20,20,1);
AddEventRect(60,70,1);
AddEventRect(60,120,1);
AddEventRect public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
StringBuffer temp = new StringBuffer();
int Count = -1;
thisEvent. append(""Decompose|"");

for ( int i = 0; i < EventShapes"
86,"EB Shape private int x, y;
 private String requirement No;
 private String ProjectName, ModulePath;
private Color c; public EBShape( int xpos, int ypos, Color col)
 {
x = xpos;
y = ypos;
c = col;
requirement No = """";
ProjectName = """";
ModulePath = """";
 } public void Updaterequirement Info(String rno, String pname, String mname)
 {
requirement No = rno. trim();
ProjectName = pname. trim();
ModulePath = mname. trim();
 } public boolean match( int mx, int my)
 {
return true;

 } public int GetX()
 {
return x;
 } public int GetY()
 {
return y;
 } public Color GetC()
{
return c;
 } public String GetReqno()
 {
return requirement No;
 } public String GetProject()
 {
return ProjectName;
 } public String GetModule()
 {
return ModulePath;
 }"
87,"EBTprivate JSplitPane splitPane;
private JSplitPane splitPane2;
private Frame FrameParent;
private JPanel MenuPanel;
private TextModel WorkArea;
private EventModel VisualPanel;
private MergeModel M public EBT(Frame f)
{

FrameParent = f;
CurrentEvent = -1;

this. serverIP =
 JOptionPane
. showInputDialog(""Please Enter the IP Address of eventserver"")
. trim();

 // Set up JList Selection wid public void getrequirement Text(EBShape sh)
{
WorkArea. showText( sh);
 } public boolean mouseDown( java. awt.Evente, int x, int y)
 {
 return true;
 }public boolean mouseUp( java. awt.Evente, int x, int y)
{
return true;
 } public void mouseClicked( java. awt. event.MouseEvente)
{
VisualPanel.Clicked( e. getX(), e. getY());
} public void mouseExited( java. awt. event.MouseEvente){} public void mousePressed( java. awt. event.MouseEvente){} public void mouseReleased( java. awt. event.MouseEvente){}public void mouseEntered( java. awt. event.MouseEvente){} public void paint(Graphics g) {} public void update(Graphics g) {} public JSplitPane getSplitPane()
{
return splitPane;
} public void valueChanged(ListSelectionEvent e)
{
if ( e. getValueIsAdjusting())
return;
} private class ValueReporter implements ListSelectionListener
{

public void valueChanged(ListSelectionEvent event)
{
 if (! event. getValueIsAdjusting())
 {
switch(EventList. getSelectedIndex())
public void RedrawAll(EBShape sh)
{
VisualPanel. drawModel( sh);
VisualPanel.CheckNotifyStatus();
} public static void main(String s[])
{
JFrame mainframe = new JFrame(""Trigger an Event Notification"");

mainframe. addWindowListener( new WindowAdapter()
{
public void windowClosing(Wind"
88,"Event Model 
protected Vector EventShapes = new Vector();
protected Vector EventLines = new Vector();
protected EB Shape ebs, ebs2;
protected EventLine mline;
protected Color ShapeColor = new Color (190,190,190);
 public EventModel(EBT e)
{
ebt = e;
CurrentEvent = -1;
NotifyButton = new JButton(""Notify"");
setLayout( null);
NotifyButton. setBounds(305,265,80,25);
MinimumNoRects = 1;

add public void getIP Server( String serverIP)
 {

this. serverIP = serverIP;
 } public void ClearVectors()
{
EventShapes. removeAllElements();
EventLines. removeAllElements();
}public void drawModel()
{
repaint();
} public void drawModel(EBShape sh)
{
EventShapes. setElementAt( sh, ESCursor);
repaint();
} private void ClearData()
{
for ( int i = 0; i < EventShapes. size(); i++)
{
ebs = (EBShape)EventShapes. elementAt( i);
ebs.Updaterequirement Info("""","""","""");
 }
}public void Clicked ( int x, int y)
{
int Hit = 0;
for ( int i = 0; i < EventShapes. size(); i++)
{
 ebs = (EBShape)EventShapes. elementAt( i);

if (( x >= ebs.GetX() && ( x <= ebs public void CheckNotifyStatus()
 {
//Check if Minimum Standards have been met.
int j = 0;
for ( j = 0; j < MinimumNoRects; j++)
{
ebs2 = (EBShape)EventShapes. elementAt( j);

 if (((((protected void BuildEvent(){} protected void AddLine( int t, int l, int r, int b)
{
EventLines. addElement( new EventLine( t, l, r, b));
} protected void AddEventRect( int x, int y, int colorStatus)
{
if ( colorStatus == 1)
{
 EventShapes. addElement( new EBShape( x, y, new Color (100,100,100)));
 }
 else
 {
Even public String getrequirement Text(String r, String p, String m)
{
return new String(""requirementwill go here"");
 } public StringBuffer GenerateEvent()
{
return new StringBuffer("" "");
 }// end of GenerateEvent method protected void paintComponent(Graphics g)
{
super. paintComponent( g);
for ( int i = 0; i < EventShapes. size(); i++)
{
ebs = (EBShape)EventShapes. elementAt( i);
 g. setC"
89,"Event Line protected int top, left, right, bottom; public EventLine ( int t, int l, int r, int b)
{
top = t;
left = l;
right = r;
bottom = b;
} public int GetT() { return top;} public int GetL() { return left;}public int GetR() { return right;} public int GetB() { return bottom;}"
90,"Merge Model public MergeModel(EBT em)
 {
super( em);
 MinimumNoRects = 3;
 } // Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(90,220,1);
 AddEventRect(20,20,1);
AddEventRect(20,70,1);
AddEvent public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
StringBuffer temp = new StringBuffer();
int MergeCount = -1;
thisEvent. append(""Merge|"");

for ( int i = 0; i < EventSha"
91,"Modify Model public ModifyModel(EBT em)
{
super( em);
 } // Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(60,80,1);
CurrentEvent = 4;
} public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
thisEvent. append(""Modify|0|"");
thisEvent. append( new Date(). toString()+ ""|"");
 ebs = (EBShape)EventShapes protected void paintComponent(Graphics g)
{
g. drawString(""TESTING MODIFY"",5,5);
super. paintComponent( g);
 }"
92,"New Modelpublic NewModel(EBT em)
{
super( em);
 } // Construct Visual model for Merge Event
public void BuildEvent()
{
ClearVectors();
AddEventRect(60,80,1);
AddArrow(35,97,59,97);
CurrentEvent = 0;
} public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
thisEvent. append(""New|0|"");
thisEvent. append( new Date(). toString()+ ""|"");
ebs = (EBShape)EventShapes. elem"
93,"Obsolete Modelpublic ObsoleteModel(EBT em)
{
super( em);
 } // Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(60,80,1);
AddLine(60,60,225,135);
AddLine(60,135,225,60);
CurrentEve public StringBuffer GenerateEvent()
 {
StringBuffer thisEvent = new StringBuffer();
thisEvent. append(""Obsolete|0|"");
thisEvent. append( new Date(). toString()+""|"");
ebs = (EBShape)EventShapes. e"
94,"Refine Modelpublic RefineModel(EBT em)
{
super( em);
 } // Construct Visual model for Merge Event
public void BuildEvent()
{
 ClearVectors();
AddEventRect(60,80,1);
CurrentEvent = 3;
} public StringBuffer GenerateEvent()
{
StringBuffer thisEvent = new StringBuffer();
thisEvent. append(""Refine|0|"");
thisEvent. append( new Date(). toString()+""|"");
ebs = (EBShape)EventShapes. el"
95,"Text Model private int CurrentEvent;
private EBT ebt;
private JLabel lblrequirement No, lblProject, lblModulePath;
private JTextField txtrequirement No, txtProject, txtModulePath;
private boolean HideMsg;
p public TextModel(EBT e)
{
 // System. out. println(""Trying to create text box"");
ebt = e;
CurrentEvent = -1;
// setForeground( new Color ( 255,255,255) );
 lblrequirement No = new JLabel(""requirement public void showText(EBShape sh)
{
 // Hide message in bottom box.
 HideMsg = true;
 repaint();
lblProject. setVisible( true);
lblrequirement No. setVisible( true);
lblModulePath. set public void HideText()
{
lblProject. setVisible( false);
lblrequirement No. setVisible( false);
lblModulePath. setVisible( false);
txtProject. setVisible( false);
txtrequirement No. setVisi public void ShowInfo( int CE)
{
CurrentEvent = CE;
HideMsg = false;
HideText();
 repaint();
} public void drawModel()
{
repaint();
} protected void paintComponent(Graphics g)
{
 super. paintComponent( g);

if (HideMsg == true)
{
 g. drawString("" "",20,25);
 g. drawString("" "",20,40);
 g. drawString("" "",20,55 "
46,
46,
46,
46,
46,
46,
46,
47,
47,
47,
47,
47,
47,
47,
47,
47,
47,
47,
47,
48,
48,
48,
48,
48,
48,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
49,
50,
50,
50,
50,
50,
50,
50,
50,
50,
50,
50,
50,
50,
50,
50,
50,
50,
50,
50,
50,
51,
51,
51,
52,
52,
52,
52,
52,
52,
52,
53,
53,
53,
53,
53,
53,
53,
53,
53,
53,
53,
53,
53,
53,
53,
53,
53,
54,
54,
55,
55,
55,
55,
55,
55,
55,
55,
56,
56,
56,
56,
56,
56,
56,
56,
57,
57,
57,
57,
57,
57,
57,
58,
58,
58,
58,
58,
58,
58,
59,
59,
59,
59,
59,
59,
60,
60,
60,
60,
60,
60,
61,
61,
61,
62,
62,
62,
62,
62,
62,
62,
63,
63,
63,
64,
64,
65,
65,
66,
66,
66,
66,
66,
67,
67,
67,
67,
67,
67,
67,
68,
68,
68,
68,
68,
68,
68,
68,
68,
68,
68,
68,
68,
69,
69,
69,
69,
69,
69,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
71,
71,
71,
71,
71,
72,
72,
72,
72,
72,
72,
73,
73,
73,
73,
73,
73,
73,
73,
73,
73,
73,
74,
74,
74,
74,
74,
74,
74,
74,
74,
74,
74,
74,
74,
75,
75,
75,
75,
75,
75,
75,
75,
75,
75,
75,
76,
76,
76,
76,
76,
76,
76,
76,
76,
76,
76,
76,
76,
76,
76,
76,
77,
77,
77,
78,
78,
78,
78,
78,
78,
79,
79,
79,
79,
79,
79,
79,
79,
79,
80,
80,
80,
80,
80,
81,
81,
81,
81,
81,
81,
82,
82,
82,
82,
82,
82,
82,
82,
82,
82,
82,
82,
82,
83,
83,
83,
83,
83,
83,
83,
83,
83,
83,
83,
83,
83,
83,
83,
83,
83,
83,
83,
84,
84,
84,
84,
84,
84,
84,
84,
84,
84,
84,
85,
85,
85,
86,
86,
86,
86,
86,
86,
86,
86,
86,
86,
87,
87,
87,
87,
87,
87,
87,
87,
87,
87,
87,
87,
87,
87,
87,
87,
87,
88,
88,
88,
88,
88,
88,
88,
88,
88,
88,
88,
88,
88,
88,
88,
89,
89,
89,
89,
89,
89,
90,
90,
90,
91,
91,
91,
91,
92,
92,
92,
93,
93,
93,
94,
94,
94,
95,
95,
95,
95,
95,
95,
95,
Document_No,
