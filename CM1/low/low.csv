id;text
DPUSDS4.0;Software Architecture	The following sections specify the architectural design of the INSTRUMENT X DPU FSW.  The architectural design consists of  * an overview of the software layers,
DPUSDS4.0;Software Architecture	The following sections specify the architectural design of the INSTRUMENT X DPU FSW.  The architectural design consists of   * a list of the CSCs comprising the DPU FSW,
DPUSDS4.0;Software Architecture	The following sections specify the architectural design of the INSTRUMENT X DPU FSW.  The architectural design consists of   * an overall application design diagram,
DPUSDS4.0;Software Architecture	The following sections specify the architectural design of the INSTRUMENT X DPU FSW.  The architectural design consists of   * a description of the execution model and operating states,
DPUSDS4.0;Software Architecture	The following sections specify the architectural design of the INSTRUMENT X DPU FSW.  The architectural design consists of   * a top-level memory map, and
DPUSDS4.0;Software Architecture	The following sections specify the architectural design of the INSTRUMENT X DPU FSW.  The architectural design consists of   * a description of the development platform, language, and compiler.
DPUSDS4.4.1;Startup Sequence	The DPU FSW is booted using PROM-resident bootstrap software.  The bootstrap software performs a basic set of built-in tests, then copies the DPU FSW from EEPROM to DRAM and executes it.  In flight, there are two methods which can trigger the DPU FSW to boot: * power-on (cold boot), or * watchdog reset (warm boot, commanded reboot).
DPUSDS4.4.1;Startup Sequence 	On flight, a power cycle can only be effected by the SCU.  A watchdog reset could be induced by the DPU FSW due to a detected, unrecoverable error, or it could occur as a by-product of the FSW entering a state in which it fails to strobe the watchdog timer.  On boot, the bootstrap tests and clears DRAM, and then proceeds to load the DPU FSW from EEPROM and executes it.  The DPU FSW then loads configuration information from EEPROM (which establishes various operational defaults) and spawns the various DPU FSW tasks.
DPUSDS4.4.3;four prioritized tasks  Then the DPU FSW is booted, it initially consists of four prioritized tasks, which are described below:  * The Exception Handler Task (excTask) is a VxWorks<99> operating system task which responds to any hardware exception that might occur during the course of program execution.  If an exception occurs, the Exception Handler suspends the offending task.  The Exception Handler is customized such that if an unrecoverable exception occurs, it will attempt to record the cause of the exception to EEPROM and reboot the DPU by disabling the watchdog strobe. * The Command and Control Task (ccmCtrlTask) is an Application Framework Software task which is responsible for spawning the remaining DPU FSW tasks and initializing the DPU FSW. the Command and Control Task then remains active to perform the remaining periodic processing tasks such as housekeeping collection and overall DPU FSW monitoring. it facilitates memory loads and dumps, and serves as the central point for error reporting. * The Log Task (logTask) is a VxWorks<99> operating system task which is used to log program output during software development and ground integration and test (I&T).  The task is left in the flight build in order to avoid different builds for ground testing vs. on orbit operations. * The Shell Task (shell) is a VxWorks<99> operating system task which provides a command-line interface to the DPU FSW during software development and ground I&T.  The task is left in the flight build in order to avoid different builds for ground testing vs. on orbit operations.  The task normally sits idle during on orbit operations.  However, it is possible to invoke the shell on orbit by way of a special ground command in the event it is necessary to diagnose an off-nominal condition or to install a software patch.
DPUSDS4.4.3;remaining DPU FSW tasks	Following startup, the Command and Control Task spawns the remaining DPU FSW tasks, which are described below:  * The Command Dispatch Task (ccmCmdTask) is an Application Framework Software task which is responsible for dispatching commands which arrive from the ICU or the SCU.  Commands are executed directly by this task by calling the applicable CSC function * The SCU Interface Task (scuiDPTask) receives telemetry data from other tasks, converts them to CCSDS Version 1 Source Packets, forms Company X Telemetry Protocol Data Units (STPDUs) from the Source Packets, and transmits the STPDUs to the SCU via the MIL-STD-1553B Interface. * The Telescope Module Event Transfer Task (tmaliTask) is an Application Framework Software task which is responsible for transferring data from the DCI ping/pong buffers to the TMALI data buffer in response to a DCI frame limit or data timeout interrupt. * The Data Compression Task (dcxTask) receives telemetry data from other tasks, uses a lossless data compression algorithm to compress the data, and then enqueues the data to the SCU Interface Task. * The Data Processing Algorithms Tasks (dpaIMTask and dpaEPTask) process incoming detector events according to the commanded mode, create data products, and enqueue those data products to the Data Compression Task (if compression is enabled) or to the SCU Interface Task. * The Error Detection and Correction Memory Scrubber Task (edacTask) cycles through the text and data segments of the DPU to trigger the correction of single-bit errors which may have occurred, in order to help prevent the occurrence of uncorrectable multiple-bit errors.
DPUSDS4.5.0;types of external (VME) interrupts	The DPU has five types of external (VME) interrupts:  * MIL-STD-1553 Interface Interrupts, * DCI Interface Interrupts, * SSI Interface Interrupts, * Memory EDAC Interrupt, and * Ethernet Interrupt (ground use only).
DPUSDS4.5.0;"interrupt service routine (ISR)	The DPU responds to interrupts via an interrupt service routine (ISR).  VME interrupts are prioritized; however the DPU does not allow nested interrupts, and so any interrupts which occur while servicing another interrupt will pend until the current ISR has returned."
DPUSDS4.5.0;Development Platform	The DPU FSW will be implemented in the ANSI C programming language, with some PowerPC assembly used in the Bootstrap and to implement the VME data transfer in the DCI Driver.  The host (development) platform and operating system is Sun/Solaris™ from Sun Microsystems, Inc.  The target platform is the RAD6000 processor which has a POWER (PowerPC-like) architecture, and executes the VxWorks™ 5.3.1 real-time operating system.  The cross compiler and debugger is MULTI/C/C++ 1.8.9 from Green Hills Software, Inc.
DPUSDS5.1.0;Bootstrap CSC	The Bootstrap CSC is a Level 1 reuse component from the SSFF and INSTRUMENT Y projects. The Bootstrap for the Company X DPU will be nearly identical to that used on the INSTRUMENT Y CIDP and SCU, with the exception of minor hardware interface differences: * The interface to the hardware watchdog timer is different on the Company X DPU versus that used on the INSTRUMENT Y CIDP/SCU. * The interface to the mission elapsed time (MET) clock is different on the Company X DPU versus that used on the INSTRUMENT Y CIDP/SCU. * The INSTRUMENT Y bootstrap was able to discern a cold (power-on) boot from a warm (watchdog reset) boot by examining the value of the MET clock, which did not reset to zero on a warm boot.  The Company X DPU MET clock resets to zero on both a cold and warm boot, and so there is no distinction in the Company X bootstrap.
DPUSDS5.1.0;initial boot sequence	the initial boot sequence, identified as Boot Sequence 1.  This processing takes place when the Bootstrap executes from Programmable Read-Only Memory (PROM).  Boot Sequence 1 is composed primarily of 4 steps as follows. First, in this sequence, EEPROM is updated.  Then, CPU BIT and a portion of DRAM BIT is performed.  Next, DRAM is cleared.  Lastly, Boot Sequence 2 is copied to DRAM and executed. During this sequence, the rest of DRAM is tested if skipBit is not set.  Load parameters are put into registers r13, r14, r15 and r16.  DRAM is cleared up to memSize.  Lastly, either the DPU-RTOS or the Bootstrap Monitor is loaded and executed according to the load parameters.
DPUSDS5.1.1;Reserved Registers	Reserved registers facilitate passing data between portions of the Bootstrap.
DPUSDS5.1.2;Built-In Test	There are two stages of Built-In Tests (BIT) for the DPU.  The Stage 1 BIT is included in the Bootstrap program and consists of Central Processing Unit (CPU) BIT, and Dynamic Random Access Memory (DRAM) BIT.  The Stage 2 BIT is executed after the operating system is booted and is not part of the Bootstrap program.
DPUSDS5.1.2;CPU BIT	The CPU BIT consists of a series of tests designed to test each of the functional units of the processor.  These include test for the Branch-Unit, the Fixed-Point Unit, the Floating-Point Unit, the Interrupt-Unit, and the Timer Unit.   Each of these tests consists of executing a few selected instructions from the this functional unit. The General Purpose Registers (GPR), the Segment Registers (SR), the Counter Register (CTR), and the Condition Register are tested for stuck-bits as part of the Branch-Unit test.  This is done by writing a 1’s pattern (verified by reading it back) and then writing a 0’s pattern (verified by reading it back).
DPUSDS5.1.2;DRAM BIT	Part of the memory is tested in Boot Sequence 1, and part of the memory is tested during Boot Sequence 2.  During Boot Sequence 1, ? KB of DRAM is tested before the Bootstrap is copied to this area.  During Boot Sequence 2, the  remaining memory is tested in ? KB blocks. The DRAM BIT first writes the address of each word in a block to that word in the block.   Then the test flushes the cache and reads back the entire block.  If a single-bit error occurs on the read-back, the location is read again.  If another single-bit error occurs, the test assumes a hard error and marks the whole block bad.  If a multiple-bit error occurs, the whole block is marked bad.  If the value read back does not match the address, the whole block is marked bad.  This same process is repeated with the one’s complement of the address. The Bootstrap stores the results of the DRAM BIT in EEPROM as a series of x consecutive y-bit words.  Each bit in a result word represents the result of testing a ? KB block of DRAM.  These bits are mapped to DRAM by proceeding from least-significant bit (LSb) to most-significant bit (MSb) as the addresses of the memory blocks increase.  A set bit indicates that a block of DRAM has failed.  A clear bit indicates that a block of DRAM has passed the test.
DPUSDS5.1.3;Hardware Interfaces	The DPU-BOOTSTRAP must interface directly with the EEPROM on the Company X Communication Module.  The DPU-BOOTSTRAP accesses EEPROM as ?-bit words only.  The specific timing requirements of the EEPROM are satisfied in one of three ways: * the timing requirements are met by inserting specific wait loops (typical), * the timing requirements are met by use of the EEPROM Driver (DOWNLOAD command), and the timing requirements are met implicitly by the amount of time which will be required to execute the intervening instructions regardless of the CPU speed setting (DRAM test logic).
DPUSDS5.1.4;Hardware Exceptions	The Bootstrap ignores any hardware exceptions that might occur while it is running.  If an exception occurs, the Bootstrap simply resumes execution with the next instruction following the one at which the exception occurred.
DPUSDS5.1.4;Bootstrap Monitor	The Bootstrap Monitor checks entered commands for syntax and number of arguments, and displays an error message to the RS-232 interface if an invalid command or argument is entered.  A complete listing of these messages is given in document 7384-BSPS-01.
DPUSDS5.10.0;EEPROM Driver CSC	The EEPROM Driver (EEPRM) CSC is a Level 1 reuse component from the SSFF and INSTRUMENT Y projects.  The EEPROM Driver CSC provides an API to the EEPROM on the SCM.  The design of the INSTRUMENT Y EEPROM Driver is described in document CIDPSDS-01.  The EEPROM Driver for the Company X DPU will be nearly identical to that used on the INSTRUMENT Y CIDP and SCU, with the exception of changes driven by hardware differences.  The design changes impact only constant #defines within the included header files.
DPUSDS5.11.0;EEPROM File System CSC 	EEPROM File System (EEFS) CSC is a Level 1 reuse component from the INSTRUMENT Y project.  The EEFS CSC provides an MS-DOS compatible file system on the SCM EEPROM.  The File System is created by using the dosFs File System included in VxWorks® with a standard VxWorks® block driver.
DPUSDS5.12.0;"Command and Control CSC	The Command and Control (CCM) CSC is a Level 2 reuse component from the INSTRUMENT Y project.  The Command and Control CSC includes the following components: * A Control Task, ccmCtrlTask(), which initializes the DPU FSW and spawns other tasks at bootup, schedules the production of DPU housekeeping data packets, monitors the execution of other tasks, and schedules the execution of other periodic tasks such as the heartbeat message and the watchdog strobe; and * A Command Dispatch Task, ccmCmdTask(), which receives and dispatches real-time commands received from the SCU or the ICU. Major data structures include: * A Static Data table that keeps track of the operational state.  Data included in this table includes housekeeping production rates, CCM specific flags, and the number of commands executed. * A Command Queue into which commands are placed when they arrive, via interrupt, from the ICU or the SCU. * An Error/Event Queue which accumulates error and event codes which are reported by the DPU FSW.  These error and event codes are removed from the queue and placed into a telemetry packet at a given interval and included in DPU housekeeping data.  DPUSDS5.12.1.1.1	Flight Software Initialization	The Command and Control CSC is initialized by spawning the CCM Control Task, ccmCtrlTask(), from the operating system startup task, usrRoot().  After the task is spawned it calls a function, ccmInit(), which creates the error/event queue, instantiates needed semaphores and installs various ISRs.  Finally, it spawns the remaining tasks which comprise the DPU FSW. When the CCM Control Task starts up, it reads DPU configuration startup defaults from the SYSTEM_CONFIG_AREA in EEPROM.  If the SYSTEM_CONFIG_AREA checksum is bad, hard-coded defaults are used.  The CCM Control Task initializes the remaining CSCs by calling the applicable initialization function, or if the CSC has an associated task, by spawning the task using the VxWorks® function, taskSpawn().  When the CCM Control Task initializes a CSC, it passes the startup defaults read from EEPROM as parameters to the task initialization function. In addition to its task initialization activities, ccmInit(), also initializes the command length verification table by calling ccmCmdLengthInit().  The command processor uses the created table to verify expected command lengths for newly received commands."
DPUSDS5.12.1.2;Control and Monitoring	the CCM Control Task initializes the DPU FSW. It is the responsibility of the CCM Control Task to establish a successful boot.  It does so by blocking on temporary semaphores, each with a 5 second timeout, after spawning the SCU Interface Task and the CCM Command Task.  If both of these tasks report a successful initialization by giving the semaphore, the CCM Control Task toggles the BC_INDEX parameter in EEPROM to indicate a successful boot.  If either task does not report a successful initialization, the CCM Control Task disables the watchdog strobe to effect a reboot of the DPU.  The rationale for selecting the successful initialization of these two tasks as the definition of a successful boot is that the DPU FSW requires these tasks, as a minimum, to establish ground contact and provide commandability.Once this initialization is complete, the task blocks on a binary semaphore which is given by the SCUI Command ISR upon arrival of the 1 Hz Clock Message.  In the event a Clock Message does not arrive, the semaphore will time out after 1.5 seconds.  The CCM Control Task remains alive to create and transmit DPU housekeeping at the appropriate intervals, perform various periodic processing tasks, and to process memory dump commands.	The final call to ccmErrEnq() is performed in order that if an error occurs in an interrupt service routine, a global variable is set to the value of the errno which is then enqueued into the Error/Event Queue as part of this task’s normal processing.
DPUSDS5.12.1.2;Control and Monitoring	The DPU produces eight types of housekeeping packets.
DPUSDS5.12.1.2;Control and Monitoring	Every time the CCM Control executes, it calls ccmPerProcess() to handle periodic processing responsibilities.  Such responsibilities include analog to digital conversion updates, DPU task monitoring, ICU heartbeat message production, and watchdog strobe. The ccmHealthChk() function, called by ccmPerProcess() verifies the execution of other tasks by monitoring the amount of time that has elapsed since each task last reported.  Other tasks report their execution to the CCM Control Task by calling the function, ccmTaskReport(), providing their task index.  Each task has an expected execution frequency, and if a task does not execute as expected, an error is reported in DPU housekeeping.  If the Command Dispatch Task fails to report for an extended period, the DPU will execute a reboot, since it is impossible to command the DPU if this task is not executing, otherwise it will strobe the watchdog
DPUSDS5.12.1.2;Control and Monitoring	the CCM Control Task also handles memory dump commands.  In the event of a data dump command, the CCM Control Task will break the dump into manageable pieces and dump a small portion at a time, each time the task is awakened.  The purpose of this “deferred” activity is to prevent a large dump from consuming available CPU time by keeping the high-priority CCM Command Dispatch Task busy for an extended period.
DPUSDS5.12.1.3;Command Handling	The DPU accepts commands via two interfaces – from the Spacecraft via the MIL-STD-1553 interface, and from the ICU via the SSI interface.  Any of the DPU commands can be sent from the SCU or the ICU.  The source for a command from the DPU is one of the following: * ICU – command is generated and sent by the ICU via the SSI. * SCU – command is generated and sent by the SCU via the 1553. * G-ICU – command is generated on the ground and sent to the DPU via the ICU/SSI. * G-SCU – command is generated on the ground and sent to the DPU via the SCU/1553.
DPUSDS5.12.1.3;Command Handling	When a command arrives from the SCU (via the 1553 interface) or the ICU (via the SSI interface), the respective ISR will enqueue the command packet into a Command Queue, and then give the semaphore to awaken the ccmCmdTask().  Since it is possible for the DPU to send a command to itself, commands may arrive at interrupt context or task context.  Therefore the CCM maintains two queues – one for interrupt context which is not semaphore protected, and one for task context which is semaphore protected.
DPUSDS5.12.1.3;Command Handling	Commands are dequeued from the Command Queue and executed by the Command Dispatch Task, ccmCmdTask().  This task blocks on a semaphore which is given by ccmCmdEnq(). The ccmCmdTask() wakes on the semaphore and calls ccmCmdProcess() to process waiting commands.  The ccmCmdProcess() function subsequently retrieves waiting commands from the Command Queue and invokes ccmCmdDispatch() to verify the expected length of the command and execute it.  If command echo is enabled, ccmCmdDispatch() will call ccmHkMkCmdEcho() to blindly echo the command back to the ground.  Counts for both rejected and executed commands are maintained. If the command sent to ccmCmdEnq() is either a 1 Hz Clock Time message or an Attitude message from the spacecraft, the command will not be forwarded to the Command Queue, but instead will be executed directly while still in interrupt context.  Attitude messages are forwarded to dpaCommandSend(), while the 1 Hz Clock Time message’s parameters are passed to tisTimeSync() in order to synchronize the current time.  Any other non DPU or spacecraft observatory messages are quietly discarded without reporting an error.In order to guarantee that ccmCmdTask() task reports in with the CCM Control Task periodically in absence of a ground command, the semaphore has a timeout value of 20 seconds.  If the semaphore times out, the task will verify no commands are on the Command Queue, and then report in to the CCM Control Task by calling ccmTaskReport().
DPUSDS5.12.1.4;Memory Upload and Download Handling	There are two ways to upload data to the DPU: * Memory Poke (D_MEM_DAT_POKE command), or * Memory Upload (D_MEM_DAT_UPLD command). The memory poke command is used when a small (<=Z bytes) of data need to be poked into a DPU memory location.  The Z byte limitation is derived from the Company X command length constraint.
DPUSDS5.12.1.4;Memory Upload and Download Handling	When larger amounts of memory must be uploaded to the DPU, such as in the case of a software patch or full software upload, the regular memory upload is used.  Memory uploads are accomplished by sending a series of individual D_MEM_DAT_UPLD commands, resulting in a single “virtual” upload. CCSDS-like sequence (grouping) flags are employed to allow the DPU FSW to accept up to a maximum of 65535 bytes in a single “virtual” upload.  The data contained in each D_MEM_DAT_UPLD command is stored in a temporary DRAM buffer until all of the sequence numbers in the entire upload have been successfully received.  When the DPU FSW receives the last command in the series, the FSW will verify that all sequence numbers have been received, verify the end-end upload checksum, and then write the entire temporary buffer to the target location specified in the first upload command.
DPUSDS5.12.1.4;Memory Upload and Download Handling	If more than 65535 bytes need to be uploaded, the upload file must be broken up into multiple smaller files, each less than or equal to 65535 bytes, and then each of the virtual uploads should be sent in series.  Because of the sequence numbers, the DPU FSW can receive individual upload commands out of sequence.  There is no time limit for the accomplishment of a single virtual upload, and so a long upload can continue across ground contacts.  If an upload is in progress, the last sequence number can be sent to the DPU FSW and it will report the list of missing sequence numbers via event number S_ccm_MISSING_SEQNO.  If an upload is in progress and needs to be cancelled, it can be discarded by issuing the D_MEM_DAT_CNCL command.
DPUSDS5.12.1.4;Memory Upload and Download Handling	Data can be upload to several types of locations, including * DRAM * EEPROM * hardware registers, and * EEPROM filesystem. ial D_MEM_DAT_UPLD command specify the target location.  If the destination is the EEPROM filesystem, a “block number” is provided in lieu of a memory address , which is used by the DPU FSW to formulate a filename of the form eefs1:DPU_blk.##, where ## is the block number.  In this case, once the entirety of the uploaded data is received by the DPU FSW, the uploaded data is then written to that file in the EEPROM filesystem.  If a file already exists with that name, it is overwritten.  The EEPROM filesystem can be reinitialized using the command D_MEM_DISK_INIT.
DPUSDS5.12.1.4;Memory Upload and Download Handling 	The command D_MEM_BLK_DNLD is used to download data from a file contained in the EEPROM filesystem.  As in the upload command, only the block number need be provided, and the entire contents of the filename formed from the block number will be downloaded.  To download data from any location other than the EEPROM filesystem, the command D_MEM_DAT_DNLD is used.  As described previously, downloads handled in a deferred fashion to avoid consuming excessive CPU time.  A single “virtual” download will appear on the ground as a series of download packets, the contents of which must be extracted and concatenated in order to recreated the original data sequence.
DPUSDS5.12.1.5;Error Collection and Reporting	The DPU-CCM CSC provides a centralized error reporting interface, ccmErrEnq(), that other FSW tasks use to report errors.  Each time it wakes, ccmTask() checks to see if it is time to form an error/event packet for transmission to the ground.  If so, ccmTask() calls ccmHkMkError() to actually create the packet and forward it to DPU-SCUI for transmission to the ground.
DPUSDS5.12.1.5;Error Collection and Reporting	The ccmErrEnq() function tracks the last error reported and its frequency of occurrence.  Once an error code has been reported it becomes the previously reported error code maintained by ccmErrEnq().  A repetition count is then incremented for each subsequent, consecutively reported, identical instance of this previously reported error.  If this error code is reported more than once in one high-rate housekeeping reporting period, then a special error, S_ccm_ERR_REPEAT is enqueued with the repetition count for the error encoded in the least significant byte. This mechanism effectively reduces the potential for housekeeping telemetry to become flooded with a single repeated error.
DPUSDS5.12.1.5;Error Collection and Reporting	The S_ccm_ERR_REPEAT error encodes the count of the last repeated error in its low order byte.  If a new error is reported as discussed above, ccmErrEnq() will enqueue a S_ccm_ERR_REPEAT  for any previously repeated error, along with the newly reported error.   In order to keep the original error codes and their repeated counts together in the same error packet, ccmMkHkErr(), enqueues a special error code, S_ccm_ERRQ_FLUSH, as a special signal to ccmErrEnq() that it needs to clear its error tracking mechanism and enqueue any  repeated error counts associated with a particular error.
DPUSDS5.12.1.5;Error Collection and Reporting	In order to insure that error counts are not lost due to rollover, ccmErrEnq(), checks to insure that the count for a given error has not gone above 250 in one high rate housekeeping reporting period.  If the error count exceeds 250 for a particular reporting period, ccmErrEnq() will enqueue S_ccm_ERR_REPEAT error with the current error count and will clear its error tracking mechanism.
DPUSDS5.12.1.5;"Error Collection and Reporting	The ccmErrEnq() may also be called from Interrupt context.  In interrupt context, the mutual exclusion mechanism implemented on the Error Queue cannot be used since it is illegal to take a semaphore in an interrupt context.  To circumvent this limitation, the global variable ccmISRerror is set with the appropriate error code.  The error will be queued the next time ccmTask() runs.  Due to the manner in which errors are handled in interrupt context, it is possible to loose errors if more than one error occurs in interrupt context before ccmTask() executes; the previous error will be overwritten by the new error."
DPUSDS5.12.1.5;Error Collection and Reporting	At boot time, no error queue exists because it has yet to be created.  Errors that occur in this early stage of error reporting are assigned directly to the global task variable errno.  The reader may refer to the VxWorks® Programmer’s Guide, section 2.3.7 for more information on errno.  If errno is set after the error queues are created, it is queued to the Error Queue by calling ccmErrEnq().
DPUSDS5.12.2;Public Functions	This routine is called by the MIL-STD-1553 Command ISR and the SSI Interface ISR any time a command arrives from the SCU or the ICU, to enqueue the command and to wakeup the CCM Command Dispatch Task so that the command can be executed.
DPUSDS5.12.2;Public Functions	This routine is called by any CSC in order to report an error or event that should be included in DPU housekeeping.  If this routine is called from interrupt context a static global variable, ccmISRError, is set so that the error can be enqueued later (see ccmCtrlTask()).  This is done since the error/event queue is semaphore-protected and a semaphore cannot be taken in an ISR.  The error queue semaphore has priority inversion set to reduce conflicts between multiple callers should a priority inversion situation arise. This routine also replaces frequently occuring errors with a special repeat error code.  The repeat error code is a special error code that follows a normally reported error code to indicate that the normally reported error code previously reported has occurred more than once in the last high rate reporting period
DPUSDS5.12.2;Public Functions	This routine is called by each DPU FSW task to report that the task has executed, so that the ccmCtrlTask() can assess the health of the DPU FSW execution.
DPUSDS5.12.2;Public Functions	This routine is called by the MIL-STD-1553 Command ISR at 1 Hz (arrival of the Clock Message) to wakeup the CCM Control Task, which blocks on a semaphore after completing its processing.
DPUSDS5.12.3;Global Data	the global data items which are accessed by this CSC
DPUSDS5.13.0;Telescope Module Access Library and Interface CSC	The Telescope Module Access Library and Interface (TMALI) CSC manages the detector event queue and provides an API for the retrieval of detector events from that queue to the data processing algorithms.
DPUSDS5.13.0;"Telescope Module Access Library and Interface CSC	The TMALI CSC includes the following components: * A queue, TMALI_EVENT_QUEUE, implemented using a ring buffer, which contains the detector events which have been received over the data capture interface from the DCI Driver, but which have not yet been retrieved by the DPA CSC; * An API which facilitates the retrieval of detector events from the queue by the DPA CSC.  The API consists of the tmaliNextEvent() and tmaliWait() functions. * An set of API functions used by the DPA CSC to configure the DCI interface, including tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet(), and tmaliDataTimeoutGet(). * An API housekeeping function, tmaliHkGet(), which gathers  CSC housekeeping data at the request of the Command and Control Task. * The task tmaliTask() and an ISR tmaliTransferToQueueISR() work together via a semaphore to synchronize the transfer of data from the DCI to the  queue An error handling ISR, tmaliDciErrorReportedISR(), is installed as a hook routine to the DCI Driver, and is used to keep track of the number of errors reported by the DCI driver."
DPUSDS5.13.1.1;Normal Data Exchange Sequence	The TMALI CSC serves as an intermediate manager of EVENT data supplied by the DCI Driver CSC and eventually delivered to the DPA CSC.  The TMALI CSC waits for notification from the DCI CSC that a frame limit (or data timeout) has been reached in the Ping-Pong buffer indicating the EVENT data is ready to be served to TMALI.   TMALI reads all EVENT data from the DCI and notifies the DCI that it can swap Ping-Pong buffers when ready.   TMALI gives a semaphore to unblock the tmaliWait() call from the DPA.
DPUSDS5.13.1.1;Normal Data Exchange Sequence	The DPA CSC calls tmaliWait() to determine how many EVENTs are waiting to be read.  When tmaliWait() returns with a number greater than zero, the DPA calls tmaliNextEvent() for each EVENT to be collected.
DPUSDS5.13.1.2;Initialization	The TMALI CSC is initialized by spawning the tmaliTask() with the startup default parameters.  This task will allocate memory for the TMALI_EVENT_QUEUE, install DCI ISRs, initialize static variables and data structures, and then enter an end-less loop in which it transfers the data from the DCI to the TMALI queue, throttled by the semaphore semDciWait.
DPUSDS5.13.1.3;Data Transfer to Queue	During initialization, the TMALI CSC installs an ISR hook routine, tmaliTransferToQueueISR(),  into the DCI Driver which is invoked when: * the DCI interface reaches the programmed frame limit in the Ping-Pong buffer, or * the DCI interface detects a data receipt timeout.
DPUSDS5.13.1.3;Data Transfer to Queue	When the tmaliTransferToQueueISR() ISR is invoked, it gives a semaphore to awaken tmaliTask() that will transfer data to the  queue over the VME bus.  The tmaliTask() uses the read() function in the DCI Driver, which implements a data transfer using a high speed assembly language routine.  Because the TMALI ring buffer is implemented as an array, the tmaliTask() function must first examine the TMALI_EVENT_QUEUE to determine whether the data resident in the DCI buffer can be retrieved using a single read() call, or whether two calls are required in order to correctly handle the wrap-around case at the end of the ring buffer.  In addition, the tmaliTask() function must perform an error check to verify that there is sufficient space to receive the data available in the Ping-Pong buffer.  If there is insufficient space for the complete set of frames, the entire contents of the readable Ping-Pong buffer are discarded and the error S_TMALI_QUEUE_FULL is reported using ‘ccmErrEnq’ mechanism.  Such discarded data constitutes an integral number of CCD frames, since the DCI hardware design ensures that Ping-Pong transitions occur at CCD frame boundaries.  This policy of discarding the newer data supports the scientific viewpoint that events collected right after a burst have more scientific value than events collected later.
DPUSDS5.13.1.3;Data Transfer to Queue	Once the events in the Ping-Pong buffer have been completely transferred to the TMALI_EVENT_QUEUE, the tamliTask() function must re-arm the hardware to swap the Ping-Pong buffer when ready.  In the event that TMALI does not finish transferring the data from the ping buffer before the pong buffer is full, the DCI Driver will issue an error interrupt, invoking the tmaliDciErrorReportedISR().  In response, the tmaliDciErrorReportedISR() will set an error flag so that the tmaliTask() can recover.  The tmaliDciErrorReportedISR() also gives the semDciWait semaphore to awaken the tmaliTask() even though it is likely already awake, since it is possible that the tmaliTask() has just completed transfer of the data at the time the error occurs.  The error will also be counted in TMALI_HK.  The DCI hardware will discard events until the tmaliTask() function completes the prior transfer, recognizes the error flag, and in response manually forces a Ping-Pong swap and re-enables data acquisition.  This guarantees that only complete frames end up in the Ping-Pong buffer and will be considered for processing.  In normal operation this error should not occur as the TMALI task should be fast enough to retrieve data from the DCI Ping-Pong buffer.  When events can’t be handled fast enough the problem should result in an TMALI queue full condition which is reported as an S_TMALI_QUEUE_FULL error using the ccmErrEnq() mechanism.
DPUSDS5.13.1.4;Event Retrieval From Queue	Events are retrieved from the TMALI_EVENT_QUEUE by the DPA CSC via an API consisting of two functions: tmaliWait() and tmaliNextEvent().  For efficiency, the following API usage points are relevant: * The DPA CSC will “inline” the tmaliNextEvent() function in order to avoid a function call for each event, * The DPA CSC will place each event received into a register, and complete the processing for a given event while resident in a register before retrieving the next event, and * The tmaliNextEvent() function performs no error checking in order to maximize the efficiency of the function.  Therefore, the DPA CSC must keep track of the number of events retrieved versus the number provided in return from tmaliWait().
DPUSDS5.13.1.5;Ring buffer data structure	The  CSC maintains a FIFO implemented as a ring buffer to temporarily store the data received from the DCI before it is processed. The ring buffer uses two pointers called pIn and pOut to keep track of the data in the buffer. The pointers were defined such that reading from the buffer is the simplest operation and only a single compare is needed to verify if the buffer is empty. The buffer only stores Events so the pointers point to these four byte entities. As the DCI specifies all data in bytes, sizes have to be converted before reading data.
DPUSDS5.13.1.5;Ring buffer data structure	The pIn and pOut pointers are defined  as follows: * pIn	- last location filled with data * pOut	- last empty location
DPUSDS5.13.1.5;Ring buffer data structure	This definition results in the following: * administration is simple but one location is wasted in the buffer full situation, the pIn pointer is one less that the pOut pointer, * buffer empty when the pIn pointer and the pOut pointer are equal.
DPUSDS5.13.1.5;Ring buffer data structure	A separate pointer indicates the end of the buffer: pEnd. This pointer points to the last available location in the buffer. Before advancing either  pointer it should be verified whether the pointer points to the last location, in that case the pointer is reset to the start of the buffer,  pointed to by pBuf, otherwise it can just be incremented.
DPUSDS5.13.1.6;Setting DCI Bit Arrangement	The bit arrangement of the DCI control/status register can be set via tmaliBitArrangementSet().
DPUSDS5.13.1.6;Setting Hardware Windowing		The hardware windowing function of the DCI can be activated and controlled  via tmaliDciWindowSet().  This function activates the hardware windowing function and transfers the specified window parameters to the DCI driver.
DPUSDS5.13.1.6;Setting Frame Depth in DCI	The optimum frame depth will be determined with benchmark testing.  The default frame depth is 10 frames.  Given the above data, it will take approximately 24 msec to read 10 maximum-sized frames at the maximum data transfer rate.
DPUSDS5.13.1.6;Setting Data Timeout in DCI	During nominal operation, frames arrive approximately every 11 msecs.  The DCI hardware will generate an interrupt if event data has been received in one of the Ping-Pong buffers, and a configurable amount of time has passed during which no additional events have been received.  A data timeout interrupt is not an error, but rather typically indicates that the current exposure has been completed.  The data timeout interrupt allows the TMALI CSC to retrieve the “trailing” events from the DCI Ping-Pong buffer.  The function tmaliDciTimeoutSet() provides an API to the DCI Driver to allow the timeout setting to be altered.
DPUSDS5.13.1.7;Housekeeping	The TMALI CSC collects housekeeping data that can be retrieved via a call to tmaliHkGet().   TMALI CSC housekeeping is returned via the TMALI_HK data structure.
DPUSDS5.13.2;Public Functions	This routine provides a means to set the bit arrangement used by the DCI.  When bSpecialArrangement is TRUE, the DCI is set to special bit arrangement mode, otherwise the default mode of no rearrangement is set.
DPUSDS5.13.2;Public Functions	When no data is available in the TMALI queue this routine blocks on a semaphore awaiting availability of events on the TMALI queue as indicated by the ISR.  When data is already available on the TMALI queue, or the semaphore is taken, the number of events on the TMALI queue is determined and returned to the caller.  The parameter ‘TickstoWait’ specifies the maximum time which the function can wait until data becomes available in kernel-ticks.  The parameter may be set to a symbolic value ‘FOREVER’ which causes the function only to return when data is available.  When the function is called with a timeout value and no data becomes avialable within that period the function will return zero (events available).If the tmali task has not been initialized the function returns an error.
DPUSDS5.13.2;Public Functions	This function gets the frame depth of the Ping-Pong buffers used by the DCI CSC.  The frame depth determines how many frames are read into the selected Ping-Pong buffer before interrupting.  The initial value for the frame depth setting is determined by the parameter provided when stating the tmaliTask.  The returned value is the current active value, this may differ from the last commanded value as the commanded value only takes effect when data is transferred from the hardware Ping-Pong buffer to the TMALI queue (in response to a frame or timeout interrupt, see section 5.13.2.3).
DPUSDS5.13.2;Public Functions	This function sets the frame depth of the Ping-Pong buffers used by the DCI CSC.  The frame depth determines how many frames are read into the selected Ping-Pong buffer before interrupting.  The initial value for the frame depth setting is determined by the parameter provided when starting the tmaliTask.  The maximum value to which the frame depth can be commanded is 64 frames, an attempt to command the frame depth to a value larger than this maximum will result in setting the timeout to the default value of V frames.The actual setting of the frame depth could be delayed by a small amount of time if there is activity on the DCI bus, and is typically changed when the DCI has just reported a frame level reached or timeout condition.  This minimizes the chance of changing the setting while the hardware is close to detecting a frame event.  Changing the frame depth while the DCI CSC is processing data could cause unpredictable results.  When a new ‘tmaliDciFrameDepthSet’ command is send before the previous setting has been activated the new request will overwrite the previous request and the DCI will be commanded to the new value at the first available opportunity.
DPUSDS5.13.2;Public Functions	This routine provides a means to get the current data timeout value used by the DCI.  The returned value is the current timeout in milliseconds.The timeout is discussed in document 036911400, section 4.3.2.4.1.3.
DPUSDS5.13.2;Public Functions	This routine provides a means to set the data timeout used by the DCI, the value requested indicates the timeout in milliseconds.  The initial value for the frame depth setting is determined by the parameter provided when starting the tmaliTask.  The maximum value to which the timeout can be commanded is X seconds, an attempt to set the timeout to a number larger than this maximum will result in setting the timeout to the default value of X milliseconds
DPUSDS5.13.2;Public Functions	This routine provides a means to set DCI windowing parameters used by the DCI data acquisition.  Before commanding the DCI driver to change the DCI hardware windowing parameters the window specification is verified. If the setting is incorrect the function returns an error and the hardware windowing function is not activated.The function both sets the requested hardware window specification and activates the hardware windowing function.
DPUSDS5.13.2;Public Functions	This routine gets housekeeping data stored for the TMALI CSC including some DCI parameters and resets the tmali internal counters to zero.  When the caller supplied pointer to a TMALI_HK structure is NIL no data is returned but the tmali internal counters are still reset to zero.Two of the four error counters are updated within an ISR context, this requires a task switch safe implementation of these counters.  Within VxWorks this could be solved using a counting semaphore.  In the TMALI CSC design a faster method was used by using a free running error counter and a careful update of the reported number of errors, using an extra temporary variable.  As the increment and assignment of the 32 bit unsigned integers themselves are ‘atomic’ operations the resulting counters are task safe and no error events are lost.  This means that the sum of the errors reported by the tmaliHkGet() function is equal to the total numbers of errors that occurred, no error reports are lost due to the update of the internal structures.
DPUSDS5.13.2;Public Functions	This function returns the next EVENT in the queue to the caller.  The caller should store the value returned by this function in a variable defined locally within the scope of the function from which it is called.  If the return value is stored as described above, the EVENT value is stored in a RAD6000 register rather than memory.  Processing is therefore much faster since register accesses on the RAD6000 are much faster than memory accesses.A compilation option ‘TMALI_NOCHECKS’ is provided for the disabling of buffer empty checks. This results in slightly faster code but should only be used when the application using this function is known to make proper calls to the function.  If the TMALI module is compiled with the ‘TMALI_NOCHECKS’ option an improper call to the tmaliNextEvent function (calling it when no data is available in the TMALI buffer) will compromise the TMALI buffer data structure.The queue structure and the related pointers are described in the local ‘tmaliP.h’ header file. As only the write pointer (pOut) is manipulated here and the operations on the 32 bit pointers themselves are 'atomic' no mutual exclusion problem can occur.
DPUSDS5.13.2;Public Functions	This task initializes the TMALI CSC and then continues to read data from the DCI and store it in the TMALI buffer each time the DCI driver signals that data is available in the Ping-Pong buffer.  The availability of data in the DCI Ping-Pong buffer is signaled to the tmaliTask using a semaphore.  Unless a fatal error is detected during initialization this task will never terminate.The specified 3 parameters specify the size of the TMALI queue and the initial parameters for the DCI, if the specified values are outside the allowed range default values will be used.The specified QueueSize is the allocated buffersize (in 4 byte EVENTS), the ring buffer is full when ‘QueueSize-1’ EVENTS are stored in the buffer.
DPUSDS5.14.0;SCU Interface CSC	The SCU Interface (SCUI) CSC is a Level 3 reuse component from the INSTRUMENT Y project.  The SCUI CSC is primarily responsible for implementing the application protocol with the SCU. The SCUI CSC provides CCSDS packetization services and manages the interface between the DPU and the SCU.
DPUSDS5.14.0;SCU Interface CSC	The SCUI CSC includes the following components: * SCU Interface Task, scuiTask(), which accumulates Data Packages, converts them to CCSDS Version 1 Source Packets, forms Company X Telemetry Protocol Data Units (ST_PDUs) from the Source Packets, and transmits the ST_PDUs to the SCU via the MIL-STD-1553B Interface.  The task also outputs messages to the “RT-RT” subaddress if one is awaiting on the input queue. * SCU Telemetry Enqueue function, scuiEnq(), which is an API by which other tasks provide telemetry data packages to the scuiTask() for processing. * SCU Observatory Message Enqueue function, scuiObsMsgSend(), which is an API by which other tasks provide command messages to the scuiTask() for transmission to the SCU and/or other Instruments (referred to in the 1553 ICD at “RT-RT Commands”. * SCU Interface Telemetry Done ISR, scuiTlmDoneISR(), which informs the DPU that the SCU has completed reading the prior ST_PDU, and gives a semaphore to awaken the scuiTask() to create and post a new ST_PDU. * SCU Interface Command Reader ISR, scuiReadCmdISR(), which receives Telecommands from the SCU and forwards them to the Command and Control Task for processing. * SCU Interface Housekeeping Function, scuiHkGet(), which gathers SCU Interface housekeeping data at the request of the Command and Control Task.
DPUSDS5.14.0;SCU Interface CSC	This CSC performs rate-buffering of the downlink telemetry to the SCU according to a commandable parameter.  The rate at which the SCU polls the DPU is also commandable.  The CSC installs an ISR to collect telecommands from the SCU via the MILSTD1553B Interface.
DPUSDS5.14.1.1;Initialization	The SCUI CSC is initialized when the scuiTask() is spawned by the CCM CSC.  Initialization parameters which are passed into the scuiTask() include: * Poll Rate – rate at which the S/C will poll the DPU for telemetry.  The rate is specified in Hz, and has a default of X Hz based on the INSTRUMENT X-DPU poll rate in the Company X 1553 ICD. * Buffer Rate – value used to rate buffer data to the S/C.  The rate is specified in bits per telemetry poll, and has a default of 7664 which is equal to one STPDU per poll (*** bytes per STPDU times V bits/byte).  This default value effectively disables rate buffering. * Size of Low Priority Queue – size in bytes of the low priority telemetry queue.  If the amount requested cannot be allocated, the buffer will be allocated at ½ the amount of memory contained in the largest free memory block. Size of High Priority Queue – size in bytes of the high priority telemetry queue. If the amount requested cannot be allocated, the buffer will be allocated at ½ the amount of memory contained in the largest free memory block.
DPUSDS5.14.1.1;Initialization	 The task invokes the initialization function scuiInit() which sets an instance variable, allocates ring buffers and semaphores for the Low and High Priority Telemetry Queues, initializes a buffer and semaphore for pending “RT-RT” command messages, creates the scuiTask() wakeup semaphore, initializes internal data structures, opens and initializes file descriptors for each of the required MIL-STD-1553 subaddresses and installs ISRs.  When the CCM CSC spawns the scuiTask(), it will block on a semaphore (ccmSemScuiSpawn) awaiting SCUI initialization.  Once initialization is complete, the SCUI CSC will signal successful initialization by giving the semaphore, and then write an empty STPDU to the 1553 shared memory.
DPUSDS5.14.1.2;Transmitting Telemetry to the Spacecraft	The SCUI CSC receives telemetry as input Data Packages via queues populated by other tasks—the Science Data Processing Task, the Data Compression Task, and the Command and Control Task.  The SCUI CSC has a High Priority Queue and a Low Priority Queue.  The two queues are implemented in an identical manner with the exception that the scuiTask() gives processing preference to the High Priority Queue.  The purpose of the High Priority Queue is to provide a means by which the Parameterized Finding Chart and DPU housekeeping can be transmitted to the SCU ahead of the potentially large amounts of buffered science data.
DPUSDS5.14.1.2;Telemetry Input to the SCUI CSC	Each queue is implemented as a First-In First-Out (FIFO) buffer using the VxWorks® ring buffer library, rngLib.  The calling application provides, via scuiEnq(), the data APID and processing information, a pointer to any tertiary header data (so-called since CCSDS packets already have a secondary header) and the length of that header data, and finally a pointer to the telemetry data itself and its length.  The scuiEnq() function then enqueues a Data Package onto the appropriate queue as indicated in the PKG_CTRL field.  Data Package identification and processing information is placed in a SCUI_ENTRY data structure, which is placed on the queue first, followed by the tertiary header (if present), followed by the telemetry data itself, and optionally followed by a trailing checksum (as indicated by the PKG_CTRL field) which is computed by scuiEnq().  The purpose of allowing the calling application to provide a separate pointer to tertiary header data is to eliminate the need for the caller to first copy the tertiary header data and the telemetry data to a separate single buffer prior to calling scuiEnq(), thus saving on memory copies.
DPUSDS5.14.1.2;Telemetry Output to the Spacecraft 1553 Bus	The SCUI CSC reads the Data Packages from the queues and transforms them into CCSDS Version 1 Source Packets.  These Source Packets are then packed into the STPDU for transmission to the SCU.  This processing is performed by scuiConvertToSTPDU().   The STPDU, prefixed with a Transfer Request Counter (TRC), is then written to fifteen sequential 1553 subaddresses (as described in the Company X 1553 ICD) by the function scuiWrite().
DPUSDS5.14.1.2;Telemetry Output to the Spacecraft 1553 Bus	The scuiConvertToSTPDU() function creates a complete STPDU for transmission each time the function is executed. The function calls scuiSTPDUFill() twice, once to populate the STPDU with data from the high priority queue, and then if space remains in the STPDU, it will attempt to populate the remaining space with data from the low priority queue.
DPUSDS5.14.1.2;Telemetry Output to the Spacecraft 1553 Bus	The SCU, which is a MIL-STD-1553 Bus Controller (BC), periodically reads the STPDU contained in the fifteen telemetry subaddresses, and then writes to the “telemetry done” subaddress.  When the “telemetry done” subaddress is written, the scuiTlmDoneISR() is called which gives a semaphore to awaken the scuiTask().  The software provides fault tolerance by automatically awaking after approximately two polling periods.  This timeout is automatically adjusted any time the SCU Poll Rate value is changed by command.
DPUSDS5.14.1.3;Receiving Commands from the Spacecraft	The DPU/SCU interface specifies that commands for the DPU will be transmitted from the SCU to the DPU on a separate MIL-STD-1553 subaddress.  The SCU Interface Command Reader ISR, scuiCmdReadISR(). consists of an ISR installed on a specific MIL-STD-1553 subaddress corresponding to the command subaddress for the INSTRUMENT X DPU. This ISR is installed at initialization by scuiInit().  Upon interrupt, the scuiCmdReadISR() reads a single telecommand from the 1553 bus, checks the length and checksum, and then forwards valid commands to the Command and Control CSC for dispatch via ccmCmdEnq().  Errors are reported by incrementing an invalid command counter.
DPUSDS5.14.1.4;Sending Command Messages to the Spacecraft	The Instrument/SCU interface provides a mechanism by which an Instrument can transmit a message to the SCU or another Instrument via the SCU, formatted as a CCSDS Telecommand Packet.  In this document, these messages are referred to as observatory messages.  The scuiObsMsgSend() function provides an API by which an observatory message can be transmitted to the SCU via the 1553 bus.  This function has an interface similar to scuiEnq(), except that this function attempts to write the message to the RT-RT subaddress immediately.  If the SCU has not read the prior message yet, the prior message is removed from the 1553 shared memory and replaced with the new message, and an error (S_scui_OBSMSG_LOST) is enqueued to note that the prior message may not have been received by the S/C.
DPUSDS5.14.2;Public Functions	This routine places the given data in either the Low or High Priority Queue depending on the PKG_CTRL parameter.  The PKG_CTRL parameter also controls whether or not the eventual CCSDS Source Packet can be segmented, and whether a trailing checksum should be computed.
DPUSDS5.14.2;Public Functions	The routine formats the given data into a CCSDS Telecommand Packet and writes it to the 1553 bus shared memory for transmission to the SCU.  If a message is already pending in the 1553 shared memory, the pending messages will be replaced in 1553 shared memory with the new message, and an error will be reported.
DPUSDS5.14.2;Public Functions	Sets the poll rate and buffer rate to the given values.  If the values are out of range, the prior values are retained and an error is reported.  The scuiTask() semaphore timeout (scuiTaskTimeout) is automatically adjusted based on the given poll rate, by setting the timeout to approximately ½ the poll rate (not that the timeout is expressed in clock ticks, and so the resolution is low and only approximates ½ of the poll rate).
DPUSDS5.14.2;Public Functions	This routine is spawned by the Command and Control Task to initialize and execute the SCU Interface Data Processor Task.  This task initializes the SCUI CSC and then enters an “infinite” loop to process telemetry and produce STPDUs.  Once initialized, the task is awakened by a semaphore given when the SCU writes the “telemetry done” subaddress.
DPUSDS5.15.0;Data Compression CSC	The Data Compression (DCX) CSC was projected to be a Level 2 reuse component from the INSTRUMENT Y project at planning time.  However, an alternate algorithm used on the XMM-OM project was benchmarked against the INSTRUMENT Y algorithm, and based on those benchmarks the XMM-OM algorithm was selected instead.  As a result, the DCX CSC is now classified as a Level 3 reuse component, and will consist of some compression queue management code reused from INSTRUMENT Y, with compression algorithm code reused from XMM-OM. The Data Compression CSC consists of a Data Compression Task, dcxTask(), which accepts Data Packages from the DPA CSC via the dcxEnq() function, compresses them using the Variable Block Tiered Word Length (VBTWL) algorithm, and provides the compressed Data Package to the SCU Interface Data Processor Task
DPUSDS5.15.1.1;Initialization	The DCX CSC is initialized when the dcxTask() is spawned by the CCM CSC.  During initialization, the DCX CSC creates a compression queue to contain data packages which are pending compression.  Access to the compression queue is protected by a mutual exclusion semaphore.  The size of the compression queue is controlled by an initialization parameters which is passed into the dcxTask().  If the amount of memory requested cannot be allocated, initialization of the DCX CSC will fail.
DPUSDS5.15.1.1;Initialization	The task invokes the initialization function dcxInit() which sets an instance variable, allocates the compression queue and mutual exclusion semaphore, creates the dcxTask() wakeup (data availability) semaphore, and initializes internal data structures.  Once initialization is complete, the task enters an “infinite” loop to process data on the compression queue until the queue is empty or until pre-empted by another task.  The task initially blocks on a binary “wakeup” semaphore which is given anytime new data is placed on the compression queue.  If the compression queue is emptied, the task will again block on the semaphore until more data is available.
DPUSDS5.15.1.2;Data Processing	The DCX CSC is a task which receives data packages from other tasks, compresses the data using the VBTWL algorithm, and then forwards the compressed data package to the SCUI CSC.
DPUSDS5.15.1.2;Data Processing	Data requiring compression is received via the dcxEnq() function, which has an API definition which matches the scuiEnq() API.  The DCX CSC handles the PKG_CTRL flags as described below: * PKG_COMPRESS – this flag is set to indicate if the package is actually compressed. * PKG_PRIORITY_HIGH – this flag is ignored by the DCX CSC but is forwarded to the SCUI CSC. * PKG_SEGMENT – this flag is ignored by the DCX CSC but is forwarded to the SCUI CSC. PKG_CHECKSUM – if set, the dcxEnq() function will compute a checksum which is appended to the data, and then the flag is negated.  The checksum will be compressed with the rest of the data, so that when the data is decompressed on the ground, the checksum can be recomputed and compared to provide a good indication of whether the decompressed copy of the data matches the original data set.
DPUSDS5.15.1.2;Data Processing	When the DCX CSC compresses a data package, the given APID is incremented by one.  If the compressed copy of data is larger than original data set, the original data set will be forwarded to the SCUI CSC, an event S_dcx_UNC_USED is enqueued to ccmErrEnq(), and the APID is not incremented.  In this way, the ground systems can discern compressed packets from non-compressed packets.
DPUSDS5.15.1.3;"Compression Algorithm	The VBTWL algorithm is implemented in a set of C-language functions provided by PSU as a reuse item from the XMM-OM mission.  The algorithm is described in document XMM-OM/PENN/TC/0004.03; therefore the design of the compression algorithm code itself is outside the scope of this document.  Rather, the design of the code which “wraps” the algorithmic code is specified.  The entry point to the compression algorithm is the function vbtwl().  This function is called directly by the Data Compression Task.  The entry point for the Data Compression Task is the function dcxTask()."
DPUSDS5.16.0;Time Synchronization CSC	The Time Synchronization (TIS) CSC is a new component which provides services to maintain time synchronization between the DPU and the spacecraft, and which provides an API for retrieval of the current system time.
DPUSDS5.16.1;Structural Design	The TIS CSC provides a library of functions to * initialize the DPU clock hardware at startup, * maintain synchronization of the DPU clock with the Spacecraft clock, * provide a function for use by other applications to retrieve the current values of the DPU clock and the UT Delta, and provide functions for use by the CCM command dispatcher to alter the configuration of the clock interface.
DPUSDS5.16.1.1;"Initialization	The TIS CSC is initialized by calling the tisInit() function.  The TIS CSC does not have an associated operating system task.  The TIS CSC will initialize the DPU hardware to perform or not perform automatic time synchronization with the spacecraft as indicated by an initialization parameter passed to the tisInit() function.  There are two 1 PPS signals between the DPU and the Spacecraft (a primary and alternate);  the TIS CSC will select the active 1 PPS signal according to the parameter passed to the tisInit() function."
DPUSDS5.16.1.2;Time Synchronization	The interface with the spacecraft as described in document 1143-EI-S19121 specifies that the spacecraft will provide a Clock Message to each Instrument at a 1 Hz rate.  The Clock Message contains both two values: a value representing the current spacecraft time, and a value representing the delta from the spacecraft time and the Univeral Time (UT), based on an epoch of TBD.
DPUSDS5.16.1.2;Time Synchronization	The time contained in the Clock Message is specified to be valid on the rising edge of the next 1PPS signal.  When the DPU receives the Clock Message, the 1553 ISR calls the tisTimeSync() function, forwarding the data portion of the clock message to the TIS CSC via the TIS_CLK_MSG data structure..  The tisTimeSync() function will immediately copy the spacecraft clock value to the DPU clock hardware registers. The DPU hardware is designed to latch in the new time on the rising edge of the next 1 PPS signal (the act of writing a new time to the hardware registers “arms” the latch function in the hardware).  Once the new time is latched, the hardware automatically disables the time latch function to avoid the potential of latching in an old time at the next 1 PPS signal.			 will be received within one second.  In the unlikely event a UT Delta is discarded, an event message is enqueued to ccmErrEnq() for informational purposes.
DPUSDS5.16.1.3;Time Retrieval	The DPU maintains a local copy of the spacecraft clock and current UT Delta in order that the DPU FSW can timestamp data products and packets.  The TIS CSC provides a function, tisTimeGet(), which retrieves a copy of both the current DPU clock value and the most recent UT Delta value.  Time is communicated among DPU FSW applications via the TIS_TIME data structure.
DPUSDS5.16.1.4;Time Interface Configuration	The DPU hardware provides two configuration options to the software: * selection of the active A PPS signal, and * the option to manually jam a value into the clock registers without the A PPS signal.
DPUSDS5.16.1.4;Time Interface Configuration	The TIS CSC provides three functions for use by the CCM command dispatcher to control these values: * tis1ppsSet() – select active A PPS signal, * tisSyncModeSet() – set whether manual clock jamming is enabled, and         tisTimeSet() – manually jam a value into the DPU clock.
DPUSDS5.16.1.4;Time Interface Configuration	The TIS CSC utilizes the “manual jam” bit in the DCI CSR to indicate whether automatic time synchronization is enabled or disabled.  If automatic time synchronization is enabled, and a command is issued to manually jam the DPU clock, the command will be rejected - see tisTimeSet().
DPUSDS5.16.1.4;Time Interface Configuration	The bits to control the behavior of the DPU clock hardware were included in the DCI interface control/status register (CSR).  This presents some opportunity for a mutual exclusion problem in the event these configuration settings are altered after startup.  However, once initialized, both configuration settings are not expected to be altered.  If they are, the DPU should be put into a mode whereby the DCI interface is quiescent.
DPUSDS5.16.2;Public Functions	Selects the active A PPS signal according to the passed parameter. THIS FUNCTION ALTERS THE VALUE OF THE DCI CSR AND SHOULD NOT BE INVOKED WHEN DCI INTERRUPTS ARE ACTIVE.
DPUSDS5.16.2;Public Functions	Initializes the TIS CSC by initializing the hardware register convenience pointers and selecting the commanded 1PPS signal, and enables or disables automatic time synchronization with the S/C according to the passed parameter. THIS FUNCTION ALTERS THE VALUE OF THE DCI CSR AND SHOULD NOT BE INVOKED WHEN DCI INTERRUPTS ARE ACTIVE.
DPUSDS5.16.2;Public Functions	Operationally, the DPU uses the Jam bit in the DCI CSR to indicate whether the DPU is actively syncing its clock with the spacecraft or not.  This function sets the Jam bit if autoSync is FALSE, and negates the Jam bit otherwise. THIS FUNCTION ALTERS THE VALUE OF THE DCI CSR AND SHOULD NOT BE INVOKED WHEN DCI INTERRUPTS ARE ACTIVE.
DPUSDS5.16.2;Public Functions	This routine returns a copy of the local copy of the spacecraft time maintained in the DPU hardware, and the UT Delta from the most recent Clock Message which is maintained in a static variable.  The caller may pass in NULL for either parameter.  If NULL is passed for both parameters, the function performs no action and returns OK.
DPUSDS5.16.2;Public Functions	This routine manually sets the values of the spacecraft time maintained in the DPU hardware, and the UT Delta maintained in a static variable, to the given values.
DPUSDS5.16.2;Public Functions	This routine extracts the current spacecraft time from the clock message and writes in to the hardware clock registers to be latched by the hardware at the next 1PPS signal, and maintains a copy of the UT Delta provided in the clock message.  If the UT Delta is currently being copied by an application, the UT Delta from the current message is discarded and an event is enqueued to ccmErrEnq().  If automatic time synchronization is disabled, this routine returns with no action taken. THIS ROUTINE IS INVOKED AT INTERRUPT CONTEXT.
DPUSDS5.18.0;Instrument Control Unit Interface CSC	The Instrument Control Unit Interface (ICUI) CSC is a new component that provides support for application-level communication with the INSTRUMENT X ICU.  The ICUI CSC is primarily responsible for implementing the application protocol with the ICU as defined in document DPUICD-01. In order to meet these objectives, ICUI provides:  * An ICU Interface Message Send Function, icuiEnq(), which provides an API by which other CSCs can send messages to the ICU. * An ICU Interface Command Reader ISR, icuiCmdReceiveISR(), which receives Telecommands from the ICU and forwards them to the Command and Control Task for processing. * An ICU Interface Housekeeping Function, icuiHkGet(), which gathers ICU Interface housekeeping data at the request of the Command and Control Task.
DPUSDS5.18.1;Initialization	The ICUI CSC is initialized by calling icuiInit().  The icuiInit() function opens the SSI interface port to the ICU, installs the transmit and receive ISRs, and enables Transmit Message Mode in the SSI Driver CSC.  The icuiInit() function is called by the CCM Control Task at bootup.
DPUSDS5.18.1.2;Sending Messages to the ICU	In order to send messages to the ICU, the DPU FSW tasks call icuiEnq().  The calling application passes the function code of the message to be sent, as well as a pointer to a data structure containing the message parameters associated with the given function code.  The icuiEnq() function formats the message according to the ICU/DPU ICD using icuiMsgFormat(), and then writes the message to SSI Driver transmitter buffer by calling the driver write() function. A mutual exclusion semaphore, icuiSemWrite, protects the SSI Driver from being written by multiple tasks simultaneously.  A timeout parameter lets the caller control how long it is willing to block on this semaphore if there is an access conflict.
DPUSDS5.18.1.2;Sending Messages to the ICU	Some special processing and checking is required in this function to handle the transmission of the ACK/NAK message.  When a command arrives from the ICU, the icuiCmdReceiveISR() will verify the message checksum and then send an ACK/NAK message to the ICU.  It is possible that an application is in the midst of sending a message to the ICU at the time a command interrupt occurs.  However, since it is not possible for an ISR to take a semaphore, an additional mechanism is required in order to provide mutual exclusion between a task an the ISR.  To accommodate this problem, the icuiEnq() function first determines whether it is being invoked from interrupt context.  If so, it then tests the value of a static variable, icuiEnqBusy.  If the variable is set, the function will save the given ACK/NAK message parameters in static variables and return.  If the variable is not set, the function will continue as normal (avoiding the semTake() and semGive() calls).  In normal execution, the icuiEnqBusy variable is set on entry and negated on exit, after which the static variables containing the ACK/NAK message parameters will be checked to determine whether an ACK/NAK is pending.
DPUSDS5.18.1.2;Receiving Commands from the ICU	The interface to the ICU is via a synchronous serial interface (SSI) bus, which utilizes an inter-block gap (IBG) to delineate complete messages from one another.  The DPU hardware produces an interrupt when it detects an IBG, and the SSI Driver provides a mechanism by which an application can install an interrupt hook routine to respond to an IBG interrupt.  Upon initialization, the ICUI CSC installs a hook routine into the SSI Driver called icuiCommandReceiveISR(), which verifies the checksum of an incoming command, transmits an ACK/NAK message to the ICU, and then enqueues the command for later processing by calling ccmCmdEnq().
DPUSDS5.18.2;Public Functions	This routine is used to format messages for transmission to the ICU and to place those messages on the SSI Driver Transmitter Queue. The functionCode parameter is used to create the CCSDS Packet APID and the Message Identifier (refer to document DPUICD-01).  A mutual exclusion semaphore, icuiSemWrite, protects the SSI Driver from being written by multiple tasks simultaneously.  The timeout parameter lets the caller control how long it is willing to block on this semaphore if there is an access conflict.This routine may be called at interrupt context to transmit an ACK/NAK message.  In that case, the semaphore is not taken since it is not valid to take a semaphore at interrupt context.  Refer to discussion of the design to accommodate the ACK/NAK message.
DPUSDS5.18.2;Public Functions	This routine returns OK, or ERROR and sets errno if the passed parameter is NULL.  The following error codes may be returned in errno
DPUSDS5.18.2;Public Functions	This routine initializes the interface to the ICU.  This routine opens SSI Driver port, installs the SSI interface interrupt callbacks, and enables Transmit Message Mode in the SSI Driver.
DPUSDS5.19.0;Data Processing Algorithm CSC	The Data Processing Algorithm (DPA) CSC is a level 3 reuse component from XMM-OM which receives and processes INSTRUMENT X detector events, and produces science and engineering data products.
DPUSDS5.19.0;Data Processing Algorithm CSC	The DPA CSC includes the following components: * 	Event Processor Task – communicates with the ICU, creates event list data products, creates Tracking Instrument Ys in the Ping/Pong buffers, creates the Finding Chart, performs the Engineering Modes, generates housekeeping data, creates the Event Frame, Ping and Pong buffers, and provides a task heartbeat to the CCM task.
DPUSDS5.19.0;Data Processing Algorithm CSC	The DPA CSC includes the following components: * 	Instrument Y Processor Task – creates histogrammed Instrument Ys, performs Tracking (choose guide stars, drift correction, shift-and-add), creates the Reference, Accumulation, and Data Product buffers, and provides a task heartbeat to the CCM task.
DPUSDS5.19.0;Data Processing Algorithm CSC	The DPA CSC includes the following components: * 	Event Frame buffer – holds time-tagged detector events before being compressed and sent to the spacecraft.
DPUSDS5.19.0;Data Processing Algorithm CSC	The DPA CSC includes the following components:  * 		Instrument Y buffers –  o Ping and Pong hold the X-second tracking Instrument Ys that are shifted and added to the Accumulation Instrument Y during tracking. o  Reference holds the initial X-second exposure that the guide stars are chosen from. o Accumulation holds the final drift corrected Instrument Y. o Data Product holds the final Instrument Y that will be compressed and sent to the spacecraft.
DPUSDS5.19.0;Data Processing Algorithm CSC	The DPA CSC includes the following components: * Algorithms –  o Choose Guide Stars scans the bright stars in the reference frame, chooses guide stars and sets up tracking windows around the guide stars. o Drift Correction calculates the drift offset and roll of a just-completed tracking frame relative to the reference frame.  o Create Finding Chart will use the above Choose Guide Stars Algorithm to find the brightest stars in the finding chart Instrument Y then creates a list of the brightest stars and their intensities. o Derive Channel Boundaries calculates a set of channel boundaries (18 numbers - 9X, 9Y) which are used by the centroiding software in the Blue Processing Electronics (BPE) in the Telescope Module.
DPUSDS5.19.1;Initialization	The DPA CSC is initialized by spawning the tasks dpaEventTask() and dpaInstrument YTask().  After the tasks are spawned they create the needed memory buffers.  The dpaEventTask() then enters the Idle state waiting for a Mode command from the ICU.  The dpaInstrument YTask also enters the Idle state waiting to process either the Ping or Pong buffer.  The default setting for compression (on or off) is retrieved from EEPROM.
DPUSDS5.19.1.2.0;Event Processing	The Event Processor Task, after receiving a Mode command from the ICU, configures the DPU DCI hardware, responds to the ICU with a Mode Ready message then receives detector events by calling functions tmaliWait() and tmaliNextEvent().  The Event Processor Task will collect detector events for the time period specified in the Mode command then issue a Mode Complete message to the ICU.  After issuing the Mode Complete message, the Event Processor Task will enter the Idle state.
DPUSDS5.19.1.2.0;Event Processing	If the Mode command is Event Mode, the detector events are spatially filtered to the event window specified in the Mode command then put into an event list in the Event Frame buffer.  Once the Event Frame Buffer fills (4MB), or 5 seconds elapses, a  PROD_EVENT data product will be produced and enqueued for transmission to the spacecraft.
DPUSDS5.19.1.2.0;Event Processing	If the Mode command is Instrument Y Mode, the detector events are spatially filtered to the Instrument Y window specified in the Mode command then the corresponding pixel in the Ping or Pong buffer is incremented.  If specified in the Mode command, pixels will be binned at AxA or BxB.  Also, if specified in the Mode command, a tracking frame data product will be produced for every Ping/Pong tracking frame. Instrument Y and Event Mode may be commanded simultaneously in the Mode command. If the ICU sends an XRT Position command, the Instrument Y mode and Event Mode windows will be resized to match the new window sizes in the command.
DPUSDS5.19.1.2.0;Event Processing	The Event Processor Task is also responsible for creating the Finding Chart.  The Create Finding Chart Algorithm will use the Choose Guide Stars Algorithm to find the brightest stars in the finding chart Instrument Y.  The parameterized finding chart will be created by listing the X & Y detector location of each star along with a CxC pixel matrix around the star location of the intensities. The Event Processor Task will create the necessary housekeeping for the DPA.
DPUSDS5.19.1.2;Full-Frame (FF) Engineering Mode	The purpose of Full-Frame Engineering Mode is to monitor the health of the detector to locate hot spots and dead pixels. Detector events produced in Full Frame High Resolution detector format are received and histogrammed for a commanded integration time.  The entire Instrument Y is transmitted to the ground.  This mode can use high resolution (all pixels) or low resolution imaging (BxB , DxD pixel binning).
DPUSDS5.19.1.2;Raw Event List (RE) Engineering Mode	The purpose of Raw Event List Engineering Mode is to diagnose problems with the detector. Detector events produced in a given detector mode are collected over a commanded integration time and transmitted to the ground as a list of raw events.
DPUSDS5.19.1.2;Channel Boundary (CB) Engineering Mode	The purpose of Channel Boundary Mode is to derive the optimum channel boundary settings from a flat field. Detector events produced in the M,N detector mode are collected and histogrammed for a commanded integration time.  The “pseudo Instrument Y” is transmitted to the ground.  Channel boundaries are derived from the Instrument Y and transmitted to the ICU and the ground.  Channel boundaries are sent by the ICU to the BPE and used in the detector event centroiding process.
DPUSDS5.19.1.2;Centroiding Confirmation (CC) Engineering Mode	The purpose of Centroiding Confirmation Engineering Mode is to determine the validity of derived channel boundaries. Detector events are collected and histogrammed for a commanded integration time.  The full field is divided into 8x8 sub-Instrument Ys, each of ExEcentroided (by 8) pixels.  These sub-Instrument Ys are then modulo binned to produce a set of 8x8 pixels pseudo-Instrument Ys.  The Instrument Ys are column (y axis) ordered, as are the pixels within them.  These pseudo Instrument Ys are transmitted to the ground.
DPUSDS5.19.1.2;Intensifier Characteristics (IC) Engineering Mode	The purpose of Intensifier Characteristics Engineering Mode is to assess detector health and performance. Detector events produced in Full Frame High Resolution detector format are collected and histogrammed for a commanded integration time to produce a pulse-height histogram.
DPUSDS5.19.1.3;Instrument Y Processing	The Instrument Y Processor Task will perform tracking by breaking the exposure up into 10-second sub-exposures which are shifted and added into a final histogrammed Instrument Y.  Tracking is performed by choosing guide stars from the first 10-second Instrument Y of an exposure.  Then in each subsequent Instrument Y, these guide stars are found and the drift is determined by comparing the two Instrument Ys. The Instrument Y is then shifted by the determined drift and added to the previous Instrument Ys in the accumulation buffer.
DPUSDS5.19.1.3;Instrument Y Processing	An exposure starts by allowing the Event Processor task to complete the first Csecond tracking Instrument Y in the Ping buffer.  This first tracking Instrument Y is copied to the reference frame buffer.  The Choose Guide Stars function is called which tries to find guide stars in the reference frame. Bright sources in the reference frame are scanned and analyzed.  The analysis gives a number of “quality” indicators for the bright sources.  Based on these quality indicators and other global considerations such as star crowdedness, a number of guide stars, nominally 10, are selected. These star positions are saved for subsequent tracking.  Based on the user-supplied/requested window configuration and the selected guide stars, window/memory management code configures memory windows and science windows around the guide stars to store acquired raw data.  While tracking, the memory windows are shifted while obeying particular memory window restrictions.  Those restrictions are: 1) that memory windows’ bottom left corner (BLC) coordinates are multiples of A and B that memory window sizes also are multiples of 16. These restrictions are imposed due to the requirements of event centroiding.
DPUSDS5.19.1.3;Instrument Y Processing	After the guide stars are chosen, the Drift Correction algorithm looks at each subsequent Ping or Pong tracking frame.  It calculates the drift offset and roll of a just-completed tracking frame relative to the reference frame. This is done by first calculating the position of the guide stars in the tracking frame. Then a maximum likelihood solution is found by comparing the positions of the guide stars calculated in the tracking frame with their position in the reference frame.  Once the translation offset has been calculated, the tracking frame is shifted by the translation offset and added to the accumulation frame, which contains the previously accumulated tracking frames.
DPUSDS5.19.1.3;Instrument Y Processing	At the end of an exposure, the Instrument Y in the accumulation buffer is transferred to the Instrument Y data product buffer one horizontal line at a time, starting at the top of the Instrument Y to form a PROD_INSTRUMENT Y data product.  This ‘rasterized’ Instrument Y in the Instrument Y data product buffer will be enqueued for transmission to the spacecraft.
DPUSDS5.19.1.4;ACS Message Processing	The SCUI task will send the ACS message to the DPA by calling the function dpaACSReceive().  Because the SCUI task will be calling dpaACSReceive() from an ISR, dpaACSReceive() must return quickly.  If commanded by the ICU in the Mode command, the ACS message will be saved along with the event data product.  To return quickly, dpaACSReceive() will place the ACS message in a data queue then return.  The Event Processor Task will remove the ACS messages from the queue and send them to the spacecraft.
DPUSDS5.19.2;Public Functions	This routine provides a means for the CCM task to send a Mode command from the ICU to the DPA software. The Mode command shall be used to command the DPU into a particular science or engineering event processing mode.  The mode shall become effective after the DPU has sent the Mode Ready message to the ICU.
DPUSDS5.19.2;Public Functions	This routine is spawned by the Command and Control Task to initialize and execute the DPA Instrument Y Processing Task.
DPUSDS5.19.2;Public Functions	This routine provides a means for the CCM task to send the Stop Mode command from the ICU to the DPA software. The Stop Mode command shall be used to command the DPU to immediately stop processing events, complete the current data product, purge events from the DPU hardware, and enter Idle Mode.  The data product will include the actual exposure time and the number of frames.  In response to this command, the DPU shall issue a Mode Complete command to the ICU after finishing the before-mentioned tasks.
DPUSDS5.19.2;Public Functions	This routine provides a means for the CCM task to send a Purge Compression Queue command from the ICU to the DPA software. The Purge Compression Queue command shall be used to command the DPU to delete all data currently in the data compression queue.
DPUSDS5.19.2;Public Functions	This routine provides a means for the CCM task to send a Purge Science Queue command from the ICU to the DPA software. The Purge Science Queue command shall be used to command the DPU to delete all data currently in the science telemetry output queue (i.e., data pending transmission to the spacecraft).
DPUSDS5.19.2;Public Functions	This routine provides a means for the CCM task to send the XRT Position command from the ICU to the DPA software. The XRT Position command shall be used to command the DPU to update the position and window parameters that it uses to spatially filter event data.
DPUSDS5.19.2;Public Functions	This routine provides a means for the SCUI task to send the spacecraft’s ACS message the DPA software.   Note: THIS FUNCTION IS CALLED BY AN ISR AND MUST RETURN QUICKLY.
DPUSDS5.19.2;Public Functions	This routine provides a means for the CCM task to get the housekeeping info from the DPA software.  The CCM task will call this function and pass a pointer to the location that DPA is to store its housekeeping.
DPUSDS5.19.2;Public Functions	This routine provides a means for the CCM to report to the DPA CSC whether to send data to the compression queue or directly to the spacecraft interface queue.  After receiving a ground command to turn compression on or off, this function is called by the ccmCmdTask to inform the DPA whether to compress its data or not.  This function will set the global variable dpa_dcx_on TRUE if compression is enabled and FALSE if not.  Dpa_dcx_on will be used by the DPA to determine whether to send data to dcxEnq() or scuiEnq().
DPUSDS5.19.2;Public Functions	This routine is spawned by the Command and Control Task to initialize and execute the DPA Event Processing Task.
DPUSDS5.2.0;Operating System CSC	The Operating System CSC, DPU-RTOS, provides a real-time, multi-tasking environment.  The Operating System CSC is a COTS product, identified as VxWorks 5.3.1, kernel version WIND 2.5.  The Operating System CSC is supplemented with a library of miscellaneous project-specific system utilities.
DPUSDS5.2.3.0;Operating System Modifications	The following sections describe changes made to COTS source files.
DPUSDS5.2.3.1;Select of VxWorks® Configuration Defaults	 	When the VxWorks® operating system is compiled, certain options can be included or excluded from the boot Instrument Y. The set of default build options is based on the value of various constants (#defines) in the VxWorks® header file configAll.h.  Modifications to the default options provided in the VxWorks® BSP (configAll.h file revision 06v,09jun97,sj).
DPUSDS5.2.3.2;Compressed VxWorks® Instrument Y	In order to conserve EEPROM memory space and ensure that the boot Instrument Y fits within a single EEPROM memory bank, the VxWorks® boot Instrument Ys are compressed.  The Instrument Y produced is capable of decompressing itself in DRAM.  The make file provided with VxWorks® does not provide the necessary make target to produce a compressed RAM-resident Instrument Y with a built-in symbol table. new target, vxWorks.st_ram.bin, is included in the VxWorks® Makefile.  This target produces a compressed RAM Instrument Y containing a symbol table, and is capable of decompressing itself in DRAM.  The new file ramInit.s contains assembly language instructions which allow the Instrument Y to decompress itself in DRAM, and is compiled and linked into the compressed target.
DPUSDS5.2.3.3;Link and Initialize Project-Specific Device Drivers and Application Programs		Project-specific device drivers and application modules must be statically linked into the VxWorks® boot Instrument Y and initialized.  Application program tasks must be spawned when the operating system boots. Device drivers and application modules are linked into the Instrument Y by adding references to the respective object files to the MACH_EXTRAS variable in the VxWorks® Makefile. The usrRoot() function in usrConfig.c is the last function to be called by the operating system during initialization.  This function is modified to execute the BIT, initialize device drivers, and spawn the top-level application program task(s).  These initialization code segments are surrounded by #ifdef…#endif directives in order that they can be conveniently included or excluded by changing the value of the corresponding constant.  Flight defaults for these constants are set in the configAll.h file.  Temporary alteration of these defaults is typically done in $WIND_BASE/target/config/rscvme/config.h.
DPUSDS5.2.3.4;Unmask VME Interrupts and Disallow Nested Interrupts	The device drivers do not automatically unmask VME interrupts at the processor.  This must be done separately since some VME interrupts may share an IRQ level. Finally, nested interrupt capability should be disabled since allowing for nested interrupts was not considered in the design of this FSW.  This is done by verifying that SYS_INT_MASK_0 and SYS_INT_MASK_1 are both defined to 0xffffffff in config.h.
DPUSDS5.2.3.5;Setup Segment Registers	In order to access VME space as memory-mapped I/O, segment registers must be setup in VxWorks®. Modifications to four source files set up both D16 and D32 access to the VME bus.  As delivered, the VxWorks® Board Support Package (BSP) supports only one data access mode.  The syntax of the function sysVmePioSetup() in rscVme.c is extended to allow the specification of two dataWidth parameters.  The sysBusToLocalAdrs() function which maps a segment register into an address is replaced by two functions sys16BusToLocalAdrs() and sys32BusToLocalAdrs() since two segment registers are required.
DPUSDS5.2.3.6;Install Exception Handlers	In the diagnostic mode of operation, the RSC processor generates external interrupts for memory single-bit errors (SBEs), multiple-bit errors (MBEs), and address exceptions.  The RSCVME Board Support Package of VxWorks? does not directly support access to these interrupts. Some custom routines must be provided to access the Memory Error Interrupt.
DPUSDS5.2.3.6;Install Exception Handlers	a default interrupt handler and is installed into element five (5) of the system interrupt table.
DPUSDS5.2.3.6;Install Exception Handlers	This routine installs a hook routine for the Memory Error Interrupt.  The hook routine will be called from the interrupt context.  This function returns OK always.
DPUSDS5.2.3.6;Install Exception Handlers	These routines mask and unmask the Memory Error Interrupt, and return OK always.
DPUSDS5.2.3.6;Install Exception Handlers 	The RSC processor also generates an external interrupt for the Power Fail Interrupt.  The RSCVME Board Support Package of VxWorks? does not directly support access to this interrupt.  Some custom routines must be provided to access this interrupt. These functions are described below, and are contained in sysLibSup.c.
DPUSDS5.2.3.6;Install Exception Handlers	This routine is a default interrupt handler and is installed into element six (6) of the system interrupt table.
DPUSDS5.2.3.6;Install Exception Handlers	This routine installs a hook routine for the Power Failure Interrupt.  The hook routine will be called from the interrupt context.  This function returns OK always.
DPUSDS5.2.3.6;Install Exception Handlers 	Certain conditions can cause the VxWorks? exception handler to reboot the DPU.  These conditions include a Data Storage Interrupt from within an interrupt context, a Multiple-Bit Error (MBE), and a deferred-work queue overrun.  Under these circumstances, interrupting devices on the Company X Communication/Memory Module must be stopped prior to jumping back to the Bootstrap.  This can be done by installing a hook routine to perform the cleanup in sysHwInit() using the function rebootHookAdd().  However, to avoid the need to cleanup interrupts, an exception handler is installed which forces a watchdog reset, which will effectively clean up the pending interrupt problem.  The exception hook saves the contents of the Exception Stack Frame to EEPROM and waits for a watchdog timeout.  The following call is added to the usrRoot() function in usrConfig.c:
DPUSDS5.2.3.7;Exclude Failed DRAM	The Bootstrap performs a memory test before loading the operating system.  The results of this test are stored in the EEPROM.  The DPU-RTOS uses the results of the memory test to exclude memory segments with bit errors from the system memory pool. The Bootstrap constructs a bit map which effectively implements a list of failed memory blocks during the bootstrap built-in test.  A set of functions have been created to utilize this  bit map to exclude failed memory blocks from the VxWorks® system memory pool.  The system memory pool is used by VxWorks® to allocate memory dynamically.  In addition, a linked list of good memory segments is created for use by the EDAC Memory Scrubber.  These functions are called from the usrInit() and usrRoot() functions in usrConfig.c.  The dramInit() function must be called prior to kernelInit() in usrInit().  The dramBuildMemPool() function is called just prior to initialization of filesystems and drivers in usrRoot().
DPUSDS5.2.3.8;Write-Protect Text Segment and Interrupt Vector Table	In order to prevent a rogue software task from inadvertently overwriting the flight software, the area of memory containing the flight software and interrupt vector table is write protected at bootup. The pages containing the text segment of DPU-RTOS and the Interrupt Vector Table (IVT) are write protected by using the rscSetPageProtect() function provided by the VxWorks® Board Support Package (BSP).  These functions are included into the VxWorks® build by asserted INCLUDE_PROTECT_TEXT and INCLUDE_PROTECT_VEC_TABLE in configAll.h. Since a VxWorks® build cannot be assumed to end on a memory page boundary, a NULL memory page is added to the beginning of the data segment to ensure that a page first page of the data segment does not overlap a protected text segment.  VxWorks provides this in the file dataSegPad.c, but does so only if INCLUDE_MMU_FULL is defined, which it is not in this configuration since a separate MMU module must be purchased for this option to be valid.  Therefore, an additional #ifdef case is added to dataSegPad.c so that the extra text segment is added when INCLUDE_PROTECT_TEXT is defined. 	VxWorks? does not provide a mechanism to determine the state of the page protection flags set in the Page Frame Table (PFT).  A custom routine must provide access to these. This routine gets the value of the page protection flags for a memory address.  It returns PAGE_READ_ONLY, PAGE_READ_WRITE, or ERROR. In order to access the page protection flags, the Storage Description Registers, SDR0 and SDR1, must be accessed to determine the origins of the Hash Allocation Table (HAT) and the Page Frame Table (PFT).
DPUSDS5.2.3.9;Install Project-Specific Module Error Identifiers	In order to provide a mechanism by which error numbers can be unique across device drivers and applications, each error number must contain a unique module identifier in the most significant word of the error number.  These module identifiers are defined in a VxWorks® header file.
DPUSDS5.2.4.0;Operating System Extensions		Routines available for use by system drivers and various applications software are kept in an extension library which is part of the DPU System Software CSCI.
DPUSDS5.2.4.1;Data Transfer Library		In order to transfer data more efficiently across the VME bus, a data transfer library is provided.  The library consists of a function which utilizes the move multiple and store multiple instructions to decrease VME data transfer time.  This library is called the “blt” library, which is short for “block transfer library”, even though the library does not technically implement VME block transfers.
DPUSDS5.2.4.1;Data Transfer Library	 This function uses the move multiple instruction to more efficiently transfer large amounts of data between memory areas.
DPUSDS5.2.4.2;Checksum Library	A number of checksum algorithms are required by various system and application software modules.  In order to avoid duplication of code, the various checksum algorithms are encapsulated into a checksum library.
DPUSDS5.2.4.2;Checksum Library 	This function performs a checksum on a specified memory range.  The checksum is performed as an 8-bit additive checksum, but the accumulated value is stored in a 16-bit variable.
DPUSDS5.2.4.2;Checksum Library	This function performs a checksum on a specified memory range.  The checksum is performed as an bit XOR.
DPUSDS5.2.4.2;Checksum Library	This function performs a checksum on a specified memory range.  The checksum is performed as a 32-bit additive checksum.
DPUSDS5.2.4.3;Watchdog Library	The DPU contains a hardware watchdog which must be strobed periodically in order to prevent a DPU reboot.
DPUSDS5.2.4.3;Watchdog Library	This function strobes the system watchdog to prevent a watchdog reset.
DPUSDS5.2.4.4;Real-Time Clock Interface	The Real-Time Clock (RTC) Registers of the RAD6000 are special-purpose registers not normally accessible to C language programs.  Some assembler wrapper functions provide access to these.
DPUSDS5.2.4.4;Real-Time Clock Interface	This routine gets the value of the Real-Time Clock (RTC) Registers and places the results in variables rtcu and rtcl.
DPUSDS5.2.4.4;Real-Time Clock Interface	This routine sets the value of the RTC Registers
DPUSDS5.2.5.0;Hardware Interfaces	VxWorks? interfaces directly with the RAD6000 CPU Module hardware in the Board Support Package (BSP).
DPUSDS5.2.6.0;Error Recovery	Except for the modification described in Sections 5.2.3.6, no further modifications to the existing task error-handling mechanisms are required. VxWorks? uses a global mechanism for returning status codes when errors occur.  This is accomplished  by using the task variable, errno (stored in the task control block).  Most VxWorks? functions return a STATUS value.  This value can either be OK or ERROR.  If a function returns ERROR, then the errno variable must indicate a specific error code.
DPUSDS5.3.0;Built-In Test CSC	The Built-In Test (BIT) CSC is a Level 2 reuse component from the SSFF and INSTRUMENT Y projects.  The detailed design of the BIT CSC follows. The Built-In Tests CSC, identified DPU-BIT, performs the Stage 2 Built-In Tests (BIT).  The Stage 2 BIT includes a test of the SCM EDAC circuit, a checksum test on SCM PROM, a MIL-STD-1553B internal BIT, and a memory test of the DCI Data Buffers. The results of the BIT are recorded in the SYS_CNFG_AREA in EEPROM and are also maintained in DRAM.  If an error occurs in one of the functions performing the BIT, the test result will be reported as a failure in the test itself.
DPUSDS5.3.1;Initialization	The DPU-BIT should be initialized every time the DPU boots.  The startup task, usrRoot() should call bitPart1() before initializing the device drivers and bitPart2() after initializing EDAC and the device drivers.
DPUSDS5.3.2.1;External Program Interfaces	This routine copies the BIT Results into bitHk for inclusion in the DPU Housekeeping.
DPUSDS5.3.2.1;External Program Interfaces	Performs the device SRAM tests, which must be done before the drivers are initialized.
DPUSDS5.3.2.1;External Program Interfaces	Performs the SCM EDAC test, PROM checksum test, and device loopback tests for those devices which support it.
DPUSDS5.3.2.1;External Program Interfaces	Reads the BIT results from the location pointed to by pBitResults (which is assumed to be in EEPROM) into the BIT results data structure in DRAM.
DPUSDS5.4.0;Error Detection and Correction CSC	The Error Detection and Correction (EDAC) CSC is a Level 1 reuse component from the SSFF and INSTRUMENT Y projects.  The EDAC CSC consists of a set of Interrupt Service Routines (ISRs) and a Memory Scrubber Task.  The design of the INSTRUMENT Y EDAC CSC is described in document CIDPSDS-01.The only design change was to add logic to check for excessive external (SCM) EDAC interrupts.
DPUSDS5.5.0;1553 Driver CSC	The MIL-STD-1553B (1553) Driver CSC is a Level 1 reuse component from the SSFF and INSTRUMENT Y projects.  The 1553 Driver is compatible with the UTMC S?MMIT™ controller on the SCM.
DPUSDS5.6.0;Generic VME Driver CSC	The Generic VME (GVME) Driver CSC is a Level 1 reuse component from the INSTRUMENT Y project.  The GVME Driver provides a set of convenience routines which are useful when accessing registers and memory in the VME memory space.
DPUSDS5.7.0;Analog to Digital Converter Driver CSC	The Analog to Digital Converter (ADC) Driver CSC is a new driver which controls and retrieves data from the ADC hardware.  The key elements of the ADC driver include: * A list (array of ADC_LIST_ENTRY) which maintains the setup information and current value (ADC_VALUE) for each of the 24 ADC values.  * An API function, adcUpdateNext(), which causes a single ADC_VALUE to be updated every other call to the driver.  A value is updated every other call since each value requires a multiplexer settle time as well as an ADC conversion time.  In order to keep the driver simple, the responsibility for implementing the correct settle time and conversion time rests with the application. * An API function, adcGet(), which returns a copy of the current list of ADC_VALUEs.
DPUSDS5.7.1;"Initialization	The driver is initialized by invoking the initialization function adcInit().  The function initializes the ADC_LIST_ENTRY array, sets up convenience pointers to the ADC hardware registers, and sets up the ADC multiplexer for the first conversion (otherwise the very first ADC value requires three calls to adcUpdateNext()).  The ADC Driver can be re-initialized, which will result in the values in the ADC_LIST_ENTRY array being reset to their default values. The ADC_VALUEs are A-bit data items; however the hardware contains a B-bit A/D.  The upper bits are used to indicate invalid or suspect values as follows: * At initialization, the MSbit of each of the ADC_VALUEs is set (0x8000). * If a conversion fails (i.e. the driver reads the analog value and determines that the conversion has not yet completed), the second MSbit."
DPUSDS5.7.2;Performing Analog-to-Digital Conversions	The ADC Driver maintains an array of ADC_LIST_ENTRY data structures which contain the hardware multiplexer setup information for each of the x analog inputs, and the current value (ADC_VALUE) of each analog input.  To update a single value in the list, an application must call the update function adcUpdateNext().  The ADC hardware only has a single A/D channel, and so to perform an A/D conversion the hardware requires a multiplexer setup and corresponding settle time, as well as the normal A/D conversion time.  Therefore, it takes two calls to adcUpdateNext() to update a single value in the list.  To keep the driver simple and to avoid embedding hard waits in the driver, the application is required to implement the setup and conversion time by spacing successive calls to the adcUpdateNext() function appropriately.
DPUSDS5.7.3;Retrieving ADC Current Values	An application can retrieve the current list of ADC_VALUEs by calling the adcGet() function.  This function copies the ADC_VALUEs into an array provided (via pointer) by the calling application.
DPUSDS5.7.4.0;ADC Driver Functions	The ADC Driver CSC is a non-standard device driver (i.e is not integrated with the VxWorks™ standard I/O system).
DPUSDS5.7.4.1;ADC Driver Functions	Returns a copy of the array containing the current values for each of the ADC_VALUEs.
DPUSDS5.7.4.2;ADC Driver Functions	The function initializes the ADC_LIST_ENTRY array, sets up convenience pointers to the ADC hardware registers, and sets up the ADC multiplexer for the first conversion (otherwise the very first ADC value requires three calls to adcUpdateNext()).  The ADC Driver can be re-initialized, which will result in the values in the ADC_LIST_ENTRY array being reset to their default values.
DPUSDS5.7.4.3;ADC Driver Functions	Updates the next entry in the array of ADC_VALUEs.  The function must be called twice to update a single value.  “Even” calls read the result of the prior conversion and setup the multiplexer for the next value.  “Odd”calls start the conversion setup in the previous call.
DPUSDS5.8.0;Synchronous Serial Interface Driver CSC	The Synchronous Serial Interface (SSI) Driver CSC is a new driver which provides an application layer interface to the SSI hardware.  The SSI Driver CSC is implemented on top of the VxWorks™ tyLib library to manage its ring buffers.   The driver features a standard I/O interface which utilizes an extended ioctl() command set to support unique SSI hardware attributes.  This driver is patterned after the older VxWorks® 5.2 serial driver architecture rather than the newer Tornado serial driver architecture due to the lack of programmer control over I/O in the newer Tornado driver architecture.
DPUSDS5.8.1;Standard I/O Interface		The open(), and creat() primitives return a unique file descriptor which is used to access the SSI port on the Company X Communications Module.  Once the port has been opened by a running task, it cannot be opened by another running task.  The driver will return an ERROR if an application tries to open a port that has already been opened.By default, open initializes the driver with no messaging mode set for either Rx or Tx.  The internal semaphore used to block calling applications is initialized to WAIT_FOREVER, and all event counters are set to zero.
DPUSDS5.8.1;Standard I/O Interface		The close primitive releases access to the port.
DPUSDS5.8.1;Standard I/O Interface		The read() primitive does not block.  The read() primitive is implemented by simply passing its parameters to the tyLib function tyRead().The size of the Rx ring buffer is specified in the call to ssiDevCreate() as part of the device instantiation. This routine returns either the number of bytes read, or ERROR.
DPUSDS5.8.1;Standard I/O Interface 	The write primitive does not block.  The write() primitive is managed by the tyLib function, tyWrite() when the driver is not in BGTX Message Mode.  The size of the Tx ring buffer is specified in the call to ssiDevCreate() as part of the device instantiation. This routine returns either the number of bytes written, or ERROR.
DPUSDS5.8.1;Standard I/O Interface	SSI ioctl() commands.
DPUSDS5.8.2;Transmit Message Mode(FIOSSIBGTXMSGENABLE) and Inter-Block Gap interrupts	The SSI Driver CSC supports a message mode to facilitate application level communication.  This mode uses the Inter-Block Gap interrupt generated by the hardware to synchronize message transmission. When in a messaging mode, the driver enables an internal Byte Count queue provides a synchronization mechanism for sending messages.  This Byte Count queue is updated with the message size as Inter-Block Gap interrupts are received. The Transmit Message Mode uses the BGTX interrupt, the Tx FIFO Empty Interrupt, the write() call, and an internal Byte Count queue to synchronize the transmission of messages over SSI.  In this mode, the maxBytes parameter passed to write() is enqueued to the Byte Count queue.  When a period of time equal to or greater than the Interblock Gap time has expired, the BGTX interrupt will be asserted.  At this time, the driver will respond and initiate a new transfer by setting a Byte Transfer Limit for this block and enabling the Tx FIFO Empty Interrupt.  The Byte Transfer Limit corresponds to the entry on the Byte Count queue.  When all bytes in the current block have been sent up to the Byte Transfer Limit, the Tx FIFO ISR will disable itself and reset the Byte Transfer Limit to zero. An application may use this mode by calling write() with a buffer pointer and maxBytes in order to transfer a message of a particular length.
DPUSDS5.8.3;Hardware Interfaces	The SSI Driver CSC accesses each of the registers on the Company X Communications module using D16 VME access.
DPUSDS5.8.4;Initialization	The SSI Driver CSC is initialized by calling the function ssiDrv() from the startup task usrRoot().
DPUSDS5.9.0;Data Capture Interface Driver CSC	The Data Capture Interface (DCI) Driver CSC is a new driver which provides a standard VxWorks™ driver interface to the DCI hardware.  The driver features two modes: a test mode and a normal mode.
DPUSDS5.9.1.1;Standard I/O Interface		The open(), and creat() primitives returns a unique file descriptor which is used to access a single DCI port on the Company X Communications Module.  Once the port has been opened by a running task, it cannot be opened by another running task.  The driver will return an ERROR if an application tries to open a port that has already been opened.By default, open() initializes the driver in NORMAL mode.  An ioctl call may be issued to force into TEST mode.
DPUSDS5.9.1.2;Standard I/O Interface		The close primitive releases access to the port.
DPUSDS5.9.1.3;Standard I/O Interface		The read() primitive does not block.  A read is performed on the active portion of the H/W ping pong buffer using the RAD 6000 move-multiple instruction, referred to here after as a “block move”.  For optimum performance, the block move is implemented in assembler.  The number of bytes read is returned to the caller.
DPUSDS5.9.1.4;Standard I/O Interface		The write primitive does not block.  The buffer passed to write is written directly to the active portion of the ping pong buffer by the driver.  This primitive is valid only in TEST mode.  The write call will set errno to S_dci_MODE_ERROR and return ERROR if the driver is in NORMAL mode.  In TEST mode, the driver returns the number of bytes written.
DPUSDS5.9.1.5;Standard I/O Interface		The ioctl() entry point controls all interface configuration.  Different commands may be available depending on whether the driver is in NORMAL or TEST mode.  Any other value of the command parameter causes errno to be set to S_dci_IOCTL_UNDEF and ERROR to be returned.
DPUSDS5.9.2;Hardware Interfaces	The DCI Driver CSC accesses each of the registers on the Company X Communications module using D16 VME access mode.  Reads from DCI memory are performed in VME D32 mode via a special assembly language routine which uses the lwm/stm instructions to minimize the transfer time.
DPUSDS5.9.3;Initialization	The DCI Driver CSC is initialized by calling the functions dciDrv() and dciDevCreate()  from the startup task usrRoot().
