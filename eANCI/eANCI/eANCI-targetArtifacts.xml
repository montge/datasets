<?xml version="1.0" encoding="utf-8"?>
<artifacts_collection>
  <collection_info>
    <id>CC</id>
    <name>eANCI Target Artifacts</name>
    <version>1.11.32</version>
    <description>Class code</description>
  </collection_info>
  <artifacts>
    <artifact>
      <id>CC140</id>
      <content>package Manager;

import java.util.Collection;

import Bean.Accesso;
import DB.DbAccesso;
import DB.DbException;

/**
* La classe AccessManager interagisce con le classi di gestione del database
* La classe AccessManager non ha dipendenze
* @author Federico Cinque
*/
public class AccessManager {
	private DbAccesso dbAccesso;
	/**
	 * Costruttore di default della classe AccessManager
	 */
	public AccessManager(){
		dbAccesso=new DbAccesso();
	}
	/**
	 * Metodo che permette di controllare la correttezza della login e della 
	 * password di un accesso invocando il relativo metodo della classe db
	 * @param login Stringa che viene usata come login
	 * @param password Stringa che viene usata come password
	 * @return True se l'accesso è presente, False altrimenti
	 * @throws DbException
	 */
	public boolean controllaAccesso(String login, String password)throws DbException{
		return dbAccesso.controllaAccesso(login, password);
	}
	/**
	 * Metodo che permette di controllare l'esistenza della login 
	 * invocando il relativo metodo della classe db
	 * @param login Stringa che viene usata come login
	 * @return True se la login è presente, False altrimenti
	 * @throws DbException
	 */
	public boolean controllaLogin(String login)throws DbException{
		return dbAccesso.controllaLogin(login);
	}
	/**
	 * Metodo che restituisce un accesso invocando il relativo metodo della classe db
	 * @param login Stringa che viene usata come login
	 * @return Restituisce un oggetto di tipo Accesso
	 * @throws DbException
	 */
	public Accesso getAccesso(String login)throws DbException{
		return dbAccesso.getAccesso(login);
	}

	public boolean modificaAccesso(String login, Accesso newAccesso)throws DbException{
		return dbAccesso.modificaAccesso(login, newAccesso);
	}
	/**
	 * Metodo che inserisce un accesso all'interno del db 
	 * invocando il relativo metodo della classe db
	 * @param ac Oggetto di tipo Accesso
	 * @return True se è stato effettuato un inserimento nel db, False altrimenti
	 * @throws DbException
	 */
	public boolean inserisciAccesso(Accesso ac)throws DbException{
		return dbAccesso.inserisciAccesso(ac);
	}
	/**
	 * Metodo che elimina un accesso dal db invocando il relativo metodo della classe db
	 * @param login Stringa che viene usata come login
	 * @return True se è stato effettuato una cancellazione nel db, False altrimenti
	 * @throws DbException
	 */
	public boolean eliminaAccesso(String login)throws DbException{
		return dbAccesso.eliminaAccesso(login);
	}
	/**
	 * Metodo che restituisce tutti gli accessi memorizzati 
	 * invocando il relativo metodo della classe db
	 * @return Restituisce una Collection di Accessi
	 * @throws DbException
	 */
	public Collection&lt;Accesso&gt; getAccessi()throws DbException{
		return dbAccesso.getAccessi();
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC141</id>
      <content>package Bean;
/**
* La classe Accesso permette la gestione degli accessi
* La classe Accesso non ha dipendenze
* @author Federico Cinque
*/
public class Accesso {
	
	private String Login;
	private String Password;
	private String Tipo;
	
	/**
	 * Costruttore vuoto della classe Accesso
	 */
	public Accesso(){
		Login=null;
		Password=null;
		Tipo=null;
	}
	/**
	 * Costruttore della classe Accesso
	 * @param Login
	 * @param Password
	 * @param Tipo
	 */
	public Accesso(String Login, String Password, String Tipo){
		this.Login=Login;
		this.Password=Password;
		this.Tipo=Tipo;
	}
	/**
	 * Metodo che restituisce una login
	 * @return Login
	 */
	public String getLogin() {
		return Login;
	}
	/**
	 * Metodo che imposta una login
	 * @param login
	 */
	public void setLogin(String login) {
		Login = login;
	}
	/**
	 * Metodo che restituisce una password
	 * @return Password
	 */
	public String getPassword() {
		return Password;
	}
	/**
	 * Metodo che imposta una password
	 * @param password
	 */
	public void setPassword(String password) {
		Password = password;
	}
	/**
	 * Metodo che restituisce il tipo di utente che accede
	 * @return Tipo
	 */
	public String getTipo() {
		return Tipo;
	}
	/**
	 * Metodo che imposta il tipo di utente che accede 
	 * @param tipo
	 */
	public void setTipo(String tipo) {
		Tipo = tipo;
	}
	/**
	 * Metodo che converete in una stringa le informazioni di un accesso
	 * @return String
	 */
	public String toString() {
		return &quot;Login: &quot;+Login+&quot;, Password: &quot;+Password+&quot;, Tipo: &quot;+Tipo;
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC142</id>
      <content>package Manager;

import java.util.Collection;

import Bean.Amministratore;
import DB.DbAmministratore;
import DB.DbException;
/**
* La classe AdminManager interagisce con le classi di gestione del database
* La classe AdminManager non ha dipendenze
* @author Federico Cinque
*/
public class AdminManager {
	private DbAmministratore dbAmministratore;
	/**
	 * Costruttore di default della classe AdminManager
	 */
	public AdminManager(){
		dbAmministratore = new DbAmministratore();
	}
	/**
	 * Metodo che modifica un amministratore
	 * invocando il relativo metodo della classe db
	 * @param matricola la stringa che identifica l'amministratore
	 * @param newAdmin Amministratore con i dati aggiornati
	 * @return True se è stato effettuato un inserimento nel db, False altrimenti
	 */
	public boolean modificaAdmin(String matricola, Amministratore newAdmin)throws DbException{
		return dbAmministratore.modificaAmministratore(matricola, newAdmin);
	}
	/**
	 * Metodo che restituisce un amministratore
	 * invocando il relativo metodo della classe db
	 * @param matricola stringa che viene utilizzato come matricola dell'amministratore
	 * @return Restituisce un oggetto di tipo Amministratore
	 * @throws DbException
	 */
	public Amministratore ricercaAdminByMatricola(String matricola)throws DbException{
		return dbAmministratore.getAmministratoreByMatricola(matricola);
	}
	/**
	 * Metodo che inserisce un amministratore all'interno del db
	 * invocando il relativo metodo della classe db
	 * @param newAdmin Oggetto di tipo Amministratore
	 * @return True se è stato effettuato un inserimento nel db, False altrimenti
	 * @throws DbException
	 */
	public boolean inserisciAdmin(Amministratore newAdmin)throws DbException{
		return dbAmministratore.inserisciAmministratore(newAdmin);
	}
	/**
	 * Metodo che elimina un Amministratore dal db
	 * invocando il relativo metodo della classe db
	 * @param matricola l'intero che viene utilizzato come matricola
	 * @return True se è stato effettuato una cancellazione nel db, False altrimenti
	 * @throws DbException
	 */
	public String eliminaAmministratore(String matricola)throws DbException{
		Collection&lt;Amministratore&gt; Amministratori = dbAmministratore.getAmministratori();
		if(Amministratori.size()&gt;1){
			if(dbAmministratore.eliminaAmministratore(matricola))
				return &quot;ok&quot;;
			else
				return &quot;errore&quot;;
		}
		else
			return &quot;unico&quot;;
	}
	/**
	 * Metodo che restituisce un amministratore
	 * invocando il relativo metodo della classe db
	 * @param login stringa che viene utilizzata come login dell'amministratore
	 * @return Restituisce un oggetto di tipo amministratore
	 * @throws DbException
	 */
	public Amministratore getAmministratoreByLogin(String login) throws DbException{
		return dbAmministratore.getAmministratoreByLogin(login);
	}
	/** Metodo che restituisce un insieme di amministratori
	 * invocando il relativo metodo della classe db
	 * @param nomeAmm stringa che viene utilizzata come nome dell'amministratore
	 * @param cognAmm stringa che viene utilizzata come cognome dell'amministratore
	 * @return Restituisce una Collection di Amministratori
	 * @throws DbException
	 */
	public Collection&lt;Amministratore&gt; getAmministratoreByName(String nomeAmm,String cognAmm) throws DbException{
		return dbAmministratore.getAmministratoreByName(nomeAmm, cognAmm);
	}
	/**
	 * Metodo che restituisce tutti gli amministratori memorizzati
	 * @return Restituisce una Collection di Amministratori
	 * @throws DbException
	 */
	public Collection&lt;Amministratore&gt; getAmministratori() throws DbException{
		return dbAmministratore.getAmministratori();
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC143</id>
      <content>package Bean;
/**
* La classe Amministratore permette la gestione degli amministratori
* La classe Amministratore non ha dipendenze
* @author Federico Cinque
*/
public class Amministratore {

	private String Nome;
	private String Cognome;
	private String Matricola;
	private String Email;
	private String Login;
	
	/**
	 * Costruttore vuoto della classe Amministratore
	 */
	public Amministratore(){
		Nome=null;
		Cognome=null;
		Matricola=null;
		Email=null;
		Login=null;
	}
	/**
	 * Costruttore della classe Amministratore
	 * @param Nome
	 * @param Cognome
	 * @param Matricola
	 * @param Email
	 * @param Login
	 */
	public Amministratore(String Nome, String Cognome, String Matricola, String Email, String Login){
		this.Nome=Nome;
		this.Cognome=Cognome;
		this.Matricola=Matricola;
		this.Email=Email;
		this.Login=Login;
	}
	/**
	 * Metodo che restituisce il nome dell'impiegato
	 * @return Nome
	 */
	public String getNome() {
		return Nome;
	}
	/**
	 * Metodo che imposta il nome dell'impiegato
	 * @param nome
	 */
	public void setNome(String nome) {
		Nome = nome;
	}
	/**
	 * Metodo che restituisce il cognome dell'impiegato
	 * @return Cognome
	 */
	public String getCognome() {
		return Cognome;
	}
	/**
	 * Metodo che imposta il cognome dell'impiegato
	 * @param cognome
	 */
	public void setCognome(String cognome) {
		Cognome = cognome;
	}
	/**
	 * Metodo che restituisce la matricola dell'impiegato
	 * @return Matricola
	 */
	public String getMatricola() {
		return Matricola;
	}
	/**
	 * Metodo che imposta la matricola dell'impiegato
	 * @param matricola
	 */
	public void setMatricola(String matricola) {
		Matricola = matricola;
	}
	/**
	 * Metodo che restituisce l'e-mail dell'impiegato
	 * @return Email
	 */
	public String getEmail() {
		return Email;
	}
	/**
	 * Metodo che imposta l'e-mail dell'impiegato
	 * @param email
	 */
	public void setEmail(String email) {
		Email = email;
	}
	/**
	 * Metodo che restituisce la login dell'impiegato
	 * @return Login
	 */
	public String getLogin() {
		return Login;
	}
	/**
	 * Metodo che imposta la login dell'impiegato
	 * @param login
	 */
	public void setLogin(String login) {
		Login = login;
	}
	/**
	 * Metodo che converete in una stringa le informazioni di un accesso
	 * @return String
	 */
	public String toString() {
		return &quot;Nome: &quot;+Nome+&quot;, Cognome: &quot;+Cognome+&quot;, Matricola: &quot;+Matricola+&quot;, e-mail: &quot;+Email+&quot;, Login: &quot;+Login;
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC144</id>
      <content>package Bean;

import java.util.Date;
/**
* è un JavaBean che gestisce i metodi di settaggio
* e restituzione degli attributi della carta
* di identità di un cittadino
* @author Francesco
*
*/
public class CartaIdentita {
	/**
	 * rappresenta il codice della carta di identità
	 * che viene inserito dall'impiegato
	 */
	private String Numero;
	private int idCittadino;
	
	private String Cittadinanza;
	private String Residenza;
	private String Via;
	private String StatoCivile;
	private String Professione;
	private double Statura;
	private String Capelli;
	private String Occhi;
	private String SegniParticolari; 
	private Date DataRilascio;
	private Date DataScadenza;
	private boolean ValidaEspatrio;
	private int num_civico;
	/**
	 * Costruttore di default vuoto
	 */

	public CartaIdentita() {
		this.num_civico=0;
		this.Capelli=null;
		this.Cittadinanza=null;
		this.DataRilascio=null;
		this.DataScadenza=null;
		
		this.Numero=null;
		this.Occhi=null;
		this.Professione=null;
		this.Residenza=null;
		this.SegniParticolari=null;
		this.StatoCivile=null;
		this.Statura=0.00;
		this.ValidaEspatrio=false;
		this.Via=null;
	}
	/**
	 * oggetto che viene restituito dal database
	 * @param cod_carta
	 * @param citt
	 * @param res
	 * @param via
	 * @param stciv
	 * @param prof
	 * @param stat
	 * @param cap
	 * @param eyes
	 * @param sp
	 * @param dr
	 * @param ds
	 * @param validEsp
	 * @param num_civ
	 */
	public CartaIdentita(String cod_carta,int idC,String cittadinanza,String res,String via,int num,
			String stciv,String prof,double stat,String cap,String eyes,String sp,Date dr,Date ds,boolean validEsp){
		this.Numero=cod_carta;
		this.idCittadino=idC;
		
		this.Cittadinanza=cittadinanza;
		this.Residenza=res;
		this.Via=via;
		this.num_civico=num;
		this.StatoCivile=stciv;
		this.Professione=prof;
		this.Statura=stat;
		this.Capelli=cap;
		this.Occhi=eyes;
		this.SegniParticolari=sp;
		this.DataRilascio=dr;
		this.DataScadenza=ds;
		this.ValidaEspatrio=validEsp;
	}
		// TODO Auto-generated constructor stub
	/**
	 * crea la carta di identità del cittadino che si è 
	 * registrato nel sistema comunale prendendo dalla classe
	 * cittadino le informazioni necessarie per la creazione
	 * del documento di riconoscimento
	 */
	public CartaIdentita(String cod_carta,String surname,String name,Date borndate,String citt,String res,String via,int num,
			String stciv,String prof,double stat,String cap,String eyes,String sp,Date dr,Date ds,boolean validEsp){
		/**
		 * il codice univoco della carta di identità richiesta dal cittadino, viene 
		 * inserito dall'impiegato all'atto della creazione cartacea del documento e nel momento
		 * in cui le informazioni devono essere mantenute nel database.
		 * 
		 */
		this.Numero=cod_carta;
		/**
		 * assegno la carta di identità che sto creando al cittadino
		 * che ne ha fatto richiesta e che è presente all'interno del
		 * database comunale
		 */
		
		this.Cittadinanza=citt;
		this.Residenza=res;
		this.Via=via;
		this.num_civico=num;
		this.StatoCivile=stciv;
		this.Professione=prof;
		this.Statura=stat;
		this.Capelli=cap;
		this.Occhi=eyes;
		this.SegniParticolari=sp;
		this.DataRilascio=dr;
		this.DataScadenza=ds;
		this.ValidaEspatrio=validEsp;
		
	}
	public int id(){
		return idCittadino;
	}
	public void setNumero(String code){
		Numero=code;
	}
	public String getNumero(){
		return Numero;
	}
	
	public void setCittadinanza(String citta){
		Cittadinanza=citta;
	}
	public String getCittadinanza(){
		return Cittadinanza;
	}
	public String getResidenza(){
		return Residenza;
	}
	public void setResidenza(String res){
		Residenza=res;
	}
	public void setVia(String list){
		Via=list;
	}
	public String getVia(){
		return Via;
	}
	public int getNumCivico(){
		return num_civico;
	}
	public void setNumCivico(int n){
		num_civico=n;
	}
	public void setStatoCivile(String stat){
		StatoCivile=stat;
	}
	public String getStatoCivile(){
		return StatoCivile;
	}
	public void setProfessione(String prof){
		Professione=prof;
	}
	public String getProfessione(){
		return Professione;
	}
	public void setStatura(double stat){
		Statura=stat;
	}
	public double getStatura(){
		return Statura;
	}
	public void setCapelli(String hair){
		Capelli=hair;
	}
	public String getCapelli(){
		return Capelli;
	}
	public void setOcchi(String eyes){
		Occhi=eyes;
	}
	public String getOcchi(){
		return Occhi;
	}
	public String getSegniParticolari(){
		return SegniParticolari;
	}
	public void setSegniParticolari(String listSp){
		SegniParticolari=listSp;
	}
	public void setDataRilascio(Date data){
		DataRilascio=data;
	}
	public Date getDataRilascio(){
		return DataRilascio;
	}
	public void setDataScadenza(Date datas){
		DataScadenza=datas;
	}
	public Date getDataScadenza(){
		return DataScadenza;
	}
	public void setValiditaEspatrio(boolean val){
		ValidaEspatrio=val;
	}
	public boolean isValidaEspatrio(){
		return ValidaEspatrio;
	}
	
	@SuppressWarnings({ &quot;deprecation&quot;, &quot;deprecation&quot;, &quot;deprecation&quot; })
	public String toString(){
		
		int month2=0;
		month2 = getDataRilascio().getMonth();
		int month3=0;
		month3 = getDataScadenza().getMonth();
		return //mi devo recuperare il cognome, nome, e data nascita dalla classe db
				
				&quot;Cittadinanza : &quot;+getCittadinanza()+&quot;\n&quot;+
				&quot;Residenza : &quot;+getResidenza()+&quot;\n&quot;+
				&quot;Via : &quot;+getVia()+&quot;\n&quot;+
				&quot;Numero Civico : &quot;+getNumCivico()+&quot;\n&quot;+
				&quot;Stato Civile : &quot;+getStatoCivile()+&quot;\n&quot;+
				&quot;Professione : &quot;+getProfessione()+&quot;\n&quot;+
				&quot;\nCONNOTATI E CONTRASSEGNI SALIENTI\n\n&quot;+
				&quot;Statura : &quot;+getStatura()+&quot;\n&quot;+
				&quot;Capelli : &quot;+getCapelli()+&quot;\n&quot;+
				&quot;Occhi : &quot;+getOcchi()+&quot;\n&quot;+
				&quot;Segni Particolari : &quot;+getSegniParticolari().toString()+&quot;\n&quot;+
				&quot;li : &quot;+getDataRilascio().getDate()+&quot;/&quot;+month2+1+&quot;/&quot;+getDataRilascio().getYear()+&quot;\n&quot;+
				&quot;Data di Scadenza : &quot;+getDataScadenza().getDate()+&quot;/&quot;+month3+1+&quot;/&quot;+getDataScadenza().getYear()+&quot;\n&quot;;
	}

}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC145</id>
      <content>package Manager;

import Bean.CartaIdentita;
import DB.*;
/**
* La classe CIManager interagisce con le classi di gestione del database
* La classe CIManager non ha dipendenze
* @author Federico Cinque
*/
public class CIManager {
	private DbCartaIdentita dbCartaIdentita;
	/**
	 * Costruttore di default della classe CIManager
	 */
	public CIManager(){
		dbCartaIdentita = new DbCartaIdentita();
	}
	/**
	 * Metodo che permette la ricerca di una carta d'identita tramite il suo numero
	 * invocando il relativo metodo della classe db
	 * @param cod il numero della carta d'identità del cittadino.
	 * @return l'oggetto di tipo CartaIdentità associata al numero passato come parametro
	 * @throws DbException
	 */
	public CartaIdentita getCartaByNumero(String cod)throws DbException{
		return dbCartaIdentita.ricercaCartaIdentitaByNumero(cod);
	}
	
	public CartaIdentita getCartaByIdCStri(int id)throws DbException{
		return dbCartaIdentita.ricercaCartaIdentitaByProprietario(id);
	}
	
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC146</id>
      <content>package Bean;
import java.util.Date;

/**
* è un JavaBean che gestisce i metodi 
* get e set degli attributi di un Cittadino
* @author Francesco
*
*/
public class Cittadino {
	private CartaIdentita ci;
private int idCittadino;
private String CodiceFiscale;
private String Cognome;
private String Nome;
private Date DataNascita;
private String LuogoNascita;
private String Email;
private boolean Advertise;
private int nucleoFamiliare;
private String Login;

	/**
	 * costruttore di default vuoto
	 */
	public Cittadino() {
		this.Advertise=false;
		this.CodiceFiscale=&quot;&quot;;
		this.Cognome=&quot;&quot;;
		this.DataNascita=null;
		this.LuogoNascita=&quot;&quot;;
		this.Email=&quot;&quot;;
		
		this.Login=&quot;&quot;;
		this.Nome=&quot;&quot;;
		
	}
	public Cittadino(String code,String cog,String nome,String res,String via){
		ci.setNumero(code);
		this.Cognome=cog;
		this.Nome=nome;
		ci.setResidenza(res);
		ci.setVia(via);
	}
	public Cittadino(int nf,String codfis,String cog,String name,Date data,String luogo){
		this.nucleoFamiliare=nf;
		this.CodiceFiscale=codfis;
		this.Cognome=cog;
		this.Nome=name;
		this.DataNascita=data;
		this.LuogoNascita=luogo;
		
	}
		// TODO Auto-generated constructor stub
	/**
	 * costruttore parametrico che crea l'oggetto
	 * cittadino con i dati inseriti da quest'ultimo 
	 * all'atto della registrazione nel sistema comunale
	 */
	public Cittadino(int id,String cod_fis,String surname,String name,Date data,String luogo,String mail,boolean adv,int nf,String l){
		this.idCittadino=id;
		this.CodiceFiscale=cod_fis;
		this.Cognome=surname;
		this.Nome=name;
		this.DataNascita=data;
		this.LuogoNascita=luogo;
		this.Email=mail;
		this.Advertise=adv;
		this.nucleoFamiliare=nf;
		this.Login=l;
	}
	public String getLogin(){
		return Login;
	}
	public void setLogin(String log){
		Login=log;
	}
	public int getIdCittadino(){
		return idCittadino;
	}
	public void setIdCittadino(int idCittadino) {
		this.idCittadino = idCittadino;
	}
	public String getCognome(){
		return Cognome;
	}
	public void setCognome(String surname){
		Cognome=surname;
	}
	public String getNome(){
		return Nome;
	}
	public void setNome(String name){
		Nome=name;
	}
	public Date getDataNascita(){
		return DataNascita;
	}
	public void setDataNascita(Date data){
		DataNascita=data;
	}
	public void setLuogoNascita(String luogo){
		LuogoNascita=luogo;
	}
	public String getLuogoNascita(){
		return LuogoNascita;
	}
	public String getEmail(){
		return Email;
	}
	public void setEmail(String mail){
		Email=mail;
	}
	public boolean isAdvertise(){
		return Advertise;
	}
	public void setIsAdvertise(boolean ad){
		Advertise=ad;
	}
	public void setNucleoFamiliare(int nf)
	{
		nucleoFamiliare = nf;
	}
	public int getNucleoFamiliare()
	{
		return nucleoFamiliare;
	}
	public String getCodiceFiscale(){
		return CodiceFiscale;
	}
	public void setCodiceFiscale(String cod_fis){
		CodiceFiscale=cod_fis;
	}
	public String toString(){
		return &quot;ID : &quot;+getIdCittadino()+&quot;\n&quot;+
		 &quot;Login : &quot;+getLogin()+&quot;\n&quot;+
		 &quot;Codice fiscale : &quot;+getCodiceFiscale()+&quot;\n&quot;+
		 &quot;Nome : &quot;+getNome()+&quot;\n&quot;+
		 &quot;Cognome : &quot;+getCognome()+&quot;\n&quot;+
		 &quot;Data di nascita : &quot;+getDataNascita()+&quot;\n&quot;+
		 &quot;Luogo di Nascita : &quot;+getLuogoNascita()+&quot;\n&quot;+
		 &quot;e-mail : &quot;+getEmail()+&quot;.\n&quot;;
	}

}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC147</id>
      <content>package Manager;

import java.util.Collection;

import Bean.Cittadino;
import DB.DbCittadino;
import DB.DbException;
/**
* La classe CittadinoManager interagisce con le classi di gestione del database
* La classe CittadinoManager non ha dipendenze
* @author Federico Cinque
*/
public class CittadinoManager {

	private DbCittadino dbCittadino;
	/**
	 * Costruttore di default della classe CIManager
	 */
	public CittadinoManager(){
		dbCittadino = new DbCittadino();
	}
	/**
	 * Metodo che permette la ricerca di un cittadino tramite la sua login
	 * invocando il relativo metodo della classe db
	 * @param login è la login in base alla quale si vuole effettuare la ricerca
	 * @return l'oggetto di tipo cittadino
	 * @throws DbException
	 */
	public Cittadino getCittadinoByLogin(String login) throws DbException{
		return dbCittadino.getCittadinoByLogin(login);
	}
	/**
	 * Metodo che permette la modifica della login per uno specifico cittadino
	 * invocando il relativo metodo della classe db
	 * @param idCitt è l'id del cittadino
	 * @param newLogin è la nuova login del cittadino
	 * @return true se l'operazione è andata a buon fine, flase altrimenti
	 */
	public boolean modificaLogin(int idCitt, String newLogin)throws DbException{
		return dbCittadino.modificaLogin(idCitt,newLogin);
	}
	/**
	 * Metodo che permette la modifica dell'indirizzo e-mail di uno specifico cittadino
	 * invocando il relativo metodo della classe db
	 * @param idCittadino è l'identificativo del cittadino
	 * @param email è la nuova mail da assegnare al cittadino
	 * @return true se l'operazione è eseguita con successo, flase altrimenti
	 * @throws DbException
	 */
	public boolean modificaEmail(int idCittadino, String email) throws DbException{
		return dbCittadino.modificaEmailCittadino(idCittadino, email);
	}
	/**
	 * Metodo che permette di inserire un nuovo cittadino
	 * invocando il relativo metodo della classe db
	 * @param cittadino è l'istanza di cittadino
	 * @return l'id del cittadino inserito.
	 * @throws DbException
	 */
	public int inserisciCittadino(Cittadino cittadino)throws DbException{
		return dbCittadino.registraCittadino(cittadino);
	}
	/**
	 * Metodo che permette la ricerca di un insieme di cittadini in base al loro nome e cognome
	 * invocando il relativo metodo della classe db
	 * @param nome parametro su cui effettuare la ricerca
	 * @param cognome parametro su cui effettuare la ricerca
	 * @return una collection di cittadini con il nome e il cognome passato come parametro
	 * @throws DbException
	 */
	public Collection&lt;Cittadino&gt; ricercaCittadino(String nome, String cognome)throws DbException{
		return dbCittadino.getCittadinoByName(nome,cognome);
	}
	/**
	 * Metodo che permette la cancellazione di un cittadino
	 * invocando il relativo metodo della classe db
	 * @param idCitt è l'identificativo del cittadino
	 * @return true se l'operazione è eseguita con successo, flase altrimenti
	 * @throws DbException
	 */
	public boolean cancellaCittadino(int idCitt)throws DbException{
		return dbCittadino.cancellaCittadino(idCitt);
	}
	/**
	 * Metodo che permette la ricerca di un cittadino tramite il suo id
	 * invocando il relativo metodo della classe db
	 * @param idCitt è l'identificativo del cittadino
	 * @return oggetto di tipo cittadino con id uguale a quello passato come parametro
	 * @throws DbException
	 */
	public Cittadino getCittadinoById(int idCitt)throws DbException{
		return dbCittadino.getCittadinoByCodice(idCitt);
	}
	/**
	 * Metodo che modifica il nucleo familiare del cittadino dato il suo id
	 * invocando il relativo metodo della classe db
	 * @param idCitt è l'id del cittadino
	 * @param newid è l'id del nuovo nucleo familiare del cittadino
	 * @return true se l'operazione è eseguita con successo, flase altrimenti
	 * @throws DbException
	 */
	public boolean modificaNucleoFamiliare(int idCitt, int newid)throws DbException{
		return dbCittadino.modificaNucleoFamiliareCittadino(idCitt, newid);
	}
	/**
	 * Metodo che permette la modifica del nome di uno specifico cittadino
	 * invocando il relativo metodo della classe db
	 * @param idCitt è l'identificativo del cittadino
	 * @param nome è il nuovo nome da assegnare al cittadino
	 * @return true se l'operazione è eseguita con successo, flase altrimenti
	 * @throws DbException
	 */
	public boolean modificaNome(int idCitt, String nome)throws DbException{
		return dbCittadino.modificaNomeCittadino(idCitt, nome);
	}
	/**
	 * Metodo che permette la modifica del cognome di uno specifico cittadino
	 * invocando il relativo metodo della classe db
	 * @param idCitt è l'identificativo del cittadino
	 * @param cognome è il nuovo cognome da assegnare al cittadino
	 * @return true se l'operazione è eseguita con successo, flase altrimenti
	 * @throws DbException
	 */
	public boolean modificaCognome(int idCitt, String cognome)throws DbException{
		return dbCittadino.modificaCognomeCittadino(idCitt, cognome);
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC148</id>
      <content>package Bean;

/**
* La classe Comune permette la comunicazione con gli altri comuni
* @author Antonio Leone
* @version 1.0
*
*/
public class Comune {
	
	private String nome;
	private String indirizzoIp;
	
	/**
	 * Costruttore di default
	 */
	
	public Comune()
	{
		
	}
	
	/**
	 * Costruttore parametrico
	 * @param n nome del comune
	 * @param i indirizzo ip del comune
	 */
	
	public Comune(String n, String i)
	{
		this.nome=n;
		this.indirizzoIp=i;
	}
	
	/**
	 * Preleva il nome del comune
	 * @return Restituisce una stringa che contiene il nome del comune
	 */
	
	public String getNome()
	{
		return this.nome;
	}
	
	/**
	 * Setta il nome del comune
	 * @param n la stringa che contiene il nuovo nome del comune
	 * @return Restituisce il nuovo nome del comune
	 */
	
	public String setNome(String n)
	{
		this.nome=n;
		return n;
	}
	
	/**
	 * Preleva l'indirizo ip del comune
	 * @return Restituisce una stringa che contiene l'indirizzo ip del comune
	 */
	
	public String getIndirizzoId()
	{
		return this.indirizzoIp;
	}
	
	/**
	 * Setta l'indirizzo ip del comune
	 * @param n la stringa che contiene il nuovo indirizzo ip del comune
	 * @return Restituisce il nuovo indirizzo ip del comune
	 */
	
	public String setIndirizzoId(String i)
	{
		this.indirizzoIp=i;
		return i;
	}
	
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC149</id>
      <content>package Servlet;
import javax.servlet.http.*;
import javax.servlet.*;
import java.io.*;
import com.oreilly.servlet.*;

/**
* La classe ControllerFiles gestisce l'upload di un file
* La classe non ha nessuna dipendenza
* @author Francesco Odierna
*/

public class ControllerFiles extends HttpServlet{
	
	public void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException,IOException{
		//instanzio le variabili
		// Il ServletContext sevirà per ricavare il MIME type del file uploadato
		ServletContext context=getServletContext();
		String forward=null;
		try
		{
			// Stabiliamo la grandezza massima del file che vogliamo uploadare
			int maxUploadFile=500000000;
			MultipartRequest multi=new MultipartRequest(request, &quot;.&quot;, maxUploadFile);
			String descrizione=multi.getParameter(&quot;text&quot;);
			File myFile=multi.getFile(&quot;myFile&quot;);
			String filePath=multi.getOriginalFileName(&quot;myFile&quot;);
			String path=&quot;C:\\RichiesteCambiResidenza\\&quot;;
			try{
				// ricaviamo i dati del file mediante un InputStream
				FileInputStream inStream=new FileInputStream(myFile);
				// stabiliamo dove andrà scritto il file
				FileOutputStream outStream=new FileOutputStream(path+myFile.getName());
				// salviamo il file nel percorso specificato
	 while(inStream.available()&gt;0){
	 	outStream.write(inStream.read());
	 }
	 // chiudiamo gli stream
	 inStream.close();
	 outStream.close();
			}catch(FileNotFoundException e){
				e.printStackTrace();
			}catch(IOException e){
				e.printStackTrace();
			}
			forward=&quot;/workers/index.jsp?func=upload&amp;page=done&quot;;
			// mettiamo nella request i dati così da poterli ricavare dalla jsp 
			request.setAttribute(&quot;contentType&quot;, context.getMimeType(path+myFile.getName()));
			request.setAttribute(&quot;text&quot;, descrizione);
			request.setAttribute(&quot;path&quot;, path+myFile.getName());
			RequestDispatcher rd=request.getRequestDispatcher(forward);
			rd.forward(request, response);
		}catch(Exception e){
			e.printStackTrace();
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC150</id>
      <content>package DB;
import Bean.*;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;

/**
* La classe DbAccesso si occupa di gestire le connessioni al db
* per consentire gli accessi.
* @author Antonio Leone
* @version 1.0
*/

public class DbAccesso {

	private Connection connection;
	
	public DbAccesso() throws DbException 
	{
		try
		{
			connection=DbConnection.getConnection();
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: Connessione non riuscita&quot;);
		}
	}
	
	/**
	 * Metodo che inserisce un accesso all'interno del db
	 * @param a Oggetto di tipo Accesso
	 * @return True se è stato effettuato un inserimento nel db, False altrimenti
	 * @throws DbException
	 */
	
	public boolean inserisciAccesso(Accesso a) throws DbException
	{	
		int ret=0;
		PreparedStatement statement=null;
		String login=a.getLogin();
		String password=a.getPassword();
		String tipo=a.getTipo();
		try
		{
			statement=connection.prepareStatement(&quot;INSERT INTO accesso VALUES (? ,? ,?)&quot;);
			statement.setString(1,login);
			statement.setString(2, password);
			statement.setString(3, tipo);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: inserimento accesso non riuscito&quot;);
		}
		finally
		{
			try 
			{
				if(statement!=null)
					statement.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore: inserimento accesso non riuscito&quot;);
			}
		}
	}
	
	/**
	 * Metodo che elimina un accesso dal db
	 * @param log Stringa che viene usata come login
	 * @return True se è stato effettuato una cancellazione nel db, False altrimenti
	 * @throws DbException
	 */
	
	public boolean eliminaAccesso(String log) throws DbException
	{	
		PreparedStatement statement=null;
		int ret=0;
		try
		{
			statement=connection.prepareStatement(&quot;DELETE FROM accesso WHERE login =?&quot;);
			statement.setString(1,log);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: cancellazione accesso non riuscita&quot;);
		}
		finally
		{
			try 
			{
				if(statement!=null)
					statement.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore: cancellazione accesso non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce un accesso
	 * @param log Stringa che viene usata come login
	 * @return Restituisce un oggetto di tipo Accesso
	 * @throws DbException
	 */
	
	public Accesso getAccesso(String log) throws DbException
	{
		PreparedStatement statement=null;
		ResultSet rs=null;
		Accesso ret=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT* FROM accesso WHERE login=?&quot;);
			statement.setString(1,log);
			rs= statement.executeQuery();
			if(!rs.next())
				return ret;
			String login = rs.getString(&quot;login&quot;);
			String password = rs.getString(&quot;password&quot;);
			String tipo = rs.getString(&quot;tipo&quot;);
			ret=new Accesso(login,password,tipo);
			return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca accesso non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca accesso non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce tutti gli accessi memorizzati
	 * @return Restituisce una Collection di Accessi
	 * @throws DbException
	 */
	
	public Collection&lt;Accesso&gt; getAccessi() throws DbException
	{
		ArrayList&lt;Accesso&gt; ret = new ArrayList&lt;Accesso&gt;(); 
		Statement statement =null;
		ResultSet rs =null;
		try
		{
			statement=connection.createStatement();
			rs = statement.executeQuery(&quot;SELECT * FROM accesso&quot;);
			while(rs.next())
			{
				String login = rs.getString(&quot;login&quot;);
				String password = rs.getString(&quot;password&quot;);
				String tipo = rs.getString(&quot;tipo&quot;);
				ret.add(new Accesso(login,password,tipo));
			}
			if(ret.isEmpty())
				return null;
			else
				return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca accessi non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca accessi non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette di controllare lesistenza della login 
	 * @param login Stringa che viene usata come login
	 * @return True se la login è presente, False altrimenti
	 * @throws DbException
	 */
	
	public boolean controllaLogin(String login)throws DbException
	{
			PreparedStatement statement =null;
			ResultSet rs=null;
			boolean ret=false;
			try
			{
				statement=connection.prepareStatement(&quot;SELECT * FROM accesso WHERE login = ?&quot;);
				statement.setString(1,login);
				rs= statement.executeQuery();
				ret=rs.next();
				return ret;
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: controllo login non riuscito&quot;);
			}
			finally
			{
				try
				{
					if(statement!=null)
						statement.close();
					if(rs!=null)
						rs.close();
				}
				catch(SQLException e)
				{
					throw new DbException(&quot;Errore: controllo login non riuscito&quot;);
				}
			}
	}
	
	/**
	 * Metodo che permette di controllare la correttezza della login e della 
	 * password di un accesso per garantire l'apertura di una sessione autenticata
	 * @param login Stringa che viene usata come login
	 * @param password Stringa che viene usata come password
	 * @return True se l'accesso è presente, False altrimenti
	 * @throws DbException
	 */
	
	public boolean controllaAccesso(String login,String password)throws DbException
	{
		PreparedStatement statement =null;
		ResultSet rs=null;
		boolean ret=false;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM accesso WHERE login = ? and password = ?&quot;);
			statement.setString(1,login);
			statement.setString(2,password);
			rs= statement.executeQuery();
			ret=rs.next();
			return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: verifica accesso non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: verifica accesso non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che modifica un accesso
	 * @param log la login che identifica un accesso
	 * @param a Accesso con i dati aggiornati
	 * @return True se è stato effettuata la modifica nel db, False altrimenti
	 */
	
	public boolean modificaAccesso(String log, Accesso a)
	{
		String login=a.getLogin();
		String password=a.getPassword();
		String tipo=a.getTipo();
		int ret=0;
		PreparedStatement statement=null;
		try
		{
			statement=connection.prepareStatement(&quot;UPDATE accesso SET login = ?,password = ?, tipo = ? WHERE login = ?&quot;);
			statement.setString(1, login);
			statement.setString(2, password);
			statement.setString(3, tipo);
			statement.setString(4, log);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: modifica accesso non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: modifica accesso non riuscita&quot;);
			}
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC151</id>
      <content>package DB;
import Bean.*;
import java.sql.*;
import java.util.ArrayList;
import java.util.Collection;

/**
* La classe DbAmministratore si occupa di gestire le connessioni al db
* @author Antonio Leone
* @version 1.0
*/

public class DbAmministratore {

	private Connection connection;
	
	public DbAmministratore() throws DbException
	{
		try
		{
			connection=DbConnection.getConnection();
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: connessione non riuscita&quot;);
		}
	}
	
	/**
	 * Metodo che inserisce un amministratore all'interno del db
	 * @param i Oggetto di tipo Amministratore
	 * @return True se è stato effettuato un inserimento nel db, False altrimenti
	 * @throws DbException
	 */
	
	public boolean inserisciAmministratore(Amministratore a)throws DbException
	{
		String matr=a.getMatricola();
		String nome=a.getNome();
		String cogn=a.getCognome();
		String email=a.getEmail();
		String login=a.getLogin();
		int ret=0;
		PreparedStatement statement=null;
		try
		{
			statement=connection.prepareStatement(&quot;INSERT INTO amministratore VALUES (? ,? ,?,?,?)&quot;);
			statement.setString(1, matr);
			statement.setString(2,nome);
			statement.setString(3,cogn);
			statement.setString(4, email);
			statement.setString(5, login);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: inserimento amministratore non riuscito&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: inserimento amministratore non riuscito&quot;);
			}
		}
	}
	
	/**
	 * Metodo che elimina un Amministratore dal db
	 * @param matr l'intero che viene utilizzato come matricola
	 * @return True se è stato effettuato una cancellazione nel db, False altrimenti
	 * @throws DbException
	 */
	
	public boolean eliminaAmministratore(String matr) throws DbException
	{
		PreparedStatement statement=null;
		int ret=0;
		try
		{
			statement=connection.prepareStatement(&quot;DELETE FROM amministratore WHERE matricola =?&quot;);
			statement.setString(1,matr);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: cancellazione amministratore non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: cancellazione amministratore non riuscita&quot;);
			}
		}
	}
	
	/** Metodo che restituisce un insieme di amministratori
	 * @param nomeImp stringa che viene utilizzata come nome dell'amministratore
	 * @param cognImp stringa che viene utilizzata come cognome dell'amministratore
	 * @return Restituisce una Collection di Amministratori
	 * @throws DbException
	 */
	
	public Collection&lt;Amministratore&gt; getAmministratoreByName(String nomeAmm,String cognAmm) throws DbException
	{
		ArrayList&lt;Amministratore&gt; ret = new ArrayList&lt;Amministratore&gt;(); 
		PreparedStatement statement=null;
		ResultSet rs=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM amministratore WHERE nome =? and cognome =?&quot;);
			statement.setString(1,nomeAmm);
			statement.setString(2,cognAmm);
			rs= statement.executeQuery();
			while(rs.next())
			{
				String matr = rs.getString(&quot;matricola&quot;);
				String nome = rs.getString(&quot;nome&quot;);
				String cognome = rs.getString(&quot;cognome&quot;);
				String eMail = rs.getString(&quot;eMail&quot;);
				String login = rs.getString(&quot;login&quot;);
				ret.add(new Amministratore(nome,cognome,matr,eMail,login));
			}
			if(ret.isEmpty())
				return null;
			else
				return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca amministratore tramite nome e cognome non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca amministratore tramite nome e cognome non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce un amministratore
	 * @param matrImp stringa che viene utilizzato come matricola dell'amministratore
	 * @return Restituisce un oggetto di tipo Amministratore
	 * @throws DbException
	 */
	
	public Amministratore getAmministratoreByMatricola(String matrAmm) throws DbException
	{
		PreparedStatement statement=null;
		ResultSet rs=null;
		Amministratore ret=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM amministratore WHERE matricola =?&quot;);
			statement.setString(1,matrAmm);
			rs= statement.executeQuery();
			if(!rs.next())
				return ret;
			String matr = rs.getString(&quot;matricola&quot;);
			String nome = rs.getString(&quot;nome&quot;);
			String cognome = rs.getString(&quot;cognome&quot;);
			String eMail = rs.getString(&quot;eMail&quot;);
			String login = rs.getString(&quot;login&quot;);
			ret=new Amministratore(nome,cognome,matr,eMail,login);
			return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca amministratore tramite matricola non riuscita&quot;);
		}
		finally
		{	
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca amministratore tramite matricola non riuscita&quot;);
			}
		}	
	}
	
	/**
	 * Metodo che restituisce tutti gli amministratori memorizzati
	 * @return Restituisce una Collection di Amministratori
	 * @throws DbException
	 */
	
	public Collection&lt;Amministratore&gt; getAmministratori() throws DbException
	{
		ArrayList&lt;Amministratore&gt; ret = new ArrayList&lt;Amministratore&gt;(); 
		Statement statement =null;
		ResultSet rs =null;
		try
		{
			statement=connection.createStatement();
			rs = statement.executeQuery(&quot;SELECT * FROM amministratore&quot;);
			while(rs.next())
			{
				String matr = rs.getString(&quot;matricola&quot;);
				String nome = rs.getString(&quot;nome&quot;);
				String cognome = rs.getString(&quot;cognome&quot;);
				String eMail = rs.getString(&quot;eMail&quot;);
				String login = rs.getString(&quot;login&quot;);
				ret.add(new Amministratore(nome,cognome,matr,eMail,login));
			}
			if(ret.isEmpty())
				return null;
			else
				return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca amministratori non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca amministratori non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce un amministratore
	 * @param log stringa che viene utilizzata come login dell'amministratore
	 * @return Restituisce un oggetto di tipo amministratore
	 * @throws DbException
	 */
	
	public Amministratore getAmministratoreByLogin(String log)throws DbException
	{
		PreparedStatement statement=null;
		ResultSet rs=null;
		Amministratore ret=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM amministratore WHERE login =?&quot;);
			statement.setString(1,log);
			rs= statement.executeQuery();
			if(!rs.next())
				return ret;
			String matr = rs.getString(&quot;matricola&quot;);
			String nome = rs.getString(&quot;nome&quot;);
			String cognome = rs.getString(&quot;cognome&quot;);
			String eMail = rs.getString(&quot;eMail&quot;);
			String login = rs.getString(&quot;login&quot;);
			ret=new Amministratore(nome,cognome,matr,eMail,login);
			return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca amministratore tramite login non riuscita&quot;);
		}
		finally
		{	
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca amministratore tramite login non riuscita&quot;);
			}
		}	
	}
	
	/**
	 * Metodo che modifica un amministratore
	 * @param matr la stringa che identifica l'amministratore
	 * @param a Amministratore con i dati aggiornati
	 * @return True se è stato effettuata una modifica nel db, False altrimenti
	 */
	
	public boolean modificaAmministratore(String matr, Amministratore a)
	{
		String matricola=a.getMatricola();
		String nome=a.getNome();
		String cogn=a.getCognome();
		String email=a.getEmail();
		String login=a.getLogin();
		int ret=0;
		PreparedStatement statement=null;
		try
		{
			statement=connection.prepareStatement(&quot;UPDATE amministratore SET matricola = ?,nome = ?, cognome = ?, email = ?, login = ? WHERE matricola = ?&quot;);
			statement.setString(1, matricola);
			statement.setString(2,nome);
			statement.setString(3,cogn);
			statement.setString(4, email);
			statement.setString(5, login);
			statement.setString(6,matr);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: modifica amministratore non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: modifica amministratore non riuscita&quot;);
			}
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC152</id>
      <content>package DB;
import Bean.*;
import java.sql.Connection;
import java.sql.SQLException;

import Bean.CartaIdentita;

/**
* Classe che si occupa di gestire le connessioni con il database
* e di schermare le servet con il DBMS.
* @author Michelangelo Cianciulli
*
*/
public class DbCambioResidenza 
{
	private Connection connection;
	
	public DbCambioResidenza() throws DbException
	{	
		try
		{
			connection=DbConnection.getConnection();
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore : connessione non riuscita&quot;);
		}
	}
	
	/**
	 * Metodo che permette la cancellazione della carta d'identità  del cittadino nel 
	 * momento in cui esso cambia residenza verso un comune esterno (aggiornamento del db)
	 * @param cod è il numero della carta d'identitÃ  di chi ha chiesto il cambio di residenza verso un comune esterno
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean changeResidence (String cod) throws DbException
	{		
		return new DbCartaIdentita().cancellaCartaIdentita(cod);
	}
	
	/**
	 * Metodo che permette l'aggiornamento della residenza salvata nella carta d'identitÃ  del cittadino che ha effettuato un cambio
	 * di residenza nello stesso comune in cui attualmente risiede.(aggiornamento del db)
	 * @param cod è il numero della carta d'identitÃ 
	 * @param v è la nuova via in cui andrÃ  a risiedere il cittadino
	 * @param nc è il nuovo numero civico dell'abitazione del cittadino
	 * @return l'oggetto CartaIdentità  aggiornato 
	 * @throws DbException
	 */

	public CartaIdentita changeResidenceIn (String cod, String v,int nc) throws DbException
	{
		if (new DbCartaIdentita().modificaResidenzaCartaIdentita(cod, v, nc))
			return new DbCartaIdentita().ricercaCartaIdentitaByNumero(cod);
		else
			return null;
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC153</id>
      <content>package DB;
import Bean.*;
import java.sql.*;

import Bean.CartaIdentita;

/**
* Classe che si occupa di gestire le connessioni con 
* il database e di schermare le servlet dal DBMS.
* @author Michelangelo Cianciulli
*
*/

public class DbCartaIdentita 
{
	private Connection connection;
	
	public DbCartaIdentita() throws DbException
	{	
		try
		{
			connection=DbConnection.getConnection();
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore : connessione non riuscita&quot;);
		}
	}
	/**
	 * Metodo che permette la ricerca di una carta d'identità tramite il suo numero.
	 * @param cod è il numero della carta d'identità  del cittadino.
	 * @return l'oggetto di tipo CartaIdentità  associata al numero passato come parametro
	 * @throws DbException
	 */
	public CartaIdentita ricercaCartaIdentitaByNumero (String cod) throws DbException
	{	
		CartaIdentita res = null;
		ResultSet rs = null;
		PreparedStatement stmt = null;
		boolean e;
		try
		{
			stmt = connection.prepareStatement(&quot;SELECT * FROM cartaidentita WHERE numero = ?&quot;);
			stmt.setString(1, cod);
			rs = stmt.executeQuery();
		if(rs.next()==true)
			{
				String num = rs.getString(&quot;numero&quot;);
				int citt = rs.getInt(&quot;cittadino&quot;);
				String cittadinanza = rs.getString(&quot;cittadinanza&quot;);
				String residenza =rs.getString(&quot;residenza&quot;);
				String via = rs.getString(&quot;via&quot;);
				int numciv = rs.getInt(&quot;numeroCivico&quot;);
				String statoCivile = rs.getString(&quot;statoCivile&quot;);
				String professione = rs.getString(&quot;professione&quot;);
				double statura = rs.getDouble(&quot;statura&quot;);
				String capelli = rs.getString(&quot;capelli&quot;);
				String occhi = rs.getString(&quot;occhi&quot;);
				String segniParticolari = rs.getString(&quot;segniParticolari&quot;);
				java.util.Date dataRilascio = rs.getDate(&quot;dataRilascio&quot;);
				java.util.Date dataScadenza = rs.getDate(&quot;dataScadenza&quot;);
				int esp = rs.getInt(&quot;validaEspatrio&quot;);
				if(esp == 1)
					e=true;
				else 
					e=false;
				res = new CartaIdentita(num,citt,cittadinanza,residenza,via,numciv,statoCivile,professione,statura,capelli,occhi,segniParticolari,dataRilascio,dataScadenza,e);
				}
			return res;
		}
		catch (SQLException exc)
		{
			throw new DbException(&quot;Errore ricerca carta d'identitÃ  tramite il suo numero&quot;);
		}
		finally
		{
			try 
			{
				if(rs!=null)
					rs.close();
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e1) 
			{
				throw new DbException(&quot;Errore ricerca carta d'identitÃ  tramite il suo numero&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la cancellazione di una carta d'identità . (aggiornamento del db)
	 * @param cod è¨ il codice della carta d'identità  che si intende cancellare
	 * @return true se l'operazione è andata a buon fine
	 * @throws DbException
	 */
	public boolean cancellaCartaIdentita (String cod) throws DbException
	{	
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;DELETE FROM cartaidentita WHERE numero = ?&quot;);
			stmt.setString(1, cod);
			int ret = stmt.executeUpdate();
			return (ret == 1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore cancellazione carta identitÃ &quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore cancellazione carta identitÃ &quot;);
			}
		}
	}

	/**
	 * Metodo che permette la registrazione di una nuova carta d'identità all'interno del database
	 * @param c è l'oggetto di tipo carta d'identità
	 * @return true se l'operazione è andata a buon fine
	 * @throws DbException
	 */
	public boolean registraCartaIdentita (CartaIdentita c) throws DbException
	{	
		int esp;
		String num = c.getNumero();
		int citt = c.id();
		String cittadinanza = c.getCittadinanza();
		String residenza = c.getResidenza();
		String via = c.getVia();
		int numCiv = c.getNumCivico();
		String statoCiv = c.getStatoCivile();
		String professione = c.getProfessione();
		double statura = c.getStatura();
		String capelli = c.getCapelli();
		String occhi = c.getOcchi();
		String segniParticolari = c.getSegniParticolari();
		java.util.Date dataRilascio = c.getDataRilascio();
		java.util.Date dataScadenza = c.getDataScadenza();
		if(c.isValidaEspatrio())
			esp = 1;
		else 
			esp = 0;
		
		PreparedStatement stmt = null;
		
		try
		{
			stmt = connection.prepareStatement(&quot;INSERT INTO cartaidentita VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)&quot;);
			stmt.setString(1,num);
			stmt.setInt(2, citt);
			stmt.setString(3,cittadinanza);
			stmt.setString(4, residenza);
			stmt.setString(5, via);
			stmt.setInt(6, numCiv);
			stmt.setString(7, statoCiv);
			stmt.setString(8, professione);
			stmt.setDouble(9, statura);
			stmt.setString(10, capelli);
			stmt.setString(11,occhi);
			stmt.setString(12, segniParticolari);
			stmt.setDate(13, new java.sql.Date(dataRilascio.getYear()-1900,dataRilascio.getMonth()-1,dataRilascio.getDate()));
			stmt.setDate(14, new java.sql.Date(dataScadenza.getYear()-1900,dataScadenza.getMonth()-1,dataScadenza.getDate()));
			stmt.setInt(15, esp);
			
			return (stmt.executeUpdate() == 1);
		}
		catch (SQLException exc)
		{
			throw new DbException(&quot;Errore inserimento carta d'identità&quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e1) 
			{
				throw new DbException(&quot;Errore ricerca carta d'identitÃ  tramite il suo numero&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la modifica della via in una specifica carta d'identità . (aggiornamento del db)
	 * @param cod è il numero della carta d'identità  
	 * @param v è la nuova via da registrare nella carta d'identità 
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean modificaViaCartaIdentita (String cod, String v) throws DbException
	{
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cartaidentita SET via = ? WHERE numero = ?&quot;);
			stmt.setString(1, v);
			stmt.setString(2, cod);
			int ret = stmt.executeUpdate();
			return (ret == 1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica via carta d'identitÃ &quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore modifica via carta d'identitÃ &quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la modifica del numero civico in una specifica carta d'identità . (aggiornamento del db)
	 * @param cod è il numero della carta d'identità
	 * @param nc è il nuovo numero civico
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean modificaNumeroCivicoCartaIdentita (String cod,int nc) throws DbException
	{
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cartaidentita SET numeroCivico = ? WHERE numero = ?&quot;);
			stmt.setInt(1, nc);
			stmt.setString(2, cod);
			int ret = stmt.executeUpdate();
			return (ret == 1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica numero civico carta d'identitÃ &quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore modifica numero civico carta d'identitÃ &quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la modifica della residenza (via e numero civio) in una specifica carta d'identità . (aggiornamento del db) 
	 * @param via è la nuova via da registrare nella carta d'identità 
	 * @param nc è il numero civico da registrare nella carta d'identità
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean modificaResidenzaCartaIdentita (String cod, String via, int nc) throws DbException
	{
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cartaidentita SET via = ?, numeroCivico = ? WHERE numero = ?&quot;);
			stmt.setString(1, via);
			stmt.setInt(2, nc);
			stmt.setString(3, cod);
			int ret = stmt.executeUpdate();
			return (ret == 1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica residenza carta d'identità &quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore modifica residenza carta d'identità &quot;);
			}
		}
	}

	/**
	 * Metodo che permette la modifica della data di rilascio di una specifica carta d'identità . (aggiornamento del db)
	 * @param cod è il numero della carta d'identità 
	 * @param d è la nuova data di rilascio della carta d'identità 
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean modificaDataRilascioCartaIdentita (String cod, java.util.Date d) throws DbException
	{
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cartaidentita SET dataRilascio = ? WHERE numero = ?&quot;);
			stmt.setString(2, cod);
			stmt.setDate(1,new java.sql.Date(d.getYear()-1900,d.getMonth()-1,d.getDate()));
			int ret = stmt.executeUpdate();
			return (ret == 1);
		}
		catch(SQLException exc)
		{
			throw new DbException (&quot;Errore modifica data rilascio carta d'identitÃ &quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException (&quot;Errore modifica data rilascio carta d'identitÃ &quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la modifica della data di scadenza per una specifica carta d'identità . (aggiornamento del db)
	 * @param cod è il numero della carta d'identità 
	 * @param d è la nuova data di scadenza
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	
	public boolean modificaDataScadenzaCartaIdentita (String cod, java.util.Date d) throws DbException
	{
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cartaidentita SET dataScadenza = ? WHERE numero = ?&quot;);
			stmt.setString(2, cod);
			stmt.setDate(1,new java.sql.Date(d.getYear()-1900,d.getMonth()-1,d.getDate()));
			int ret = stmt.executeUpdate();
			return (ret == 1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica data scadenza carta d'identitÃ &quot;); 
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore modifica data scadenza carta d'identitÃ &quot;); 
			}
		}	
	}
	
	/**
	 * Metodo che permette la modifica della validità per l'espatrio di una specifica carta d'identità . (aggiornamento del db)
	 * @param cod è il numero della carta d'identità 
	 * @param esp è il valore booleano che indica la validità per l'espatrio per la specifica carta d'identità 
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean modificaValidaEspatrio (String cod, boolean esp) throws DbException
	{
		PreparedStatement stmt = null;
		int e;
		if (esp==true)
			e=1;
		else
			e=0;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cartaidentita SET validaEspatrio = ? WHERE numero = ?&quot;);
			stmt.setString(2, cod);
			stmt.setInt(1, e);
			int ret = stmt.executeUpdate();
			return (ret == 1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica validitÃ  espatrio carta d'identitÃ &quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e1) 
			{
				throw new DbException(&quot;Errore modifica validitÃ  espatrio carta d'identitÃ &quot;);
			}
		}
	}	
/**
* Metodo che permette la ricerca di una carta d'identità a partire dall'id del proprietario
* @param idC è l'id del cittadino
* @return l'oggetto di tipo CartaIdentita dello specifico cittadino.
* @throws DbException
*/
	public CartaIdentita ricercaCartaIdentitaByProprietario (int idC) throws DbException
	{	
		CartaIdentita res = null;
		ResultSet rs = null;
		PreparedStatement stmt = null;
		boolean e;
		try
		{
			stmt = connection.prepareStatement(&quot;SELECT * FROM cartaidentita WHERE cittadino = ?&quot;);
			stmt.setInt(1, idC);
			rs = stmt.executeQuery();
		if(rs.next()==true)
			{
				String num = rs.getString(&quot;numero&quot;);
				int citt = rs.getInt(&quot;cittadino&quot;);
				String cittadinanza = rs.getString(&quot;cittadinanza&quot;);
				String residenza =rs.getString(&quot;residenza&quot;);
				String via = rs.getString(&quot;via&quot;);
				int numciv = rs.getInt(&quot;numeroCivico&quot;);
				String statoCivile = rs.getString(&quot;statoCivile&quot;);
				String professione = rs.getString(&quot;professione&quot;);
				double statura = rs.getDouble(&quot;statura&quot;);
				String capelli = rs.getString(&quot;capelli&quot;);
				String occhi = rs.getString(&quot;occhi&quot;);
				String segniParticolari = rs.getString(&quot;segniParticolari&quot;);
				java.util.Date dataRilascio = rs.getDate(&quot;dataRilascio&quot;);
				java.util.Date dataScadenza = rs.getDate(&quot;dataScadenza&quot;);
				int esp = rs.getInt(&quot;validaEspatrio&quot;);
				if(esp == 1)
					e=true;
				else 
					e=false;
				res = new CartaIdentita(num,citt,cittadinanza,residenza,via,numciv,statoCivile,professione,statura,capelli,occhi,segniParticolari,dataRilascio,dataScadenza,e);
				}
			return res;
		}
		catch (SQLException exc)
		{
			throw new DbException(&quot;Errore ricerca carta d'identitÃ  tramite id del cittadino&quot;);
		}
		finally
		{
			try 
			{
				if(rs!=null)
					rs.close();
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e1) 
			{
				throw new DbException(&quot;Errore ricerca carta d'identitÃ  tramite id del cittadino&quot;);
			}
		}
	}

}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC154</id>
      <content>package DB;
import java.sql.*;
import java.util.*;

import Bean.Cittadino;

/** 
* Classe che si occupa di gestire le connessioni con il database
* e di schermare le servet con il DBMS.
* 
* @author Michelangelo Cianciulli
*/

public class DbCittadino 
{
	private Connection connection;
	
	public DbCittadino() throws DbException
	{
		try
		{
			connection=DbConnection.getConnection();
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore : connessione non riuscita&quot;);
		}
	}
	
	/**
	 * Metodo che permette di registrare un nuovo cittadino. (aggiornamento del db)
	 * @param citt è l'istanza di cittadino
	 * @return l'id del cittadino inserito.
	 * @throws DbException
	 */
	public int registraCittadino(Cittadino citt) throws DbException
	{
		PreparedStatement stmt = null;
		int a;
		String login=citt.getLogin();
		String cognome=citt.getCognome();
		String nome=citt.getNome();
		java.util.Date d=citt.getDataNascita();
		String luogoN = citt.getLuogoNascita();
		String codF=citt.getCodiceFiscale();
		String email=citt.getEmail();
		boolean adv=citt.isAdvertise();
		int nuclF=citt.getNucleoFamiliare();
		if(adv==true)
			a=1;
		else a=0;
		try
		{
			
				stmt = connection.prepareStatement(&quot;INSERT INTO cittadino VALUES (?,?,?,?,?,?,?,?,?,?)&quot;);
				stmt.setInt(1, 0);
				stmt.setString(2, codF);
				stmt.setString(3, cognome);
				stmt.setString(4, nome);
				stmt.setDate(5, new java.sql.Date(d.getYear()-1900,d.getMonth()-1,d.getDate()));
				stmt.setString(6, luogoN);
				stmt.setString(7, email);
				stmt.setInt(8, a);
				if(nuclF!=0)
					stmt.setInt(9, nuclF);
				else
					stmt.setNull(9, java.sql.Types.NULL);
				stmt.setString(10, login);
				stmt.executeUpdate();
				return maxID();
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore inserimento nuovo cittadino&quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore inserimento nuovo cittadino&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la modifica del nome di uno specifico cittadino. (aggiornamento del db)
	 * @param idCitt è l'identificativo del cittadino
	 * @param newname il nuovo nome da assegnare al cittadino
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean modificaNomeCittadino (int idCitt,String newname) throws DbException
	{	
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cittadino SET nome = ? WHERE idCittadino = ?&quot;);
			stmt.setInt(2, idCitt);
			stmt.setString(1, newname);
			return (stmt.executeUpdate()==1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica nome cittadino&quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore modifica nome cittadino&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la modifica del cognome di uno specifico cittadino. (aggiornamento del db)
	 * @param idCitt è l'identificativo del cittadino
	 * @param newsurname è il nuovo cognome da assegnare al cittadino
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean modificaCognomeCittadino(int idCitt,String newsurname) throws DbException
	{ 
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cittadino SET cognome = ? WHERE idCittadino = ?&quot;);
			stmt.setInt(2, idCitt);
			stmt.setString(1, newsurname);
			return (stmt.executeUpdate()==1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica cognome cittadino&quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore modifica cognome cittadino&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la modifica del codice fiscale di uno specifico cittadino. (aggiornamento del db)
	 * @param idCitt è l'identificativo del cittadino
	 * @param newcf è il nuovo codice fiscale da assegnare al cittadino
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean modificaCodiceFiscaleCittadino(int idCitt,String newcf) throws DbException
	{
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cittadino SET codicefiscale = ? WHERE idCittadino = ?&quot;);
			stmt.setInt(2, idCitt);
			stmt.setString(1, newcf);
			return (stmt.executeUpdate()==1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica codice fiscale cittadino&quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore modifica codice fiscale cittadino&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la modifica dell'indirizzo e-mail di uno specifico cittadino. (aggiornamento del db)
	 * @param idCitt è l'identificativo del cittadino
	 * @param newmail è la nuova mail da assegnare al cittadino
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean modificaEmailCittadino(int idCitt,String newmail)throws DbException
	{		
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cittadino SET eMail = ? WHERE idCittadino = ?&quot;);
			stmt.setInt(2, idCitt);
			stmt.setString(1, newmail);
			return (stmt.executeUpdate()==1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica mail cittadino&quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore modifica mail cittadino&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la modifica del campo advertise di uno specifico cittadino. (aggiornamento del db)
	 * @param idCitt è l'identificativo del cittadino
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean modificaAdvertise(int idCitt) throws DbException
	{
		PreparedStatement stmt = null;
		ResultSet rs = null;
		int ret;
		try
		{
			stmt = connection.prepareStatement(&quot;SELECT advertise FROM cittadino WHERE idCittadino = ?&quot;);
			Statement statement = connection.createStatement();
			stmt.setInt(1, idCitt);
			rs = stmt.executeQuery();
			rs.next();
			int adv = rs.getInt(&quot;advertise&quot;);
			if (adv == 0) 
				ret = statement.executeUpdate(&quot;UPDATE cittadino SET advertise = 1 WHERE idCittadino = &quot;+idCitt);
			else	
				ret = statement.executeUpdate(&quot;UPDATE cittadino SET advertise = 0 WHERE idCittadino =&quot;+idCitt);
		
			return (ret == 1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica advertise cittadino&quot;);
		}
		finally
		{
			try 
			{
				if(rs!=null)
					rs.close();
				if(stmt!=null)
					stmt.close();
			}
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore modifica advertise cittadino&quot;);
			}	
		}
	}
	
	/**
	 * Metodo che permette la cancellazione di un cittadino. (aggiornamento del db)
	 * @param idCitt è l'identificativo del cittadino
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean cancellaCittadino(int idCitt) throws DbException
	{	
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;DELETE FROM cittadino WHERE idCittadino = ?&quot;);
			stmt.setInt(1, idCitt);
			return (stmt.executeUpdate()==1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore cancellazione cittadino&quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore cancellazione cittadino&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la ricerca di un cittadino tramite il suo id.
	 * @param idCitt è l'identificativo del cittadino
	 * @return oggetto di tipo cittadino con id uguale a quello passato come parametro
	 * @throws DbException
	 */
	
	public Cittadino getCittadinoByCodice(int idCitt) throws DbException
	{
		Cittadino res = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try
		{
			stmt = connection.prepareStatement(&quot;SELECT * FROM cittadino WHERE idCittadino = ?&quot;);
			stmt.setInt(1, idCitt);
			rs = stmt.executeQuery();
			if(rs.next() == true)
				{
				boolean adv;
				int idCittadino = rs.getInt(&quot;idCittadino&quot;);
				String codiceFiscale = rs.getString(&quot;codiceFiscale&quot;);
				String cognome = rs.getString(&quot;cognome&quot;);
				String nome = rs.getString(&quot;nome&quot;);
				java.util.Date dataNascita = rs.getDate(&quot;dataNascita&quot;);
				String luogoN = rs.getString(&quot;luogoNascita&quot;);
				String eMail = rs.getString(&quot;eMail&quot;);
				int advertise = rs.getInt(&quot;advertise&quot;);
				int nucleoFamiliare = rs.getInt(&quot;nucleoFamiliare&quot;);
				String login = rs.getString(&quot;login&quot;);
				if(advertise == 1)
					adv=true;
				else 
					adv=false;
				res = new Cittadino(idCittadino,codiceFiscale,cognome,nome,dataNascita,luogoN,eMail,adv,nucleoFamiliare,login);
				}
			return res;
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore ricerca cittadino by codice&quot;);
		}
		finally
		{
			try 
			{
				if(rs!=null)
					rs.close();
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore ricerca cittadino by codice&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la ricerca di un insieme di cittadini in base al loro nome e cognome.
	 * @param name parametro su cui effettuare la ricerca
	 * @param surname parametro su cui effettuare la ricerca
	 * @return una collection di cittadini con il nome e il cognome passato come parametro
	 * @throws DbException
	 */
	public Collection&lt;Cittadino&gt; getCittadinoByName(String name,String surname) throws DbException
	{
		
		Collection&lt;Cittadino&gt; res = new ArrayList&lt;Cittadino&gt;();
		PreparedStatement stmt = null;
		ResultSet rs = null;
		boolean adv;
		try
		{
			stmt = connection.prepareStatement(&quot;SELECT * FROM cittadino WHERE nome = ? AND cognome = ?&quot;);
			stmt.setString(1, name);
			stmt.setString(2, surname);
			rs = stmt.executeQuery();
			while(rs.next())
			{
				int idCittadino = rs.getInt(&quot;idCittadino&quot;);
				String codiceFiscale = rs.getString(&quot;codiceFiscale&quot;);
				String cognome = rs.getString(&quot;cognome&quot;);
				String nome = rs.getString(&quot;nome&quot;);
				java.util.Date dataNascita = rs.getDate(&quot;dataNascita&quot;);
				String luogoN = rs.getString(&quot;luogoNascita&quot;);
				String eMail = rs.getString(&quot;eMail&quot;);
				int advertise = rs.getInt(&quot;advertise&quot;);
				int nucleoFamiliare = rs.getInt(&quot;nucleoFamiliare&quot;);
				String login = rs.getString(&quot;login&quot;);
				if(advertise == 1)
					adv=true;
				else adv=false;
					res.add(new Cittadino(idCittadino,codiceFiscale,cognome,nome,dataNascita,luogoN,eMail,adv,nucleoFamiliare,login));
			}
				return res;
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore ricerca cittadini tramite nome e cognome&quot;);
		}
		finally
		{
			try 
			{
				if(rs!=null)
					rs.close();
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore ricerca cittadini tramite nome e cognome&quot;);
			}
		}	
	}
	
	/**
	 * Metodo che permette la modifica della login per uno specifico cittadino. (aggiornamento del db)
	 * @param idC è l'id del cittadino
	 * @param newLogin è la nuova login del cittadino
	 * @return true se l'operazione è andata a buon fine
	 */
	public boolean modificaLogin(int idC, String newLogin) throws DbException
	{
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cittadino SET login = ? WHERE idCittadino = ?&quot;);
			stmt.setString(1, newLogin);
			stmt.setInt(2, idC);
			//rs = stmt.executeQuery();
			/*if(rs.next())
				{
				String l = rs.getString(&quot;login&quot;);
				stmt = connection.prepareStatement(&quot;UPDATE accesso SET login = ? WHERE login = ?&quot;);
				stmt.setString(1, newLogin);
				stmt.setString(2, l);*/
				return (stmt.executeUpdate()==1);
				//}
		//return false;
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica login&quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
				if(rs!=null)
					rs.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore modifica login&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la ricerca di un cittadino tramite la sua login.
	 * @param log è la login in base alla quale si vuole effettuare la ricerca
	 * @return l'oggetto di tipo cittadino
	 * @throws DbException
	 */
	public Cittadino getCittadinoByLogin (String log) throws DbException
	{
		Cittadino res = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try
		{
			stmt = connection.prepareStatement(&quot;SELECT * FROM cittadino WHERE login = ?&quot;);
			stmt.setString(1, log);
			rs = stmt.executeQuery();
			if(rs.next() == true)
				{
				boolean adv;
				int idCittadino = rs.getInt(&quot;idCittadino&quot;);
				String codiceFiscale = rs.getString(&quot;codiceFiscale&quot;);
				String cognome = rs.getString(&quot;cognome&quot;);
				String nome = rs.getString(&quot;nome&quot;);
				java.util.Date dataNascita = rs.getDate(&quot;dataNascita&quot;);
				String luogoN = rs.getString(&quot;luogoNascita&quot;);
				String eMail = rs.getString(&quot;eMail&quot;);
				int advertise = rs.getInt(&quot;advertise&quot;);
				int nucleoFamiliare = rs.getInt(&quot;nucleoFamiliare&quot;);
				String login = rs.getString(&quot;login&quot;);
				if(advertise == 1)
					adv=true;
				else 
					adv=false;
				res = new Cittadino(idCittadino,codiceFiscale,cognome,nome,dataNascita,luogoN,eMail,adv,nucleoFamiliare,login);
				}
			return res;
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore ricerca cittadino by login&quot;);
		}
		finally
		{
			try 
			{	
				if(rs!=null)
					rs.close();
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore ricerca cittadino by login&quot;);
			}
		}
	}
	
	/**
	 * Metodo privato che ritorna l'id dell'ultimo cittadino inserito.
	 * @return l'id più alto della tabella cittadino
	 * @throws DbException
	 */
	private int maxID () throws DbException
	{
		Statement stmt = null;
		ResultSet rs = null;
		try
		{
			stmt = connection.createStatement();
			rs = stmt.executeQuery(&quot;SELECT max(idCittadino) as m FROM cittadino;&quot;);
			if(rs.next())
				return rs.getInt(&quot;m&quot;);
			throw new DbException(&quot;Errore esecuzione maxID&quot;);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore esecuzione maxID&quot;);
		}
		finally
		{
			try 
			{
				if(rs!=null)
					rs.close();
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore esecuzione maxID&quot;);
			}	
		}
	}
	
	/**
	 * Metodo che permette di conoscere l'id del cittadino a partire dai suoi dati anagrafici (codice fiscale,cognome,nome)
	 * @param cf è il codice fiscale parametro per la ricerca
	 * @param surname è il cognome parametro per la ricerca
	 * @param name è il nome parametro per la ricerca
	 * @return l'id del cittadino se ok, -1 se la ricerca non ha successo
	 */
	public int findIdCittadino (String cf,String surname,String name)
	{	
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try
		{
			stmt = connection.prepareStatement(&quot;SELECT idCittadino AS id FROM cittadino WHERE codiceFiscale = ? AND nome = ? AND cognome = ?&quot;);
			stmt.setString(1, cf);
			stmt.setString(2, name);
			stmt.setString(3, surname);
			rs = stmt.executeQuery();
			if(rs.next())
				return rs.getInt(&quot;id&quot;);
			return -1;
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore ricerca id cittadino tramite cf/nome/cognome&quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
				if(rs!=null)
					rs.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore ricerca id cittadino tramite cf/nome/cognome&quot;);
			}
		}
	}
	
	/**
	 * Metodo che permette la ricerca del codice fiscale del cittadino a partire dal suo ID
	 * @param id è l'id del cittadino
	 * @return il codice fiscale del cittadino
	 */
	public String findCodiceFiscale (int id)
	{
		PreparedStatement stmt = null;
		ResultSet rs = null;
		String res = null;
		try
		{
			stmt = connection.prepareStatement(&quot;SELECT codiceFiscale as cf FROM cittadino WHERE idCittadino = ?&quot;);
			stmt.setInt(1, id);
			rs = stmt.executeQuery();
			if(rs.next())
				res = rs.getString(&quot;cf&quot;);
			return res;
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore ricerca codice fiscale tramite ID&quot;);
		}
		finally
		{
			try 
			{
				if(rs!=null)
					rs.close();
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore ricerca codice fiscale tramite ID&quot;);
			}	
		}
	}
	
	/**
	 * Metodo che modifica il nucleo familiare del cittadino dato il suo id
	 * @param idCitt è l'id del cittadino
	 * @param newnucleo è il nuovo nucleo familiare del cittadino
	 * @return true se l'operazione è eseguita con successo
	 * @throws DbException
	 */
	public boolean modificaNucleoFamiliareCittadino(int idCitt,int newnucleo) throws DbException
	{	
		PreparedStatement stmt = null;
		try
		{
			stmt = connection.prepareStatement(&quot;UPDATE cittadino SET nucleoFamiliare = ? WHERE idCittadino = ?&quot;);
			stmt.setInt(2, idCitt);
			stmt.setInt(1, newnucleo);
			int ret = stmt.executeUpdate();
			return (ret == 1);
		}
		catch(SQLException exc)
		{
			throw new DbException(&quot;Errore modifica nucleo familiare cittadino&quot;);
		}
		finally
		{
			try 
			{
				if(stmt!=null)
					stmt.close();
			} 
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore modifica nucleo familiare cittadino&quot;);
			}
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC155</id>
      <content>package DB;
import Bean.*;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
* La classe DbComune si occupa di gestire le connessioni al db
* @author Antonio Leone
* @version 1.0
*/

public class DbComune {
	
private Connection connection;
	
	public DbComune() throws DbException
	{
		try
		{
			connection=DbConnection.getConnection();
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: Connessione non riuscita&quot;);
		}
	}
	
	/**
	 * Metodo che inserisce un comune all'interno del db
	 * @param c oggetto di tipo Comune
	 * @return True se è stato effettuato un inserimento nel db, False altrimenti
	 * @throws DbException
	 */
	
	public boolean inserisciComune(Comune c)throws DbException
	{
		int ret=0;
		PreparedStatement statement=null;
		String nome=c.getNome();
		String indirizzo=c.getIndirizzoId();
		try
		{
			statement=connection.prepareStatement(&quot;INSERT INTO comune VALUES (?, ?)&quot;);
			statement.setString(1, nome);
			statement.setString(2, indirizzo);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: inserimento comune non riuscito&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: inserimento comune non riuscito&quot;);
			}
		}
	}
	
	/**
	 * Metodo che elimina un comune dal db
	 * @param nome che identifica il comune
	 * @return True se è stato effettuato una cancellazione nel db, False altrimenti
	 * @throws DbException
	 */
	
	public boolean eliminaComune(String nome) throws DbException
	{	
		PreparedStatement statement=null;
		int ret=0;
		try
		{
			statement=connection.prepareStatement(&quot;DELETE FROM comune WHERE nome = ?&quot;);
			statement.setString(1,nome);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: cancellazione comune non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: cancellazione comune non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce un comune
	 * @param nome la stringa che rappresenta il nome del comune
	 * @return Restituisce un oggetto di tipo Comune
	 * @throws DbException
	 */
	
	public Comune getComuneByName(String nome)throws DbException
	{
		PreparedStatement statement=null;
		ResultSet rs=null;
		Comune ret=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT* FROM comune WHERE nome = ?&quot;);
			statement.setString(1,nome);
			rs= statement.executeQuery();
			if(!rs.next())
				return ret;
			String nomeC=rs.getString(&quot;nome&quot;);
			String indirizzo=rs.getString(&quot;indirizzoIp&quot;);
			ret=new Comune(nomeC,indirizzo);
			return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca del comune tramite il nome non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca del comune tramite il nome non riuscita&quot;);
			}
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC156</id>
      <content>package DB;
import Bean.*;
import com.mchange.v2.c3p0.ComboPooledDataSource;
import java.util.*;
import java.beans.PropertyVetoException;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.*;

/** 
* Questa classe fornisce un pool di connesione
* @author Antonio Leone
*/

public class DbConnection {
	
	private static Properties dbProperties;
	private static ComboPooledDataSource cpds=null;
	
	/**
	 * Questa porzione di codice crea un pool di connessione e definisce i db properties
	 */
	static 
	{
try 
{
				DbConnection.loadDbProperties();
				DbConnection.createPool();
			} 
catch (IOException e) 
{
				throw new DbException(&quot;Errore nella definizione dei DB properties&quot;);
			}
			catch (SQLException e) 
			{
				throw new DbException(&quot;Errore nella creazione del Poll di Connessioni&quot;);
			} 
			catch (PropertyVetoException e) 
			{
				throw new DbException(&quot;Errore nella creazione del Poll di Connessioni&quot;);
			} 
}
	
	private static void createPool() throws SQLException, PropertyVetoException
	{
	cpds = new ComboPooledDataSource(); 
		cpds.setJdbcUrl( DbConnection.dbProperties.getProperty(&quot;url&quot;)); 
		cpds.setDriverClass(DbConnection.dbProperties.getProperty(&quot;driver&quot;)); 
		cpds.setUser(DbConnection.dbProperties.getProperty(&quot;username&quot;)); 
		cpds.setPassword(DbConnection.dbProperties.getProperty(&quot;password&quot;));
	}
	
	/**
	 * Ritorna una connessione al db, se non è già disponibile ne viene creata una nuova
	 * @return una connessione al db
	 * @throws SQLException 
	 */
	
	public static synchronized Connection getConnection() throws SQLException 
	{
		return cpds.getConnection();
	}
	
	/**
	 * Carica i db properties
	 * @throws IOException
	 */
	
	private static void loadDbProperties() throws IOException
	{
		 InputStream fileProperties = new FileInputStream(&quot;database.properties&quot;);
		 DbConnection.dbProperties = new Properties();
		 DbConnection.dbProperties.load(fileProperties); 	
	}
	
	/**
	 * Metodo che chiude il pool di connessione
	 */
	
	public void closePool()
	{
		cpds.close();
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC157</id>
      <content>package DB;
import Bean.*;
/**
* La classe DbException viene lanciata quando si verifica un eccezione legata al db
* @author Antonio Leone
* @version 1.0
*/
public class DbException extends RuntimeException {

	private static final long serialVersionUID = -6403170047487930045L;
	public DbException()
	{
	}
	public DbException(String message)
	{
		super(message);
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC158</id>
      <content>package DB;
import Bean.*;
import java.sql.*;
import java.util.ArrayList;
import java.util.Collection;

/**
* La classe DbImpiegato si occupa di gestire le connessioni al db
* @author Antonio Leone
* @version 1.0
*/

public class DbImpiegato {
	
	private Connection connection;
	
	public DbImpiegato() throws DbException
	{
		try
		{
			connection=DbConnection.getConnection();
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: connessione non riuscita&quot;);
		}
	}
	
	/**
	 * Metodo che inserisce un impiegato all'interno del db
	 * @param i Oggetto di tipo Impiegato
	 * @return True se è stato effettuato un inserimento nel db, False altrimenti
	 * @throws DbException
	 */
	
	public boolean inserisciImpiegato(Impiegato i)throws DbException
	{
		String matr=i.getMatricola();
		String nome=i.getNome();
		String cogn=i.getCognome();
		String email=i.getEmail();
		String login=i.getLogin();
		int ret=0;
		PreparedStatement statement=null;
		try
		{
			statement=connection.prepareStatement(&quot;INSERT INTO impiegato VALUES (? ,? ,?,?,?)&quot;);
			statement.setString(1, matr);
			statement.setString(2,nome);
			statement.setString(3,cogn);
			statement.setString(4, email);
			statement.setString(5, login);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: inserimento impiegato non riuscito&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: inserimento impiegato non riuscito&quot;);
			}
		}
	}
	
	/**
	 * Metodo che elimina un impiegato dal db
	 * @param matr la stringa che viene utilizzato come matricola
	 * @return True se è stato effettuato una cancellazione nel db, False altrimenti
	 * @throws DbException
	 */
	
	public boolean eliminaImpiegato(String matr) throws DbException
	{
		PreparedStatement statement=null;
		int ret=0;
		try
		{
			statement=connection.prepareStatement(&quot;DELETE FROM impiegato WHERE matricola =?&quot;);
			statement.setString(1,matr);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: cancellazione impiegato non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: cancellazione impiegato non riuscita&quot;);
			}
		}
	}
	
	/** Metodo che restituisce un insieme di impiegati
	 * @param nomeImp stringa che viene utilizzata come nome dell'impiegato
	 * @param cognImp stringa che viene utilizzata come cognome dell'impiegato
	 * @return Restituisce una Collection di Impiegati
	 * @throws DbException
	 */
	
	public Collection&lt;Impiegato&gt; getImpiegatoByName(String nomeImp,String cognImp) throws DbException
	{
		ArrayList&lt;Impiegato&gt; ret = new ArrayList&lt;Impiegato&gt;(); 
		PreparedStatement statement=null;
		ResultSet rs=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM impiegato WHERE nome =? and cognome =?&quot;);
			statement.setString(1,nomeImp);
			statement.setString(2,cognImp);
			rs= statement.executeQuery();
			while(rs.next())
			{
				String matr = rs.getString(&quot;matricola&quot;);
				String nome = rs.getString(&quot;nome&quot;);
				String cognome = rs.getString(&quot;cognome&quot;);
				String eMail = rs.getString(&quot;eMail&quot;);
				String login = rs.getString(&quot;login&quot;);
				ret.add(new Impiegato(nome,cognome,matr,eMail,login));
			}
			if(ret.isEmpty())
				return null;
			else
				return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca impiegato tramite nome e cognome non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca impiegato tramite nome e cognome non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce un impiegato
	 * @param matrImp stringa che viene utilizzato come matricola dell'impiegato
	 * @return Restituisce un oggetto di tipo Impiegato
	 * @throws DbException
	 */
	
	public Impiegato getImpiegatoByMatricola(String matrImp) throws DbException
	{
		PreparedStatement statement=null;
		ResultSet rs=null;
		Impiegato ret=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM impiegato WHERE matricola =?&quot;);
			statement.setString(1,matrImp);
			rs= statement.executeQuery();
			if(!rs.next())
				return ret;
			String matr = rs.getString(&quot;matricola&quot;);
			String nome = rs.getString(&quot;nome&quot;);
			String cognome = rs.getString(&quot;cognome&quot;);
			String eMail = rs.getString(&quot;eMail&quot;);
			String login = rs.getString(&quot;login&quot;);
			ret=new Impiegato(nome,cognome,matr,eMail,login);
			return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca impiegato tramite matricola non riuscita&quot;);
		}
		finally
		{	
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca impiegato tramite matricola non riuscita&quot;);
			}
		}	
	}
	
	/**
	 * Metodo che restituisce tutti gli impiegati memorizzati
	 * @return Restituisce una Collection di impiegati
	 * @throws DbException
	 */
	
	public Collection&lt;Impiegato&gt; getImpiegati() throws DbException
	{
		ArrayList&lt;Impiegato&gt; ret = new ArrayList&lt;Impiegato&gt;(); 
		Statement statement =null;
		ResultSet rs =null;
		try
		{
			statement=connection.createStatement();
			rs = statement.executeQuery(&quot;SELECT * FROM impiegato&quot;);
			while(rs.next())
			{
				String matr = rs.getString(&quot;matricola&quot;);
				String nome = rs.getString(&quot;nome&quot;);
				String cognome = rs.getString(&quot;cognome&quot;);
				String eMail = rs.getString(&quot;eMail&quot;);
				String login = rs.getString(&quot;login&quot;);
				ret.add(new Impiegato(nome,cognome,matr,eMail,login));
			}
			if(ret.isEmpty())
				return null;
			else
				return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca impiegati non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca impiegati non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce un impiegato
	 * @param log stringa che viene utilizzata come login dell'impiegato
	 * @return Restituisce un oggetto di tipo impiegato
	 * @throws DbException
	 */
	
	public Impiegato getImpiegatoByLogin(String log)throws DbException
	{
		PreparedStatement statement=null;
		ResultSet rs=null;
		Impiegato ret=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM impiegato WHERE login =?&quot;);
			statement.setString(1,log);
			rs= statement.executeQuery();
			if(!rs.next())
				return ret;
			String matr = rs.getString(&quot;matricola&quot;);
			String nome = rs.getString(&quot;nome&quot;);
			String cognome = rs.getString(&quot;cognome&quot;);
			String eMail = rs.getString(&quot;eMail&quot;);
			String login = rs.getString(&quot;login&quot;);
			ret=new Impiegato(nome,cognome,matr,eMail,login);
			return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca impiegato tramite login non riuscita&quot;);
		}
		finally
		{	
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca impiegato tramite login non riuscita&quot;);
			}
		}	
	}
	
	/**
	 * Metodo che modifica un impiegato
	 * @param matr la stringa che identifica l'impiegato
	 * @param a impiegato con i dati aggiornati
	 * @return True se è stato effettuato una modifica nel db, False altrimenti
	 */
	
	public boolean modificaImpiegato(String matr, Impiegato a)
	{
		String matricola=a.getMatricola();
		String nome=a.getNome();
		String cogn=a.getCognome();
		String email=a.getEmail();
		String login=a.getLogin();
		int ret=0;
		PreparedStatement statement=null;
		try
		{
			statement=connection.prepareStatement(&quot;UPDATE impiegato SET matricola = ?,nome = ?, cognome = ?, email = ?, login = ? WHERE matricola = ?&quot;);
			statement.setString(1, matricola);
			statement.setString(2,nome);
			statement.setString(3,cogn);
			statement.setString(4, email);
			statement.setString(5, login);
			statement.setString(6,matr);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: modifica impiegato non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: modifica impiegato non riuscita&quot;);
			}
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC159</id>
      <content>package DB;
import Bean.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;

/**
* La classe DbNucleoFamiliare si occupa di gestire le connessioni al db
* @author Antonio Leone
* @version 1.0
*/

public class DbNucleoFamiliare {
	
	private Connection connection;
	
	public DbNucleoFamiliare() throws DbException
	{
		try
		{
			connection=DbConnection.getConnection();
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: Connessione non riuscita&quot;);
		}
	}
	
	/**
	 * Metodo che inserisci un oggetto nucleoFamiliare nel db
	 * @param nf Oggetto di tipo nucleofamiliare
	 * @return Restituisce l'id del nucleo familiare inserito
	 * @throws DbException
	 */
	
	public int inserisciNucleoFamiliare(NucleoFamiliare nf)throws DbException
	{
		PreparedStatement statement=null;
		int idC=nf.getCapoFamiglia();
		String note=nf.getNote();
		int nc=nf.getNComponenti();
		try
		{
			statement=connection.prepareStatement(&quot;INSERT INTO nucleofamiliare VALUES (? ,? ,?,?)&quot;);
			statement.setInt(1,0);
			statement.setInt(2, idC);
			statement.setString(3, note);
			statement.setInt(4,nc);
			statement.executeUpdate();
			return lastId();
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: inserimento nucleo familiare non riuscito&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: inserimento nucleo familiare non riuscito&quot;);
			}
		}
	}
	
	/**
	 * Metodo che elimina un nucleoFamiliare dal db
	 * @param id l'intero che viene utilizzato come id del nucleoFamiliare
	 * @return True se è stato effettuato una cancellazione nel db, False altrimenti
	 * @throws DbException
	 */
	
	public boolean eliminaNucleoFamiliare(int id)throws DbException
	{
		PreparedStatement statement=null;
		int ret=0;
		try
		{
			statement=connection.prepareStatement(&quot;DELETE FROM nucleofamiliare WHERE idNucleoFamiliare =?&quot;);
			statement.setInt(1,id);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: cancellazione nucleo familiare non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: cancellazione nucleo familiare non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce i componeneti di uno stato di famiglia
	 * @param id intero che viene usato come id del nucleo familiare
	 * @return Restituisce una Collection di cittadini
	 * @throws DbException
	 */
	
	public Collection&lt;Cittadino&gt; getStatoFamiglia(int id)throws DbException
	{
		ArrayList&lt;Cittadino&gt; ret = new ArrayList&lt;Cittadino&gt;(); 
		PreparedStatement statement=null;
		ResultSet rs=null;
		NucleoFamiliare nf=getNucleoFamiliareById(id);
		if(nf==null)
			return null;
		int nc=nf.getNComponenti();
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM statofamiglia WHERE nucleoFamiliare = ?&quot;);
			statement.setInt(1,id);
			rs = statement.executeQuery();
			for(int i=0;i&lt;nc;i++)
			{
				rs.next();
				String cc=rs.getString(&quot;codiceFiscale&quot;);
				String cognome = rs.getString(&quot;cognome&quot;);
				String nome = rs.getString(&quot;nome&quot;);
				java.util.Date dataNascita = rs.getDate(&quot;dataNascita&quot;);
				String luogo=rs.getString(&quot;luogoNascita&quot;);
				int nucleoFamiliare = rs.getInt(&quot;nucleoFamiliare&quot;);
				ret.add(new Cittadino(nucleoFamiliare,cc,cognome,nome,dataNascita,luogo));
			}
			if(ret.isEmpty())
				return null;
			else
				return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca stato famiglia non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca stato famiglia non riuscita&quot;);
			}
		}
	}

	/**
	 * Metodo che permette di controllare lesistenza di un nucleo familiare
	 * @param id l'intero che viene utilizzato come id del nucleo familiare
	 * @return True se l'id è presente, False altrimenti
	 * @throws DbException 
	 */
	
	public boolean controllaIdFamiglia(int id)throws DbException
	{
			PreparedStatement statement=null;
			ResultSet rs=null;
			boolean ret=false;
			try
			{
				statement=connection.prepareStatement(&quot;SELECT * FROM nucleofamiliare WHERE idNucleoFamiliare = ?&quot;);
				statement.setInt(1,id);
				rs= statement.executeQuery();
				ret=rs.next();
				return(ret);
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: controllo nucleo familiare non riuscito&quot;);
			}
			finally
			{
				try
				{
					if(statement!=null)
						statement.close();
					if(rs!=null)
						rs.close();
				}
				catch(SQLException e)
				{
					throw new DbException(&quot;Errore: controllo nucleo familiare non riuscito&quot;);
				}
			}
	}
	
	/**
	 * Metodo che permette la ricerca di un nucleo familiare per conoscere le eventuali note
	 * @param id l'intero che viene utilizzato come id del nucleo familiare
	 * @return Restituisce le note del nucleo familiare
	 * @throws DbException
	 */
	
	public String noteFamiglia (int id)throws DbException
	{
		PreparedStatement statement =null;
		ResultSet rs=null;
		String ret=&quot;&quot;;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT note FROM nucleofamiliare WHERE idNucleoFamiliare = ?&quot;);
			statement.setInt(1,id);
			rs= statement.executeQuery();
			if(!rs.next())
				return null;
			ret=rs.getString(&quot;note&quot;);
			if(ret==null)
				return &quot;&quot;;
			else
				return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca note non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca note non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che modifica un capo famiglia
	 * @param idF l'intero che viene utilizzato come id della famiglia
	 * @param idC l'intero che viene utilizzato come id del capo famiglia
	 * @return True se la modifica ha avuto successo, altrimenti False
	 * @throws DbException
	 */
	
	public boolean setCapoFamiglia(int idF,int idC)throws DbException
	{
		PreparedStatement statement=null;
		int ret=0;
		try
		{
			statement=connection.prepareStatement(&quot;UPDATE nucleofamiliare SET capoFamiglia = ? WHERE idNucleoFamiliare = ?&quot;);
			statement.setInt(1,idC);
			statement.setInt(2,idF);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: modifica capo famiglia non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: modifica capo famiglia non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce un nucleo familiare
	 * @param id l'intero che contiene l'id del nucleo familiare
	 * @return Restituisce un oggetto di tipo NucleoFamiliare
	 * @throws DbException
	 */
	
	public NucleoFamiliare getNucleoFamiliareById(int id)throws DbException
	{
		PreparedStatement statement=null;
		ResultSet rs=null;
		NucleoFamiliare ret=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT* FROM nucleofamiliare WHERE idNucleoFamiliare = ?&quot;);
			statement.setInt(1,id);
			rs= statement.executeQuery();
			if(!rs.next())
				return ret;
			int idN=rs.getInt(&quot;idNucleoFamiliare&quot;);
			int idC=rs.getInt(&quot;capoFamiglia&quot;);
			String note=rs.getString(&quot;note&quot;);
			int nc=rs.getInt(&quot;nComponenti&quot;);
			ret=new NucleoFamiliare(idN,idC,note,nc);
			return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca nucleo familiare tramite id non riuscito&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca nucleo familiare tramite id non riuscito&quot;);
			}
		}
	}

	private int lastId()throws DbException
	{	
		int ret=0;
		Statement statement=null;
		ResultSet rs=null;
		try
		{
			statement=connection.createStatement();
			rs=statement.executeQuery(&quot;SELECT max(idNucleoFamiliare)AS max FROM nucleofamiliare&quot;);
			if(!rs.next())
				return ret;
			ret=rs.getInt(1);
			return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca id dell'ultimo nucleo familiare non riuscito&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca id dell'ultimo nucleo familiare non riuscito&quot;);
			}
		}
	}
	
	/**
	 * Metodo che modifica il numero di componenti del nucleo familiare
	 * @param idF l'intero che viene utilizzato come id della famiglia
	 * @param n l'intero che rappresenta il nuovo numero di componenti
	 * @return True se la modifica ha avuto successo, altrimenti False
	 * @throws DbException
	 */
	
	public boolean setnComponenti(int idF,int n)
	{
		PreparedStatement statement=null;
		int ret=0;
		try
		{
			statement=connection.prepareStatement(&quot;UPDATE nucleofamiliare SET nComponenti = ? WHERE idNucleoFamiliare = ?&quot;);
			statement.setInt(1,n);
			statement.setInt(2,idF);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: modifica numero componenti non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: modifica numero componenti non riuscita&quot;);
			}
		}
	}
	
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC160</id>
      <content>package DB;
import Bean.*;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;

/**
* La classe DbRichiesta si occupa di gestire le connessioni al db
* @author Antonio Leone
* @version 1.0
*/

public class DbRichiesta {
	
private Connection connection;
	
	public DbRichiesta() throws DbException
	{
		try
		{
			connection=DbConnection.getConnection();
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: Connessione non riuscita&quot;);
		}
	}
	
	/**
	 * Metodo che inserisce una richiesta all'interno del db
	 * @param ric oggetto di tipo Richiesta
	 * @return True se è stato effettuato un inserimento nel db, False altrimenti
	 * @throws DbException
	 */
	
	public boolean inserisciRichiesta(Richiesta ric)throws DbException
	{
		int ret=0;
		PreparedStatement statement=null;
		String tipo=ric.getTipo();
		String data=ric.getData();
		int richiedente=ric.getRichiedente();
		String stato=ric.getStato();
		String documento=ric.getDocumento();
		try
		{
			statement=connection.prepareStatement(&quot;INSERT INTO richiesta VALUES (?, ?, ?, ?, ?, ?)&quot;);
			statement.setInt(1,0);
			statement.setString(2, tipo);
			statement.setString(3,data);
			statement.setInt(4, richiedente);
			statement.setString(5, stato);
			statement.setString(6, documento);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: inserimento richiesta non riuscito&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: inserimento richiesta non riuscito&quot;);
			}
		}
	}
	
	/**
	 * Metodo che elimina una richiesta dal db
	 * @param id l'intero che viene usato come id della richiesta
	 * @return True se è stato effettuato una cancellazione nel db, False altrimenti
	 * @throws DbException
	 */
	
	public boolean eliminaRichiesta(int id) throws DbException
	{	
		PreparedStatement statement=null;
		int ret=0;
		try
		{
			statement=connection.prepareStatement(&quot;DELETE FROM richiesta WHERE idRichiesta =?&quot;);
			statement.setInt(1,id);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: cancellazione richiesta non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: cancellazione richiesta non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce una richiesta
	 * @param id l'intero che viene usato come id della richiesta
	 * @return Restituisce un oggetto di tipo Richiesta
	 * @throws DbException
	 */
	
	public Richiesta getRichiestaById(int id)throws DbException
	{
		PreparedStatement statement=null;
		ResultSet rs=null;
		Richiesta ret=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT* FROM richiesta WHERE idRichiesta = ?&quot;);
			statement.setInt(1,id);
			rs= statement.executeQuery();
			if(!rs.next())
				return ret;
			int idR=rs.getInt(&quot;idRichiesta&quot;);
			String tipo=rs.getString(&quot;tipo&quot;);
			String data=rs.getString(&quot;data&quot;);
			int richiedente=rs.getInt(&quot;richiedente&quot;);
			String stato=rs.getString(&quot;stato&quot;);
			String documento=rs.getString(&quot;documento&quot;);
			ret=new Richiesta(idR,tipo,data,richiedente,stato,documento);
			return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca tramite l'id della richiesta non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca tramite l'id della richiesta non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce un insieme di richieste
	 * @param idR l'intero che viene usato come id del richiedente
	 * @return Restituisce una Collection di Richieste
	 * @throws DbException
	 */
	
	public Collection&lt;Richiesta&gt; getRichiestaByRichiedente(int idR)throws DbException
	{
		ArrayList&lt;Richiesta&gt; ret = new ArrayList&lt;Richiesta&gt;(); 
		PreparedStatement statement=null;
		ResultSet rs=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM richiesta WHERE richiedente = ? ORDER BY data desc&quot;);
			statement.setInt(1,idR);
			rs= statement.executeQuery();
			while(rs.next())
			{
				int idRic=rs.getInt(&quot;idRichiesta&quot;);
				String tipo=rs.getString(&quot;tipo&quot;);
				String data=rs.getString(&quot;data&quot;);
				int richiedente=rs.getInt(&quot;richiedente&quot;);
				String statoR=rs.getString(&quot;stato&quot;);
				String documento=rs.getString(&quot;documento&quot;);
				ret.add(new Richiesta(idRic,tipo,data,richiedente,statoR,documento));
			}
			if(ret.isEmpty())
				return null;
			else
				return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca richieste tramite l'id del richiedente non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca richieste tramite l'id del richiedente non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce un insieme di richieste
	 * @param idR l'intero che viene usato come id del richiedente
	 * @param stato la stringa che viene usata come stato della richiesta
	 * @return Restituisce una Collection di tipo Richiesta
	 * @throws DbException
	 */
	
	public Collection&lt;Richiesta&gt; getRichiestaByStato(int idR, String stato) throws DbException
	{
		ArrayList&lt;Richiesta&gt; ret = new ArrayList&lt;Richiesta&gt;(); 
		PreparedStatement statement=null;
		ResultSet rs=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM richiesta WHERE richiedente =? and stato =? ORDER BY data desc&quot;);
			statement.setInt(1,idR);
			statement.setString(2,stato);
			rs= statement.executeQuery();
			while(rs.next())
			{
				int idRic=rs.getInt(&quot;idRichiesta&quot;);
				String tipo=rs.getString(&quot;tipo&quot;);
				String data=rs.getString(&quot;data&quot;);
				int richiedente=rs.getInt(&quot;richiedente&quot;);
				String statoR=rs.getString(&quot;stato&quot;);
				String documento=rs.getString(&quot;documento&quot;);
				ret.add(new Richiesta(idRic,tipo,data,richiedente,statoR,documento));
			}
			if(ret.isEmpty())
				return null;
			else
				return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca richieste tramite l'id del richiedente e stato richiesta non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca tramite l'id del richiedente e stato richiesta non riuscita &quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce un insieme di richieste
	 * @param idR l'intero che viene usato come id del richiedente
	 * @param tipo la stringa che viene usata come tipologia della richiesta
	 * @return Restituisce una Collection di tipo Richiesta
	 * @throws DbException
	 */
	
	public Collection&lt;Richiesta&gt; getRichiestaByTipo(int idR, String tipo) throws DbException
	{
		ArrayList&lt;Richiesta&gt; ret = new ArrayList&lt;Richiesta&gt;(); 
		PreparedStatement statement=null;
		ResultSet rs=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM richiesta WHERE richiedente =? and tipo =? ORDER BY data desc&quot;);
			statement.setInt(1,idR);
			statement.setString(2,tipo);
			rs= statement.executeQuery();
			while(rs.next())
			{
				int idRic=rs.getInt(&quot;idRichiesta&quot;);
				String tipoR=rs.getString(&quot;tipo&quot;);
				String data=rs.getString(&quot;data&quot;);
				int richiedente=rs.getInt(&quot;richiedente&quot;);
				String statoR=rs.getString(&quot;stato&quot;);
				String documento=rs.getString(&quot;documento&quot;);
				ret.add(new Richiesta(idRic,tipoR,data,richiedente,statoR,documento));
			}
			if(ret.isEmpty())
				return null;
			else
				return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca richieste tramite l'id del richiedente e tipo richiesta non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca tramite l'id del richiedente e tipo richiesta non riuscita &quot;);
			}
		}
	}
		
	/**
	 * Metodo che modifica lo stato di una richiesta
	 * @param idR l'intero che viene utilizzato come id della richiesta
	 * @param stato la stringa che viene utilizzato come stato della richiesta
	 * @return True se la modifica ha avuto successo, altrimenti False
	 * @throws SQLException
	 */
	
	public boolean setStatoRichiesta(int idR, String stato)throws DbException
	{
		PreparedStatement statement=null;
		int ret=0;
		try
		{
			statement=connection.prepareStatement(&quot;UPDATE richiesta SET stato = ? WHERE idRichiesta = ?&quot;);
			statement.setString(1,stato);
			statement.setInt(2,idR);
			ret= statement.executeUpdate();
			return (ret==1);
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: modifica stato richiesta non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: modifica stato richiesta non riuscita&quot;);
			}
		}
	}
	
	/**
	 * Metodo che restituisce un insieme di richieste
	 * @return Restituisce una Collection di Richieste
	 * @throws DbException
	 */
	
	public Collection&lt;Richiesta&gt; getRichieste() throws DbException
	{
		ArrayList&lt;Richiesta&gt; ret = new ArrayList&lt;Richiesta&gt;(); 
		PreparedStatement statement=null;
		ResultSet rs=null;
		try
		{
			statement=connection.prepareStatement(&quot;SELECT * FROM richiesta ORDER BY data desc&quot;);
			rs= statement.executeQuery();
			while(rs.next())
			{
				int idRic=rs.getInt(&quot;idRichiesta&quot;);
				String tipo=rs.getString(&quot;tipo&quot;);
				String data=rs.getString(&quot;data&quot;);
				int richiedente=rs.getInt(&quot;richiedente&quot;);
				String statoR=rs.getString(&quot;stato&quot;);
				String documento=rs.getString(&quot;documento&quot;);
				ret.add(new Richiesta(idRic,tipo,data,richiedente,statoR,documento));
			}
			if(ret.isEmpty())
				return null;
			else
				return ret;
		}
		catch(SQLException e)
		{
			throw new DbException(&quot;Errore: ricerca richieste non riuscita&quot;);
		}
		finally
		{
			try
			{
				if(statement!=null)
					statement.close();
				if(rs!=null)
					rs.close();
			}
			catch(SQLException e)
			{
				throw new DbException(&quot;Errore: ricerca richieste tramite l'id del richiedente non riuscita&quot;);
			}
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC161</id>
      <content>package Bean;

/**
* La classe Impiegato permette solo all'amministratore la gestione degli impiegati
* La classe Impiegato non ha dipendenze
* @author Federico Cinque
*/
public class Impiegato {
	
	private String Nome;
	private String Cognome;
	private String Matricola;
	private String Email;
	private String Login;
	
	/**
	 * Costruttore vuoto della classe Impiegato
	 */
	public Impiegato(){
		Nome=null;
		Cognome=null;
		Matricola=null;
		Email=null;
		Login=null;
	}
	/**
	 * Costruttore della classe Impiegato
	 * @param Nome
	 * @param Cognome
	 * @param Matricola
	 * @param Email
	 * @param Login
	 */
	public Impiegato(String Nome, String Cognome,String Matricola, String Email, String Login){
		this.Nome=Nome;
		this.Cognome=Cognome;
		this.Matricola=Matricola;
		this.Email=Email;
		this.Login=Login;
	}
	/**
	 * Metodo che restituisce il nome dell'impiegato
	 * @return Nome
	 */
	public String getNome() {
		return Nome;
	}
	/**
	 * Metodo che imposta il nome dell'impiegato
	 * @param nome
	 */
	public void setNome(String nome) {
		Nome = nome;
	}
	/**
	 * Metodo che restituisce il cognome dell'impiegato
	 * @return Cognome
	 */
	public String getCognome() {
		return Cognome;
	}
	/**
	 * Metodo che imposta il cognome dell'impiegato
	 * @param cognome
	 */
	public void setCognome(String cognome) {
		Cognome = cognome;
	}
	/**
	 * Metodo che restituisce la matricola dell'impiegato
	 * @return Matricola
	 */
	public String getMatricola() {
		return Matricola;
	}
	/**
	 * Metodo che imposta la matricola dell'impiegato
	 * @param matricola
	 */
	public void setMatricola(String matricola) {
		Matricola = matricola;
	}
	/**
	 * Metodo che restituisce l'e-mail dell'impiegato
	 * @return Email
	 */
	public String getEmail() {
		return Email;
	}
	/**
	 * Metodo che imposta l'e-mail dell'impiegato
	 * @param email
	 */
	public void setEmail(String email) {
		Email = email;
	}
	/**
	 * Metodo che restituisce la login dell'impiegato
	 * @return Login
	 */
	public String getLogin() {
		return Login;
	}
	/**
	 * Metodo che imposta la login dell'impiegato
	 * @param login
	 */
	public void setLogin(String login) {
		Login = login;
	}
	/**
	 * Metodo che converete in una stringa le informazioni di un accesso
	 * @return String
	 */
	public String toString() {
		return &quot;Nome: &quot;+Nome+&quot;, Cognome: &quot;+Cognome+&quot;, Matricola: &quot;+Matricola+&quot;, e-mail: &quot;+Email+&quot;, Login: &quot;+Login;
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC162</id>
      <content>package Manager;

import java.util.Collection;

import Bean.Impiegato;
import DB.DbException;
import DB.DbImpiegato;
/**
* La classe ImpiegatoManager interagisce con le classi di gestione del database
* La classe ImpiegatoManager non ha dipendenze
* @author Federico Cinque
*/
public class ImpiegatoManager {
	private DbImpiegato dbImpiegato;
	/**
	 * Costruttore di default della classe ImpiegatoManager
	 */
	public ImpiegatoManager(){
		dbImpiegato = new DbImpiegato();
	}
	/**
	 * Metodo che modifica un impiegato
	 * invocando il relativo metodo della classe db
	 * @param matricola la stringa che identifica l'impiegato
	 * @param newImpiegato impiegato con i dati aggiornati
	 * @return True se è stato effettuato un inserimento nel db, False altrimenti
	 */
	public boolean modificaImpiegato(String matricola, Impiegato newImpiegato)throws DbException{
		return dbImpiegato.modificaImpiegato(matricola, newImpiegato);
	}
	/**
	 * Metodo che restituisce un impiegato
	 * invocando il relativo metodo della classe db
	 * @param matricola stringa che viene utilizzato come matricola dell'impiegato
	 * @return Restituisce un oggetto di tipo Impiegato
	 * @throws DbException
	 */
	public Impiegato ricercaImpiegatoByMatricola(String matricola) throws DbException{
		return dbImpiegato.getImpiegatoByMatricola(matricola);
	}
	/**
	 * Metodo che inserisce un impiegato all'interno del db
	 * invocando il relativo metodo della classe db
	 * @param newImpiegato Oggetto di tipo Impiegato
	 * @return True se è stato effettuato un inserimento nel db, False altrimenti
	 * @throws DbException
	 */
	public boolean inserisciImpiegato(Impiegato newImpiegato)throws DbException{
		return dbImpiegato.inserisciImpiegato(newImpiegato);
	}
	/**
	 * Metodo che elimina un impiegato dal db
	 * invocando il relativo metodo della classe db
	 * @param matricola la stringa che viene utilizzato come matricola
	 * @return True se è stato effettuato una cancellazione nel db, False altrimenti
	 * @throws DbException
	 */
	public boolean eliminaImpiegato(String matricola)throws DbException{
		return dbImpiegato.eliminaImpiegato(matricola);
	}
	/**
	 * Metodo che restituisce un impiegato
	 * invocando il relativo metodo della classe db
	 * @param login stringa che viene utilizzata come login dell'impiegato
	 * @return Restituisce un oggetto di tipo impiegato
	 * @throws DbException
	 */
	public Impiegato getImpiegatoByLogin(String login) throws DbException{
		return dbImpiegato.getImpiegatoByLogin(login);
	}
	/** Metodo che restituisce un insieme di impiegati
	 * invocando il relativo metodo della classe db
	 * @param nomeImp stringa che viene utilizzata come nome dell'impiegato
	 * @param cognImp stringa che viene utilizzata come cognome dell'impiegato
	 * @return Restituisce una Collection di Impiegati
	 * @throws DbException
	 */
	public Collection&lt;Impiegato&gt; getImpiegatoByName(String nomeImp,String cognImp) throws DbException{
		return dbImpiegato.getImpiegatoByName(nomeImp, cognImp);
	}
	/**
	 * Metodo che restituisce tutti gli impiegati memorizzati
	 * invocando il relativo metodo della classe db
	 * @return Restituisce una Collection di impiegati
	 * @throws DbException
	 */
	public Collection&lt;Impiegato&gt; getImpiegati() throws DbException{
		return dbImpiegato.getImpiegati();
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC163</id>
      <content>package Bean;

/**
* Questa classe si occupa di gestire lo stato di famiglia del cittadino
* @author Christian Ronca
*
*/
public class NucleoFamiliare {
	private int idNucleoFamiliare;
	private int capoFamiglia;
	private String nota;
	private int nComponenti;
	
	/**
	 * Costruttore standard
	 */
	public NucleoFamiliare() {
		
	}

	/**
	 * 
	 * @param idNucleoFamiliare		contiene l'id del gruppo familiare
	 * @param capofamiglia			contiene l'id del capofamiglia
	 * @param nota					eventuale nota
	 */
	public NucleoFamiliare(int idNucleoFamiliare, int capofamiglia, String nota, int nc) {
		this.idNucleoFamiliare = idNucleoFamiliare;
		this.capoFamiglia = capofamiglia;
		this.nota = nota;
		this.nComponenti=nc;
	}
	
	/**
	 * Restituisce l'id dello stato di famiglia
	 * @return	una stringa che contiene l'id dello stato di famiglia
	 */
	public int getIdNucleoFamiliare() {
		return idNucleoFamiliare;
	}

	/**
	 * Setta l'id dello stato di famiglia
	 * @return	una stringa che contiene il nuovo id dello stato di famiglia
	 */
	public int setIdNucleoFamiliare(int str) {
		idNucleoFamiliare = str;
		return idNucleoFamiliare;
	}

	/**
	 * Restituisce l'id del capofamiglia
	 * @return	una stringa che contiene l'id del capofamiglia
	 */
	public int getCapoFamiglia() {
		return capoFamiglia;
	}

	/**
	 * Setta l'id del capofamiglia
	 * @return	una stringa che contiene il nuovo id del capofamiglia
	 */
	public int setCapoFamiglia(int str) {
		capoFamiglia = str;
		return capoFamiglia;
	}

	/**
	 * Restituisce le note rilasciate
	 * @return	una stringa che contiene una nota rilasciata in precedenza
	 */
	public String getNote() {
		return nota;
	}

	/**
	 * Inserisce una nota
	 * @return	una stringa che contiene la nota rilasciata
	 */
	public String setNote(String str) {
		nota = str;
		return nota;
	}
	/**
	 * Restituisce il numero di componenti della famiglia
	 * @return	un intero che contiene il numero di componenti del nucleo familiare
	 */
	public int getNComponenti() {
		return nComponenti;
	}

	/**
	 * Setta il numero di componenti del nucleo familiare
	 * @return	un intero che contiene il nuovo numero di componenti del nucleo familiare
	 */
	public int setNComponenti(int str) {
		nComponenti = str;
		return nComponenti;
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC164</id>
      <content>package Manager;

import Bean.NucleoFamiliare;
import DB.DbException;
import DB.DbNucleoFamiliare;
/**
* La classe NucleoFamiliareManager interagisce con le classi di gestione del database
* La classe NucleoFamiliareManager non ha dipendenze
* @author Federico Cinque
*/
public class NucleoFamiliareManager {

	private DbNucleoFamiliare nucleoF;
	/**
	 * Costruttore di default della classe NucleoFamiliareManager
	 */
	public NucleoFamiliareManager(){
		nucleoF = new DbNucleoFamiliare();
	}
	/**
	 * Metodo che inserisci un oggetto nucleoFamiliare nel db
	 * invocando il relativo metodo della classe db
	 * @param nf Oggetto di tipo nucleofamiliare
	 * @return Restituisce l'id del nucleo familiare inserito
	 * @throws DbException
	 */
	public int inserisciNucleo(NucleoFamiliare nf){
		return nucleoF.inserisciNucleoFamiliare(nf);
	}
	/**
	 * Metodo che permette di controllare lÕesistenza di un nucleo familiare
	 * invocando il relativo metodo della classe db
	 * @param id l'intero che viene utilizzato come id del nucleo familiare
	 * @return True se l'id è presente, False altrimenti
	 * @throws DbException 
	 */
	public boolean controllaidFamiglia(int id){
		return nucleoF.controllaIdFamiglia(id);
	}
	/**
	 * Metodo che restituisce il numero di componenti del nucleo familiare
	 * invocando il relativo metodo della classe db
	 * @param id del nucleo familiare di cui si vuole il numero di componenti
	 * @return True se l'id è presente, False altrimenti
	 * @throws DbException 
	 */
	public int getNComponentiNucleo(int id){
		return nucleoF.getNucleoFamiliareById(id).getNComponenti();
	}
	/**
	 * Metodo che modifica un capo famiglia
	 * invocando il relativo metodo della classe db
	 * @param id l'intero che viene utilizzato come id della famiglia
	 * @param IdCitt l'intero che viene utilizzato come id del capo famiglia
	 * @return True se la modifica ha avuto successo, altrimenti False
	 * @throws DbException
	 */
	public boolean setCapoFamiglia(int id, int IdCitt){
		return nucleoF.setCapoFamiglia(id, IdCitt);
	}
	/**
	 * Metodo che incrementa il numero di componenti del nucleo familiare
	 * invocando un metodo della classe db
	 * @param id del nucleo familiare che si vuole modificare
	 * @return True se la modifica ha avuto successo, altrimenti False
	 * @throws DbException 
	 */
	public boolean incrementaComponenti(int id){
		int n = getNComponentiNucleo(id)+1;
		return nucleoF.setnComponenti(id,n);
	}
	/**
	 * Metodo che decrementa il numero di componenti del nucleo familiare
	 * invocando un metodo della classe db
	 * @param id del nucleo familiare che si vuole modificare
	 * @return True se la modifica ha avuto successo, altrimenti False
	 * @throws DbException 
	 */
	public boolean decrementaComponenti(int id){
		int n = getNComponentiNucleo(id)-1;
		return nucleoF.setnComponenti(id,n);
	}
	
	public NucleoFamiliare getNucleo(int id) {
		return nucleoF.getNucleoFamiliareById(id);
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC165</id>
      <content>package Bean;

/**
* Classe che gestisce i metodi dell'oggetto Richiesta
* @author 	Christian Ronca
* @version 1.0
*/
public class Richiesta {
	private int idRichiesta;
	private String tipo;
	private String data;
	private int richiedente;
	private String stato;
	private String documento;
	
	/**
	 * Costruttore di default
	 */
	public Richiesta() {
		
	}
	
	/**
	 * Costruttore paramentrico 
	 * @param idRichiesta 		id della richiesta
	 * @param tipo 				tipo della richiesta 
	 * @param data 				data in cui è stata effettuata la richiesta
	 * @param richiedente 		id del richiedente
	 * @param stato 			stato di avanzamento della richiesta
	 * @param documento 		link al documento richiesto
	 */
	public Richiesta(int idRichiesta, String tipo, String data, int richiedente, String stato, String documento) {
		this.idRichiesta = idRichiesta;
		this.tipo = tipo;
		this.data = data;
		this.richiedente = richiedente;
		this.stato = stato;
		this.documento = documento;
	}
	
	/**
	 * Costruttore paramentrico 
	 * @param tipo 				tipo della richiesta 
	 * @param data 				data in cui è stata effettuata la richiesta
	 * @param richiedente 		id del richiedente
	 * @param stato 			stato di avanzamento della richiesta
	 * @param documento 		link al documento richiesto
	 */
	public Richiesta(String tipo, String data, int richiedente, String stato, String documento) {
		this.tipo = tipo;
		this.data = data;
		this.richiedente = richiedente;
		this.stato = stato;
		this.documento = documento;
	}
	
	/**
	 * Preleva l'id della richiesta
	 * @return	una stringa con l'id della richiesta
	 */
	public int getIdRichiesta() {
		return idRichiesta;
	}
	
	/**
	 * Setta un nuovo id alla richiesta
	 * @param str	prende in input una stringa che contiene il nuovo id della richiesta
	 * @return		una stringa che contiene il nuovo id
	 */
	public int setIdRichiesta(int str) {
		idRichiesta = str;
		return str;
	}
	
	/**
	 * Preleva il tipo di richiesta effettuata
	 * @return	una stringa che contiene il tipo di richiesta
	 */
	public String getTipo() {
		return tipo;
	}
	
	/**
	 * Setta il tipo della richiesta
	 * @param str	prende in input una stringa che contiene il tipo della richiesta
	 * @return		una stringa che contiene il nuovo tipo
	 */
	public String setTipo(String str) {
		tipo = str;
		return str;
	}
	
	/**
	 * Preleva la data in cui è stata fatta la richiesta
	 * @return una stringa che contiene la data della richiesta
	 */
	public String getData() {
		return data;
	}
	
	/**
	 * Setta la data alla richiesta
	 * @param str	prende in input una stringa che contiene la data della richiesta
	 * @return		una stringa che contiene la nuova data
	 */
	public String setData(String str) {
		data = str;
		return str;
	}
	
	/**
	 * Preleva l'id del richiedente che ha effettuato la richiesta
	 * @return	una stringa con l'id della richiesta
	 */
	public int getRichiedente() {
		return richiedente;
	}
	
	/**
	 * Setta il richiedente della richiesta
	 * @param str	prende in input una stringa che contiene il richiedente della richiesta
	 * @return		una stringa che contiene il richiedente
	 */
	public int setRichiedente(int str) {
		richiedente = str;
		return str;
	}
	
	/**
	 * Preleva lo stato della richiesta
	 * @return	una stringa con l'id della richiesta
	 */
	public String getStato() {
		return stato;
	}
	
	/**
	 * Setta lo stato della richiesta
	 * @param str	prende in input una stringa che contiene la data della richiesta
	 * @return		una stringa che contiene la nuova data
	 */
	public String setStato(String str) {
		stato = str;
		return str;
	}
	
	/**
	 * Preleva il link al documento richiesto
	 * @return	una stringa con l'id della richiesta
	 */
	public String getDocumento() {
		return documento;
	}
	
	/**
	 * Setta il link al documento
	 * @param str	prende in input una stringa che contiene il link al documento richiesto
	 * @return		una stringa che contiene il nuovo documento
	 */
	public String setDocumento(String str) {
		documento = str;
		return str;
	}
	
	/**
	 * Restituisce un valore booleano nel caso in cui la richiesta sia stata accettata
	 * @return		true se la richiesta è stata accettata
	 */
	public boolean isAccettata() {
		return stato.equalsIgnoreCase(&quot;accettata&quot;);
	}
	
	/**
	 * Restituisce un valore booleano nel caso in cui la richiesta sia stata rifiutata
	 * @return		false se la richiesta è stata rifiutata
	 */
	public boolean isRifiutata() {
		return stato.equalsIgnoreCase(&quot;rifiutata&quot;);
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC166</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
/**
* La classe ServletAnnulla annulla l'operazione che l'utente stava eseguendo
* La classe ServletAnnulla non ha dipendenze
* @author Federico Cinque
*/
public class ServletAnnulla extends HttpServlet{
	public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();
		
		session.removeAttribute(&quot;amm&quot;);
		session.removeAttribute(&quot;acc&quot;);
		session.removeAttribute(&quot;c&quot;);
		session.removeAttribute(&quot;newCapo&quot;);
		session.removeAttribute(&quot;citt&quot;);
		
		String url=&quot;/myDoc/workers/index.jsp&quot;;
		response.sendRedirect(url);
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC167</id>
      <content>package Servlet;
import Bean.*;
import Manager.*;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
* La classe ServletCaricaPratica carica in una sessione gli oggetti Cittadino e CartaIdentita
* La classe dipende da DbCittadino e DbCartaIdentita
* @author Christian Ronca
*/

public class ServletCaricaPratica extends HttpServlet {
	
	public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		int id_utente = Integer.parseInt(request.getParameter(&quot;id_utente&quot;));
		
		CittadinoManager cm = new CittadinoManager();
		Cittadino cittadino = cm.getCittadinoById(id_utente);
		HttpSession session = request.getSession();
		CIManager cim = new CIManager();
		CartaIdentita ci = cim.getCartaByIdCStri(id_utente);
		
		session.setAttribute(&quot;c&quot;, cittadino);
		session.setAttribute(&quot;ci&quot;, ci);
		
		String url=&quot;/myDoc/workers/index.jsp?func=pra&amp;page=modulone&quot;;
		response.sendRedirect(url);
	}

}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC168</id>
      <content>package Servlet;
import Bean.CartaIdentita;
import Bean.Cittadino;
import DB.*;
import Manager.AccessManager;
import Manager.CittadinoManager;
import Manager.NucleoFamiliareManager;

import java.io.*;
import java.util.GregorianCalendar;
import javax.servlet.*;
import javax.servlet.http.*;

import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.Element;
import com.lowagie.text.Font;
import com.lowagie.text.PageSize;
import com.lowagie.text.Paragraph;
import com.lowagie.text.pdf.PdfPCell;
import com.lowagie.text.pdf.PdfPTable;
import com.lowagie.text.pdf.PdfWriter;

/**
* La classe ServletCreaPdfCambioAbitazione un file PDF in base ai dati ricevuti da una pagina JSP
* La classe non ha nessuna dipendenza
* @author Christian Ronca
*/

public class ServletCreaPdfCambioAbitazione extends HttpServlet {
	private static final long serialVersionUID = -168526506138896791L;
	private HttpSession session;
	
	public void doPost(HttpServletRequest request, HttpServletResponse response) 
		throws ServletException, IOException {
		session = request.getSession();
		
		try {
			GregorianCalendar gc = new GregorianCalendar();
			int gg = gc.get(GregorianCalendar.DATE);
			int mm = gc.get(GregorianCalendar.MONTH) + 1;
			int year = gc.get(GregorianCalendar.YEAR);
			String now = &quot;&quot; + year + mm + gg;
			String inout = &quot;&quot;;
			
			String nome_comune			= request.getParameter(&quot;comunename&quot;).toUpperCase();
			//String numb_document		= request.getParameter(&quot;numberdocument&quot;);
			String nome					= request.getParameter(&quot;name&quot;).toUpperCase();
			String surname				= request.getParameter(&quot;surname&quot;).toUpperCase();
			String name_citta			= request.getParameter(&quot;citta&quot;).toUpperCase();
			String gg_date				= request.getParameter(&quot;gg&quot;);
			String mm_date				= request.getParameter(&quot;mm&quot;);
			String aa_date				= request.getParameter(&quot;aa&quot;);
			String newcomune			= request.getParameter(&quot;newcomune&quot;).toUpperCase();
			String indir				= request.getParameter(&quot;via&quot;).toUpperCase();
			String numero_civico		= request.getParameter(&quot;civico&quot;);
			//String interno				= request.getParameter(&quot;interno&quot;);
			String indirnew				= request.getParameter(&quot;newvia&quot;).toUpperCase();
			String num_civnew			= request.getParameter(&quot;num&quot;);
			//String interno_new			= request.getParameter(&quot;interno1&quot;);
			String pref					= request.getParameter(&quot;pref&quot;);
			String tel					= request.getParameter(&quot;tel&quot;);
			String cntlr				= request.getParameter(&quot;radio&quot;);
			String check				= request.getParameter(&quot;check&quot;);
			
			String parent1				= request.getParameter(&quot;parentela1&quot;).toUpperCase();
			String surname1				= request.getParameter(&quot;surname1&quot;).toUpperCase();
			String name1				= request.getParameter(&quot;name1&quot;).toUpperCase();
			String luogo1				= request.getParameter(&quot;luogo1&quot;).toUpperCase();
			String gg1					= request.getParameter(&quot;gg1&quot;);
			String mm1					= request.getParameter(&quot;mm1&quot;);
			String aa1					= request.getParameter(&quot;aa1&quot;);
			String parent2				= request.getParameter(&quot;parentela2&quot;).toUpperCase();
			String surname2				= request.getParameter(&quot;surname2&quot;).toUpperCase();
			String name2				= request.getParameter(&quot;name2&quot;).toUpperCase();
			String luogo2				= request.getParameter(&quot;luogo2&quot;).toUpperCase();
			String gg2					= request.getParameter(&quot;gg2&quot;);
			String mm2					= request.getParameter(&quot;mm2&quot;);
			String aa2					= request.getParameter(&quot;aa2&quot;);
			String parent3				= request.getParameter(&quot;parentela3&quot;).toUpperCase();
			String surname3				= request.getParameter(&quot;surname3&quot;).toUpperCase();
			String name3				= request.getParameter(&quot;name3&quot;).toUpperCase();
			String luogo3				= request.getParameter(&quot;luogo3&quot;).toUpperCase();
			String gg3					= request.getParameter(&quot;gg3&quot;);
			String mm3					= request.getParameter(&quot;mm3&quot;);
			String aa3					= request.getParameter(&quot;aa3&quot;);
			String parent4				= request.getParameter(&quot;parentela4&quot;).toUpperCase();
			String surname4				= request.getParameter(&quot;surname4&quot;).toUpperCase();
			String name4				= request.getParameter(&quot;name4&quot;).toUpperCase();
			String luogo4				= request.getParameter(&quot;luogo4&quot;).toUpperCase();
			String gg4					= request.getParameter(&quot;gg4&quot;);
			String mm4					= request.getParameter(&quot;mm4&quot;);
			String aa4					= request.getParameter(&quot;aa4&quot;);
			String parent5				= request.getParameter(&quot;parentela5&quot;).toUpperCase();
			String surname5				= request.getParameter(&quot;surname5&quot;).toUpperCase();
			String name5				= request.getParameter(&quot;name5&quot;).toUpperCase();
			String luogo5				= request.getParameter(&quot;luogo5&quot;).toUpperCase();
			String gg5					= request.getParameter(&quot;gg5&quot;);
			String mm5					= request.getParameter(&quot;mm5&quot;);
			String aa5					= request.getParameter(&quot;aa5&quot;);
			String parent6				= request.getParameter(&quot;parentela6&quot;).toUpperCase();
			String surname6				= request.getParameter(&quot;surname6&quot;).toUpperCase();
			String name6				= request.getParameter(&quot;name6&quot;).toUpperCase();
			String luogo6				= request.getParameter(&quot;luogo6&quot;).toUpperCase();
			String gg6					= request.getParameter(&quot;gg6&quot;);
			String mm6					= request.getParameter(&quot;mm6&quot;);
			String aa6					= request.getParameter(&quot;aa6&quot;);
			
			String nome11				= request.getParameter(&quot;nome11&quot;).toUpperCase();
			String nome12				= request.getParameter(&quot;nome12&quot;).toUpperCase();
			String rapporto				= request.getParameter(&quot;rapporto&quot;).toUpperCase();
			//String data_gg				= request.getParameter(&quot;data_gg&quot;);
			//String data_mm				= request.getParameter(&quot;data_mm&quot;);
			//String data_aa				= request.getParameter(&quot;data_aa&quot;);
			//String identita1			= request.getParameter(&quot;identita1&quot;).toUpperCase();
			//String identita2			= request.getParameter(&quot;identita2&quot;).toUpperCase();
			//String cod_doc				= request.getParameter(&quot;cod_document&quot;);
			String indirizzo			= request.getParameter(&quot;indirizzo&quot;).toUpperCase();
			String num_civico1			= request.getParameter(&quot;num_civico1&quot;);
			//String interno1				= request.getParameter(&quot;interno1&quot;);
			String prec_res				= request.getParameter(&quot;prec_res&quot;).toUpperCase();
			//String cc_date				= request.getParameter(&quot;cc_date&quot;);
			//String cc_mese				= request.getParameter(&quot;cc_mese&quot;);
			//String cc_anno				= request.getParameter(&quot;cc_anno&quot;);
			String ab_libera			= request.getParameter(&quot;abitaz&quot;);
			String abilita_cod_doc		= request.getParameter(&quot;cod_doc&quot;);
			String cod_documento		= request.getParameter(&quot;cod_documento&quot;);
			String nametab1				= request.getParameter(&quot;nametab1&quot;).toUpperCase();
			String surnametab1			= request.getParameter(&quot;surnametab1&quot;).toUpperCase();
			String nametab2				= request.getParameter(&quot;nametab2&quot;).toUpperCase();
			String surnametab2			= request.getParameter(&quot;surnametab2&quot;).toUpperCase();
			String nametab3				= request.getParameter(&quot;nametab3&quot;).toUpperCase();
			String surnametab3			= request.getParameter(&quot;surnametab3&quot;).toUpperCase();
			String nametab4				= request.getParameter(&quot;nametab4&quot;).toUpperCase();
			String surnametab4			= request.getParameter(&quot;surnametab4&quot;).toUpperCase();
			String nametab5				= request.getParameter(&quot;nametab5&quot;).toUpperCase();
			String surnametab5			= request.getParameter(&quot;surnametab5&quot;).toUpperCase();
			String nametab6				= request.getParameter(&quot;nametab6&quot;).toUpperCase();
			String surnametab6			= request.getParameter(&quot;surnametab6&quot;).toUpperCase();
			String nametab7				= request.getParameter(&quot;nametab7&quot;).toUpperCase();
			String surnametab7			= request.getParameter(&quot;surnametab7&quot;).toUpperCase();
			//String nametab8				= request.getParameter(&quot;nametab8&quot;).toUpperCase();
			//String surnametab8			= request.getParameter(&quot;surnametab8&quot;).toUpperCase();
			
			//String qualifica_vigile 	= request.getParameter(&quot;qualifica_vigile&quot;); //maresciallo
			String dati_vigile			= request.getParameter(&quot;nome_vigile&quot;) + &quot; &quot; + request.getParameter(&quot;cognome_vigile&quot;);
			String dispone				= request.getParameter(&quot;testo_ufficiale&quot;);
			String accert				= request.getParameter(&quot;text_area&quot;);
			String indirizzo_esatto_d	= request.getParameter(&quot;radio1&quot;);
			String indirizzo_esatto		= request.getParameter(&quot;indix&quot;); // indix
			//String ab_effettivamente	= request.getParameter(&quot;check&quot;);
			String alloggio_occupato	= request.getParameter(&quot;check1&quot;);
			String cp1					= request.getParameter(&quot;cogn_pers&quot;);
			String np1					= request.getParameter(&quot;nome_pers&quot;);
			String pp1					= request.getParameter(&quot;parent&quot;);
			String cp2					= request.getParameter(&quot;cogn_pers1&quot;);
			String np2					= request.getParameter(&quot;nome_pers1&quot;);
			String pp2					= request.getParameter(&quot;parent1&quot;);
			String cp3					= request.getParameter(&quot;cogn_pers2&quot;);
			String np3					= request.getParameter(&quot;nome_pers2&quot;);
			String pp3					= request.getParameter(&quot;parent2&quot;);
			String proprieta_componenti = request.getParameter(&quot;check2&quot;);
			String titolo_di_possesso	= request.getParameter(&quot;locazione&quot;);
			//String extra_possesso		= request.getParameter(&quot;specification&quot;);
			String tipo_di_alloggio		= request.getParameter(&quot;check3_si&quot;);
			String osser_abitazione		= request.getParameter(&quot;textarea&quot;);
			String mot					= request.getParameter(&quot;rad&quot;);
			String mot_causa			= request.getParameter(&quot;text_trasfert&quot;);
			String professione			= request.getParameter(&quot;prof1&quot;);
			String ind_lavoro			= request.getParameter(&quot;all&quot;);
			String transfer				= request.getParameter(&quot;indiconiuge&quot;);
			String circostanze			= request.getParameter(&quot;circos&quot;);
			String oss_finali			= request.getParameter(&quot;osservtext&quot;);
			
			cntlr = &quot;stesso&quot;;
			if(cntlr.equals(&quot;stesso&quot;)) {
				inout = &quot;interno&quot;;
			} else {
				inout = &quot;altro&quot;;
			}
			
			Document document = new Document(PageSize.A4);
			PdfWriter.getInstance(document, response.getOutputStream());
			FileOutputStream fout = new FileOutputStream(&quot;webapps//myDoc//workers//pratiche_complete//&quot; + now +&quot;_2345_&quot; + inout +&quot;.pdf&quot;);
			PdfWriter.getInstance(document, fout);
			response.setContentType(&quot;application/pdf&quot;);
			document.open();
			
			Paragraph spazio = new Paragraph(&quot;\n&quot;);
			Paragraph anagrafe_comune = new Paragraph(&quot;Anagrafe del comune di &quot; + nome_comune, new Font(Font.HELVETICA, 10, Font.BOLD));
			anagrafe_comune.setAlignment(Element.ALIGN_RIGHT);
			document.add(anagrafe_comune);
			
			Paragraph oggetto = new Paragraph(&quot;OGGETTO: DICHIARAZIONE DI CAMBIAMENTO DI ABITAZIONE&quot;, new Font(Font.HELVETICA, 12, Font.BOLD));
			oggetto.setAlignment(Element.ALIGN_CENTER);
			document.add(oggetto);
			
			Paragraph sottoscritto = new Paragraph(&quot; Io sottoscritto/a &quot; + surname + &quot; &quot; + nome + &quot; nato/a in &quot; + name_citta +&quot; il &quot; + gg_date+&quot;/&quot;+mm_date+&quot;/&quot;+aa_date + 
					&quot; già residente in via &quot; + indir +&quot; &quot;+ numero_civico + &quot; dichiaro, ai sensi e per gli effetti del combinato disposto dagli articoli 10,&quot; +
					&quot; lettera a) e 13 del D.P.R. 30/05/1989, n 223 di essermi trasferito nel comune di &quot;+ newcomune +&quot; in via &quot; + indirnew + &quot; &quot; +num_civnew + &quot; tel: &quot; + pref + &quot; &quot; + tel +
					&quot; unitamente ai seguenti familiari/conviventi:\n &quot;);
			sottoscritto.setAlignment(Element.ALIGN_JUSTIFIED);
			document.add(sottoscritto);
			
			//tabella stato di famiglia
			PdfPTable sf = new PdfPTable(5);
			sf.setWidthPercentage(100);
			sf.addCell(new Paragraph(&quot;PARENTELA&quot;));
			sf.addCell(new Paragraph(&quot;NOME&quot;));
			sf.addCell(new Paragraph(&quot;COGNOME&quot;));
			sf.addCell(new Paragraph(&quot;LUOGO DI NASCITA&quot;));
			sf.addCell(new Paragraph(&quot;DATA&quot;));
			sf.addCell(new Paragraph(parent1));
			sf.addCell(new Paragraph(surname1));
			sf.addCell(new Paragraph(name1));
			sf.addCell(new Paragraph(luogo1));
			sf.addCell(new Paragraph(gg1+&quot;/&quot;+mm1+&quot;/&quot;+aa1));
			sf.addCell(new Paragraph(parent2));
			sf.addCell(new Paragraph(surname2));
			sf.addCell(new Paragraph(name2));
			sf.addCell(new Paragraph(luogo2));
			sf.addCell(new Paragraph(gg2+&quot;/&quot;+mm2+&quot;/&quot;+aa2));
			document.add(sf);
			
			Paragraph mendace = new Paragraph(&quot;Dichiaro, ai sensi e per gli effetti di cui art. 46 e 47 del DPR 445/00 e pienamente consapevole &quot; +
					&quot;delle responsabilità civili e penali previste in caso di dichiarazione mendace che:\n\n&quot;);
			mendace.setAlignment(Element.ALIGN_JUSTIFIED);
			document.add(mendace);
			
			if(ab_libera.equals(&quot;si&quot;)) {
				Paragraph ab = new Paragraph(&quot; - l'abitazione nella quale mi sono trasferito/a è libera da persone e/o cose;\n\n\n&quot;);
				document.add(ab);
			} else {
				Paragraph occ = new Paragraph(&quot; - è occupata da terze parti, sotto riportate: \n\n&quot;);
				document.add(occ);
				PdfPTable altri_occupanti = new PdfPTable(2);
				altri_occupanti.setWidthPercentage(100);
				altri_occupanti.addCell(new Paragraph(&quot;NOME&quot;));
				altri_occupanti.addCell(new Paragraph(&quot;COGNOME&quot;));
				altri_occupanti.addCell(new Paragraph(nametab1));
				altri_occupanti.addCell(new Paragraph(surnametab1));
				altri_occupanti.addCell(new Paragraph(nametab2));
				altri_occupanti.addCell(new Paragraph(surnametab2));
				altri_occupanti.addCell(new Paragraph(nametab3));
				altri_occupanti.addCell(new Paragraph(surnametab3));
				altri_occupanti.addCell(new Paragraph(nametab4));
				altri_occupanti.addCell(new Paragraph(surnametab4));
				altri_occupanti.addCell(new Paragraph(nametab5));
				altri_occupanti.addCell(new Paragraph(surnametab5));
				altri_occupanti.addCell(new Paragraph(nametab6));
				altri_occupanti.addCell(new Paragraph(surnametab6));
				altri_occupanti.addCell(new Paragraph(nametab7));
				altri_occupanti.addCell(new Paragraph(surnametab7));
				document.add(altri_occupanti);
				
				if(check != null) {
					Paragraph p = new Paragraph(&quot;\nche tra il/la Sig./ra &quot; + nome11 + &quot; ed il/la Sig./ra &quot; + nome12 +&quot; sussiste il seguente rapporto di: &quot; +rapporto + &quot;\n\n&quot;);
					document.add(p);
				} else {
					Paragraph p1 = new Paragraph(&quot;\nche non sussiste nessun rapporto di parentela con le persoche che occupano già l'alloggio e quelle che vi sono trasferite\n\n&quot;);
					document.add(p1);
				}
			}
					//inserire le altri info in caso di abilitazione

			Paragraph sdata = new Paragraph(&quot;Data: &quot;+gg+&quot;/&quot;+mm+&quot;/&quot;+year, new Font(Font.HELVETICA, 12, Font.NORMAL));
			sdata.setAlignment(Element.ALIGN_LEFT);
			document.add(sdata);
			
			Paragraph firma_dichiarante = new Paragraph(&quot;_________________\nFirma del dichiarante\n\n&quot;, new Font(Font.HELVETICA, 12, Font.NORMAL));
			firma_dichiarante.setAlignment(Element.ALIGN_RIGHT);
			document.add(firma_dichiarante);
			
			if(abilita_cod_doc != null) {
				PdfPTable tabella_estremi = new PdfPTable(1);
				tabella_estremi.setWidthPercentage(100);
				PdfPCell cella = new PdfPCell();
				Paragraph livello = new Paragraph(&quot;(1) &quot; + cod_documento);
				Paragraph livello2 = new Paragraph(&quot;In questo spazio riportare gli estremi del documento qualora la persona non sia conosciuta dall'ufficiale d'anagrafe.&quot;, new Font(Font.HELVETICA, 8));
				cella.addElement(livello);
				cella.addElement(livello2);
				tabella_estremi.addCell(cella);
				document.add(tabella_estremi);
			}
			
			Paragraph polizia = new Paragraph(&quot;\nAL COMANDO DI POLIZIA MUNICIPALE - SEDE&quot;, new Font(Font.HELVETICA, 12, Font.BOLD));
			polizia.setAlignment(Element.ALIGN_RIGHT);
			document.add(polizia);
			
			Paragraph alcomando_testo = new Paragraph(&quot;\n A norma dell'art. 4 della legge n. 1228 e dell'art. 18, 1° comma del regolamento di esecuzione (DPR 30 maggio 1989, n. 223), pregasi assumere,&quot; +
					&quot; tutte le informazioni riferite alle sopra elencate persone, rispondendo a tutte le domande indicate all' interno del presente foglio.\nDimora abituale dichiata in via &quot;+indirizzo+ &quot; &quot; +num_civico1+
					&quot;\nPrecedente residenza &quot; + prec_res + &quot;\n\n&quot;);
			alcomando_testo.setAlignment(Element.ALIGN_JUSTIFIED);
			document.add(alcomando_testo);
			document.add(sdata);
			
			Paragraph firma_impiegato = new Paragraph(&quot;_________________\nL'ufficiale di anagrafe responsabile\n\n&quot;, new Font(Font.HELVETICA, 12, Font.NORMAL));
			firma_impiegato.setAlignment(Element.ALIGN_RIGHT);
			document.add(firma_impiegato);
			
			Paragraph ufficiale_anagrafe = new Paragraph(&quot;L'UFFICIALE DI ANAGRAFE&quot;, new Font(Font.HELVETICA, 12, Font.BOLD));
			ufficiale_anagrafe.setAlignment(Element.ALIGN_CENTER);
			document.add(ufficiale_anagrafe);
			
			Paragraph ufficiale_testo = new Paragraph(&quot;Visto la relazione del Comando di Polizia Municipale\nA norma di: &quot; + dati_vigile);
			document.add(ufficiale_testo);
			
			Paragraph disp = new Paragraph(&quot;DISPONE: &quot; + dispone);
			document.add(disp);
			
			Paragraph testo_disp = new Paragraph(&quot;\n&quot;);
			testo_disp.setAlignment(Element.ALIGN_JUSTIFIED);
			document.add(testo_disp);
			document.add(sdata);
			document.add(firma_impiegato);
			
			Paragraph accertamento = new Paragraph(&quot;Accertamento del &quot; + accert + &quot;\n&quot;, new Font(Font.HELVETICA, 12, Font.BOLD));
			document.add(accertamento);
			Paragraph indirizzo_dic = new Paragraph(&quot; - L'indirizzo dichiarato è esatto? &quot; + indirizzo_esatto_d.toUpperCase() + &quot;\n&quot;,
					new Font(Font.HELVETICA, 12, Font.COURIER));
			document.add(indirizzo_dic);
			if(indirizzo_esatto_d.equals(&quot;no&quot;)) {
				Paragraph indirizzo_es = new Paragraph(&quot; - L'indirizzo esatto è: &quot; + indirizzo_esatto.toUpperCase() + &quot;\n&quot;);
				document.add(indirizzo_es);
			}

			Paragraph abitazione_eff = new Paragraph(&quot; - La persona o le persone sopra citate abitano effettivamente all'indirizzo dichiarato? &quot; + indirizzo_esatto_d.toUpperCase() + &quot;\n&quot;);
			document.add(abitazione_eff);
			Paragraph alloggio_occ = new Paragraph(&quot; - L'alloggio è occupato anche da altre persone residenti oltre quelle sopra citatate? &quot; + alloggio_occupato.toUpperCase() +&quot;\n&quot;);
			document.add(alloggio_occ);
			if(alloggio_occupato.equals(&quot;si&quot;)) {
				document.add(spazio);
				PdfPTable tabella_famiglia = new PdfPTable(3);
				tabella_famiglia.addCell(new Paragraph(&quot;COGNOME&quot;));
				tabella_famiglia.addCell(new Paragraph(&quot;NOME&quot;));
				tabella_famiglia.addCell(new Paragraph(&quot;RELAZIONE DI PARENTELA&quot;));
				tabella_famiglia.addCell(new Paragraph(cp1));
				tabella_famiglia.addCell(new Paragraph(np1));
				tabella_famiglia.addCell(new Paragraph(pp1));
				tabella_famiglia.addCell(new Paragraph(cp2));
				tabella_famiglia.addCell(new Paragraph(np2));
				tabella_famiglia.addCell(new Paragraph(pp2));
				tabella_famiglia.addCell(new Paragraph(cp3));
				tabella_famiglia.addCell(new Paragraph(np3));
				tabella_famiglia.addCell(new Paragraph(pp3));
				tabella_famiglia.setWidthPercentage(100);
				document.add(tabella_famiglia);
			}
			
			Paragraph titolo = new Paragraph(&quot; - L'alloggio è di proprietà di uno dei componenti? &quot; + proprieta_componenti.toUpperCase() + &quot;\n&quot;);
			document.add(titolo);
			if(proprieta_componenti.equals(&quot;no&quot;)) {
				Paragraph poss = new Paragraph(&quot; - Titolo di possesso: &quot; + titolo_di_possesso.toUpperCase() + &quot;\n&quot;);
				document.add(poss);
			}
			
			Paragraph tipo_alloggio = new Paragraph(&quot; - Tipo di alloggio: &quot;+tipo_di_alloggio.toUpperCase() +&quot;\n&quot;); // inserire il tipo di alloggio
			document.add(tipo_alloggio);
			if(tipo_di_alloggio.equals(&quot;altro&quot;)) {
				Paragraph osservazioni_tipo = new Paragraph(&quot; - Osservazioni sul tipo di alloggio: &quot; + osser_abitazione + &quot;\n&quot;);
				document.add(osservazioni_tipo);
			}
			Paragraph motivo = new Paragraph(&quot; - Motivo del trasferimento: &quot; + mot.toUpperCase() + &quot;\n&quot;);
			document.add(motivo);
			if(mot.equals(&quot;altro&quot;)) {
				Paragraph motivo_causa = new Paragraph(&quot; &gt; Causa: &quot; + mot_causa.toUpperCase() + &quot;\n\n&quot;);
				document.add(motivo_causa);
			}
			
			document.add(spazio);
			PdfPTable tabella_professione = new PdfPTable(2);
			tabella_professione.addCell(new Paragraph(&quot;Professione o condizione non professionale dei componenti&quot;));
			tabella_professione.addCell(new Paragraph(&quot;Indicare il luogo di lavoro o l'indirizzo della scuola frequentata&quot;));
			tabella_professione.addCell(new Paragraph(professione));
			tabella_professione.addCell(new Paragraph(ind_lavoro));
			tabella_professione.setWidthPercentage(100);
			document.add(tabella_professione);
			
			if(transfer.length() != 0) {
				Paragraph altro_coniuge = new Paragraph(&quot; - Quando il trasferimento si riferisce ad un solo coniuge (con o senza familiari) indicare l'indirizzo: &quot; + transfer.toUpperCase() + &quot;\n&quot;);
				document.add(altro_coniuge);
			}
			Paragraph desume = new Paragraph(&quot; - Dalle informazioni sopra indicate si desume che sussista la dimora abituale? &quot;+circostanze.toUpperCase()+&quot;\n&quot;);
			document.add(desume);
			Paragraph osservazioni_finali = new Paragraph(&quot; - Osservazioni: &quot; + oss_finali + &quot;\n\n\n&quot;);
			document.add(osservazioni_finali);
			document.add(sdata);
			document.add(firma_dichiarante);
			
			document.close();
			fout.close();
			
			if(cntlr.equals(&quot;stesso&quot;)) {
				aggiornaDB(indirnew, num_civnew);
			} else {
				cancellaDB(request, response);
			}
			
		} catch (DocumentException e) {
			e.printStackTrace();
		}
	}

	private void aggiornaDB(String indirnew, String num_civnew) {
		DbCambioResidenza cr = new DbCambioResidenza();
		CartaIdentita ci = (CartaIdentita) session.getAttribute(&quot;ci&quot;);
		cr.changeResidenceIn(ci.getNumero(), indirnew, Integer.parseInt(num_civnew));
	}
	
	private void cancellaDB(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		AccessManager AM = new AccessManager();
		CittadinoManager CM = new CittadinoManager();
		Cittadino c = (Cittadino) session.getAttribute(&quot;c&quot;);
		
		if(AM.eliminaAccesso(c.getLogin()) &amp;&amp; CM.cancellaCittadino(c.getIdCittadino())){	//elimina il cittadino e l'accesso 
			//controllando che l'esito sia positivo
			NucleoFamiliareManager NFM = new NucleoFamiliareManager();
			NFM.getNComponentiNucleo(c.getNucleoFamiliare());
			String ris=&quot;ok&quot;;
			ServletContext sc = getServletContext();
			request.setAttribute(&quot;ris&quot;, ris);
			RequestDispatcher rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 
			rd.forward(request, response);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC169</id>
      <content>package Servlet;
import java.io.*;
import java.util.GregorianCalendar;
import javax.servlet.*;
import javax.servlet.http.*;
import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.Element;
import com.lowagie.text.Font;
import com.lowagie.text.Paragraph;
import com.lowagie.text.pdf.PdfWriter;

/**
* La classe ServletCreaPdfCertificati crea un file PDF con i dati ricevuti da una pagina JSP
* La classe non ha nessuna dipendenza
* @author Christian Ronca
*/

public class ServletCreaPdfCertificati extends HttpServlet {
	private static final long serialVersionUID = -2298846540114609975L;

	public void doPost(HttpServletRequest request, HttpServletResponse response) 
		throws ServletException, IOException {
	 
		String certificato	= request.getParameter(&quot;certificato&quot;);
String cognome		= request.getParameter(&quot;cognome&quot;).toUpperCase();
		String nome			= request.getParameter(&quot;nome&quot;).toUpperCase();
		String sesso		= request.getParameter(&quot;sesso&quot;).toUpperCase();
		String nascita		= request.getParameter(&quot;nascita&quot;).toUpperCase();
		String provincia	= request.getParameter(&quot;provincia&quot;).toUpperCase();
		String residenza	= request.getParameter(&quot;residenza&quot;).toUpperCase();
		String prov_res		= request.getParameter(&quot;prov_res&quot;).toUpperCase();
		String data			= request.getParameter(&quot;data&quot;);
		String indirizzo	= request.getParameter(&quot;indirizzo&quot;).toUpperCase();
		String dichiara_x 	= request.getParameter(&quot;dichiara&quot;).toUpperCase();

		response.setContentType(&quot;application/pdf&quot;);
		//PrintWriter out = response.getWriter();
		
		try {
			Document document = new Document();
			PdfWriter.getInstance(document, response.getOutputStream());
			document.open();
	
			Paragraph par = new Paragraph(&quot;\nDichiarazione sostitutiva della&quot;, new Font(Font.HELVETICA, 16, Font.BOLD));
			par.setAlignment(Element.ALIGN_CENTER);
			document.add(par);
			
			Paragraph titolo = new Paragraph(&quot;CERTIFICAZIONE DI &quot; + certificato, new Font(Font.HELVETICA, 22, Font.BOLD));
			titolo.setAlignment(Element.ALIGN_CENTER);
			document.add(titolo);
			
			Paragraph dpr = new Paragraph(&quot;(Art. 46 - lettera a - D.P.R. 28 dicembre 2000, n. 445)\n\n\n\n\n&quot;, new Font(Font.HELVETICA, 10, Font.BOLD));
			dpr.setAlignment(Element.ALIGN_CENTER);
			document.add(dpr);
			
			Paragraph testo = new Paragraph(&quot;Il Sottoscritto/a &quot; + cognome + &quot; &quot; + nome +&quot; nato/a in &quot;+ nascita +&quot; il &quot; + data + &quot; residente &quot; +
					&quot;in &quot;+residenza+&quot; provincia di &quot;+provincia+&quot; in via &quot;+indirizzo+&quot;, consapevole che chiunque rilascia dichiarazioni mendaci &quot; +
					&quot;è punito ai sensi del codice penale e delle leggi speciali in materia, ai sensi e per&quot; +
					&quot; gli effetti dell'art. 76 D.P.R. n. 445/2000\n\n\n&quot;, new Font(Font.HELVETICA, 14, Font.NORMAL));
			dpr.setAlignment(Element.ALIGN_CENTER);
			document.add(testo);
			
			Paragraph dichiara = new Paragraph(&quot;DICHIARA\n&quot;, new Font(Font.HELVETICA, 18, Font.BOLD));
			dichiara.setAlignment(Element.ALIGN_CENTER);
			document.add(dichiara);

			Paragraph cosa_dichiara = new Paragraph(&quot;di essere &quot; + dichiara_x +&quot;\n\n\n\n\n\n&quot;, new Font(Font.HELVETICA, 16, Font.NORMAL));
			cosa_dichiara.setAlignment(Element.ALIGN_CENTER);
			document.add(cosa_dichiara);
			
			Paragraph info = new Paragraph(&quot;Esente da imposta di bollo ai sensi dell'art. &quot; +
					&quot;37 D.P.R. 28 dicembre 2000, n. 455\n\n\n\n&quot;, new Font(Font.HELVETICA, 10, Font.NORMAL));
			info.setAlignment(Element.ALIGN_CENTER);
			document.add(info);
			
			GregorianCalendar gc = new GregorianCalendar();
			int gg = gc.get(GregorianCalendar.DATE);
			int mm = gc.get(GregorianCalendar.MONTH) + 1;
			int year = gc.get(GregorianCalendar.YEAR);
			Paragraph sdata = new Paragraph(&quot;Data: &quot;+gg+&quot;/&quot;+mm+&quot;/&quot;+year, new Font(Font.HELVETICA, 14, Font.NORMAL));
			sdata.setAlignment(Element.ALIGN_LEFT);
			document.add(sdata);
			
			Paragraph firma = new Paragraph(&quot;___________________\nFirma del dichiarante&quot;, new Font(Font.HELVETICA, 14, Font.NORMAL));
			firma.setAlignment(Element.ALIGN_RIGHT);
			document.add(firma);
			
			document.close();
		} catch(DocumentException e) {
			e.printStackTrace();
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC170</id>
      <content>package Servlet;
import Bean.CartaIdentita;
import Bean.Cittadino;
import DB.*;
import Manager.AccessManager;
import Manager.CittadinoManager;
import Manager.NucleoFamiliareManager;

import java.io.*;
import java.util.GregorianCalendar;
import javax.servlet.*;
import javax.servlet.http.*;

import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.Element;
import com.lowagie.text.Font;
import com.lowagie.text.PageSize;
import com.lowagie.text.Paragraph;
import com.lowagie.text.pdf.PdfPCell;
import com.lowagie.text.pdf.PdfPTable;
import com.lowagie.text.pdf.PdfWriter;

/**
* La classe ServletCreaPdfCittadino un file PDF in base ai dati ricevuti da una pagina JSP
* La classe non ha nessuna dipendenza
* @author Christian Ronca
*/

public class ServletCreaPdfCittadino extends HttpServlet {
	private static final long serialVersionUID = -168526506138896791L;
	private HttpSession session;
	
	public void doPost(HttpServletRequest request, HttpServletResponse response) 
		throws ServletException, IOException {
		session = request.getSession();
		
		try {
			GregorianCalendar gc = new GregorianCalendar();
			int gg = gc.get(GregorianCalendar.DATE);
			int mm = gc.get(GregorianCalendar.MONTH) + 1;
			int year = gc.get(GregorianCalendar.YEAR);
			String now = &quot;&quot; + year + mm + gg;
			String inout = &quot;&quot;;
			
			String nome_comune			= request.getParameter(&quot;comunename&quot;).toUpperCase();
			String nome					= request.getParameter(&quot;name&quot;).toUpperCase();
			String surname				= request.getParameter(&quot;surname&quot;).toUpperCase();
			String name_citta			= request.getParameter(&quot;citta&quot;).toUpperCase();
			String gg_date				= request.getParameter(&quot;gg&quot;);
			String mm_date				= request.getParameter(&quot;mm&quot;);
			String aa_date				= request.getParameter(&quot;aa&quot;);
			String newcomune			= request.getParameter(&quot;newcomune&quot;).toUpperCase();
			String indir				= request.getParameter(&quot;via&quot;).toUpperCase();
			String numero_civico		= request.getParameter(&quot;civico&quot;);
			String indirnew				= request.getParameter(&quot;newvia&quot;).toUpperCase();
			String num_civnew			= request.getParameter(&quot;num&quot;);
			String pref					= request.getParameter(&quot;pref&quot;);
			String tel					= request.getParameter(&quot;tel&quot;);
			String cntlr				= request.getParameter(&quot;radio&quot;);
			String check				= request.getParameter(&quot;check&quot;);
			
			String parent1				= request.getParameter(&quot;parentela1&quot;).toUpperCase();
			String surname1				= request.getParameter(&quot;surname1&quot;).toUpperCase();
			String name1				= request.getParameter(&quot;name1&quot;).toUpperCase();
			String luogo1				= request.getParameter(&quot;luogo1&quot;).toUpperCase();
			String gg1					= request.getParameter(&quot;gg1&quot;);
			String mm1					= request.getParameter(&quot;mm1&quot;);
			String aa1					= request.getParameter(&quot;aa1&quot;);
			String parent2				= request.getParameter(&quot;parentela2&quot;).toUpperCase();
			String surname2				= request.getParameter(&quot;surname2&quot;).toUpperCase();
			String name2				= request.getParameter(&quot;name2&quot;).toUpperCase();
			String luogo2				= request.getParameter(&quot;luogo2&quot;).toUpperCase();
			String gg2					= request.getParameter(&quot;gg2&quot;);
			String mm2					= request.getParameter(&quot;mm2&quot;);
			String aa2					= request.getParameter(&quot;aa2&quot;);
			String parent3				= request.getParameter(&quot;parentela3&quot;).toUpperCase();
			String surname3				= request.getParameter(&quot;surname3&quot;).toUpperCase();
			String name3				= request.getParameter(&quot;name3&quot;).toUpperCase();
			String luogo3				= request.getParameter(&quot;luogo3&quot;).toUpperCase();
			String gg3					= request.getParameter(&quot;gg3&quot;);
			String mm3					= request.getParameter(&quot;mm3&quot;);
			String aa3					= request.getParameter(&quot;aa3&quot;);
			String parent4				= request.getParameter(&quot;parentela4&quot;).toUpperCase();
			String surname4				= request.getParameter(&quot;surname4&quot;).toUpperCase();
			String name4				= request.getParameter(&quot;name4&quot;).toUpperCase();
			String luogo4				= request.getParameter(&quot;luogo4&quot;).toUpperCase();
			String gg4					= request.getParameter(&quot;gg4&quot;);
			String mm4					= request.getParameter(&quot;mm4&quot;);
			String aa4					= request.getParameter(&quot;aa4&quot;);
			String parent5				= request.getParameter(&quot;parentela5&quot;).toUpperCase();
			String surname5				= request.getParameter(&quot;surname5&quot;).toUpperCase();
			String name5				= request.getParameter(&quot;name5&quot;).toUpperCase();
			String luogo5				= request.getParameter(&quot;luogo5&quot;).toUpperCase();
			String gg5					= request.getParameter(&quot;gg5&quot;);
			String mm5					= request.getParameter(&quot;mm5&quot;);
			String aa5					= request.getParameter(&quot;aa5&quot;);
			String parent6				= request.getParameter(&quot;parentela6&quot;).toUpperCase();
			String surname6				= request.getParameter(&quot;surname6&quot;).toUpperCase();
			String name6				= request.getParameter(&quot;name6&quot;).toUpperCase();
			String luogo6				= request.getParameter(&quot;luogo6&quot;).toUpperCase();
			String gg6					= request.getParameter(&quot;gg6&quot;);
			String mm6					= request.getParameter(&quot;mm6&quot;);
			String aa6					= request.getParameter(&quot;aa6&quot;);
			
			String nome11				= request.getParameter(&quot;nome11&quot;).toUpperCase();
			String nome12				= request.getParameter(&quot;nome12&quot;).toUpperCase();
			String rapporto				= request.getParameter(&quot;rapporto&quot;).toUpperCase();
			String indirizzo			= request.getParameter(&quot;indirizzo&quot;).toUpperCase();
			String num_civico1			= request.getParameter(&quot;num_civico1&quot;);
			String prec_res				= request.getParameter(&quot;prec_res&quot;).toUpperCase();
			String ab_libera			= request.getParameter(&quot;abitaz&quot;);
			String abilita_cod_doc		= request.getParameter(&quot;cod_doc&quot;);
			String cod_documento		= request.getParameter(&quot;cod_documento&quot;);
			String nametab1				= request.getParameter(&quot;nametab1&quot;).toUpperCase();
			String surnametab1			= request.getParameter(&quot;surnametab1&quot;).toUpperCase();
			String nametab2				= request.getParameter(&quot;nametab2&quot;).toUpperCase();
			String surnametab2			= request.getParameter(&quot;surnametab2&quot;).toUpperCase();
			String nametab3				= request.getParameter(&quot;nametab3&quot;).toUpperCase();
			String surnametab3			= request.getParameter(&quot;surnametab3&quot;).toUpperCase();
			String nametab4				= request.getParameter(&quot;nametab4&quot;).toUpperCase();
			String surnametab4			= request.getParameter(&quot;surnametab4&quot;).toUpperCase();
			String nametab5				= request.getParameter(&quot;nametab5&quot;).toUpperCase();
			String surnametab5			= request.getParameter(&quot;surnametab5&quot;).toUpperCase();
			String nametab6				= request.getParameter(&quot;nametab6&quot;).toUpperCase();
			String surnametab6			= request.getParameter(&quot;surnametab6&quot;).toUpperCase();
			String nametab7				= request.getParameter(&quot;nametab7&quot;).toUpperCase();
			String surnametab7			= request.getParameter(&quot;surnametab7&quot;).toUpperCase();
			
			cntlr = &quot;stesso&quot;;
			if(cntlr.equals(&quot;stesso&quot;)) {
				inout = &quot;interno&quot;;
			} else {
				inout = &quot;altro&quot;;
			}
			
			Document document = new Document(PageSize.A4);
			PdfWriter.getInstance(document, response.getOutputStream());
			FileOutputStream fout = new FileOutputStream(&quot;webapps//myDocs//docs//&quot; + now +&quot;_2345_&quot; + inout +&quot;.pdf&quot;);
			PdfWriter.getInstance(document, fout);
			response.setContentType(&quot;application/pdf&quot;);
			document.open();
			
			Paragraph spazio = new Paragraph(&quot;\n&quot;);
			Paragraph anagrafe_comune = new Paragraph(&quot;Anagrafe del comune di &quot; + nome_comune, new Font(Font.HELVETICA, 10, Font.BOLD));
			anagrafe_comune.setAlignment(Element.ALIGN_RIGHT);
			document.add(anagrafe_comune);
			
			Paragraph oggetto = new Paragraph(&quot;OGGETTO: DICHIARAZIONE DI CAMBIAMENTO DI ABITAZIONE&quot;, new Font(Font.HELVETICA, 12, Font.BOLD));
			oggetto.setAlignment(Element.ALIGN_CENTER);
			document.add(oggetto);
			
			Paragraph sottoscritto = new Paragraph(&quot; Io sottoscritto/a &quot; + surname + &quot; &quot; + nome + &quot; nato/a in &quot; + name_citta +&quot; il &quot; + gg_date+&quot;/&quot;+mm_date+&quot;/&quot;+aa_date + 
					&quot; già residente in via &quot; + indir +&quot; &quot;+ numero_civico + &quot; dichiaro, ai sensi e per gli effetti del combinato disposto dagli articoli 10,&quot; +
					&quot; lettera a) e 13 del D.P.R. 30/05/1989, n 223 di essermi trasferito nel comune di &quot;+ newcomune +&quot; in via &quot; + indirnew + &quot; &quot; +num_civnew + &quot; tel: &quot; + pref + &quot; &quot; + tel +
					&quot; unitamente ai seguenti familiari/conviventi:\n &quot;);
			sottoscritto.setAlignment(Element.ALIGN_JUSTIFIED);
			document.add(sottoscritto);
			
			//tabella stato di famiglia
			PdfPTable sf = new PdfPTable(5);
			sf.setWidthPercentage(100);
			sf.addCell(new Paragraph(&quot;PARENTELA&quot;));
			sf.addCell(new Paragraph(&quot;NOME&quot;));
			sf.addCell(new Paragraph(&quot;COGNOME&quot;));
			sf.addCell(new Paragraph(&quot;LUOGO DI NASCITA&quot;));
			sf.addCell(new Paragraph(&quot;DATA&quot;));
			sf.addCell(new Paragraph(parent1));
			sf.addCell(new Paragraph(surname1));
			sf.addCell(new Paragraph(name1));
			sf.addCell(new Paragraph(luogo1));
			sf.addCell(new Paragraph(gg1+&quot;/&quot;+mm1+&quot;/&quot;+aa1));
			sf.addCell(new Paragraph(parent2));
			sf.addCell(new Paragraph(surname2));
			sf.addCell(new Paragraph(name2));
			sf.addCell(new Paragraph(luogo2));
			sf.addCell(new Paragraph(gg2+&quot;/&quot;+mm2+&quot;/&quot;+aa2));
			document.add(sf);
			
			Paragraph mendace = new Paragraph(&quot;Dichiaro, ai sensi e per gli effetti di cui art. 46 e 47 del DPR 445/00 e pienamente consapevole &quot; +
					&quot;delle responsabilità civili e penali previste in caso di dichiarazione mendace che:\n\n&quot;);
			mendace.setAlignment(Element.ALIGN_JUSTIFIED);
			document.add(mendace);
			
			if(ab_libera.equals(&quot;si&quot;)) {
				Paragraph ab = new Paragraph(&quot; - l'abitazione nella quale mi sono trasferito/a è libera da persone e/o cose;\n\n\n&quot;);
				document.add(ab);
			} else {
				Paragraph occ = new Paragraph(&quot; - è occupata da terze parti, sotto riportate: \n\n&quot;);
				document.add(occ);
				PdfPTable altri_occupanti = new PdfPTable(2);
				altri_occupanti.setWidthPercentage(100);
				altri_occupanti.addCell(new Paragraph(&quot;NOME&quot;));
				altri_occupanti.addCell(new Paragraph(&quot;COGNOME&quot;));
				altri_occupanti.addCell(new Paragraph(nametab1));
				altri_occupanti.addCell(new Paragraph(surnametab1));
				altri_occupanti.addCell(new Paragraph(nametab2));
				altri_occupanti.addCell(new Paragraph(surnametab2));
				altri_occupanti.addCell(new Paragraph(nametab3));
				altri_occupanti.addCell(new Paragraph(surnametab3));
				altri_occupanti.addCell(new Paragraph(nametab4));
				altri_occupanti.addCell(new Paragraph(surnametab4));
				altri_occupanti.addCell(new Paragraph(nametab5));
				altri_occupanti.addCell(new Paragraph(surnametab5));
				altri_occupanti.addCell(new Paragraph(nametab6));
				altri_occupanti.addCell(new Paragraph(surnametab6));
				altri_occupanti.addCell(new Paragraph(nametab7));
				altri_occupanti.addCell(new Paragraph(surnametab7));
				document.add(altri_occupanti);
				
				if(check != null) {
					Paragraph p = new Paragraph(&quot;\nche tra il/la Sig./ra &quot; + nome11 + &quot; ed il/la Sig./ra &quot; + nome12 +&quot; sussiste il seguente rapporto di: &quot; +rapporto + &quot;\n\n&quot;);
					document.add(p);
				} else {
					Paragraph p1 = new Paragraph(&quot;\nche non sussiste nessun rapporto di parentela con le persoche che occupano già l'alloggio e quelle che vi sono trasferite\n\n&quot;);
					document.add(p1);
				}
			}

			Paragraph sdata = new Paragraph(&quot;Data: &quot;+gg+&quot;/&quot;+mm+&quot;/&quot;+year, new Font(Font.HELVETICA, 12, Font.NORMAL));
			sdata.setAlignment(Element.ALIGN_LEFT);
			document.add(sdata);
			
			Paragraph firma_dichiarante = new Paragraph(&quot;_________________\nFirma del dichiarante\n\n&quot;, new Font(Font.HELVETICA, 12, Font.NORMAL));
			firma_dichiarante.setAlignment(Element.ALIGN_RIGHT);
			document.add(firma_dichiarante);
			
			document.close();
		} catch(Exception e) {
			e.printStackTrace();
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC171</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Manager.AccessManager;
import Manager.AdminManager;
import Bean.Accesso;
import Bean.Amministratore;
import DB.DbException;
/**
* La classe ServletEliminaAmministratore ricerca ed elimina un amministratore
* La classe ServletEliminaAmministratore non ha dipendenze
* @author Federico Cinque
*/
public class ServletEliminaAmministratore extends HttpServlet{

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException{
		HttpSession session = request.getSession();
		if(session!=null){ //Se la sessione è nulla effettua il redirect alla pagina di autenticazione
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
				//Se gli attributi di sessione amm e acc sono nulli devo effettuare la ricerca
				if(session.getAttribute(&quot;amm&quot;)==null &amp;&amp; session.getAttribute(&quot;acc&quot;)==null){
					String matricola = request.getParameter(&quot;matricola&quot;);
					AdminManager AdM = new AdminManager();
					Amministratore am = AdM.ricercaAdminByMatricola(matricola);
					if(am != null){
						session.setAttribute(&quot;amm&quot;, am);

						AccessManager AM = new AccessManager();
						Accesso ac = AM.getAccesso(am.getLogin());
						session.setAttribute(&quot;acc&quot;, ac);

						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=cancella&amp;page=amministratore&quot;); 
						rd.forward(request,response);
					}
					else{
						ris=&quot;La matricola non corrisponde ad un amministratore&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;); 
						rd.forward(request,response);
					}
				}
				else{	//Se gli attributi sono presenti procedo con la cancellazione

					AccessManager AM = new AccessManager();
					AdminManager AdM = new AdminManager();

					Accesso ac = (Accesso) session.getAttribute(&quot;acc&quot;);
					Amministratore am = (Amministratore) session.getAttribute(&quot;amm&quot;);

					String matricola = am.getMatricola();
					String login = ac.getLogin();

					String risCanc = AdM.eliminaAmministratore(matricola);	//provo ad effettuare la cancellazione

					if(risCanc.equals(&quot;ok&quot;)){ // controllo che l'amministratore non è unico ed è stato cancellato
						if(AM.eliminaAccesso(login)){ //elimina l'accesso corrspondente
							ris=&quot;ok&quot;;
							request.setAttribute(&quot;ris&quot;, ris);
							rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 
						}
						else{
							ris=&quot;fallita&quot;;
							request.setAttribute(&quot;ris&quot;, ris);
							rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
						}
					}
					else{
						if(risCanc.equals(&quot;unico&quot;)) //se l'amministratore è unico non è stato cancellato
							ris=&quot;Non si pu cancellare l'ultimo amministratore&quot;;
						else
							ris=&quot;fallita&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
					}
					rd.forward(request,response);
					session.removeAttribute(&quot;amm&quot;);
					session.removeAttribute(&quot;acc&quot;);
				}
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC172</id>
      <content>package Servlet;

import java.io.IOException;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Manager.AccessManager;
import Manager.CIManager;
import Manager.CittadinoManager;
import Manager.NucleoFamiliareManager;
import Bean.Accesso;
import Bean.CartaIdentita;
import Bean.Cittadino;
import Bean.NucleoFamiliare;
import DB.DbException;
/**
* La classe ServletEliminaCittadino ricerca ed elimina un cittadino
* La classe ServletEliminaCittadino non ha dipendenze
* @author Federico Cinque
*/
public class ServletEliminaCittadino extends HttpServlet{

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException{
		HttpSession session = request.getSession();
		if(session!=null){	//Se la sessione è nulla effettua il redirect alla pagina di autenticazione
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
				//Se gli attributi di sessione c e acc sono nulli devo effettuare la ricerca
				if(session.getAttribute(&quot;c&quot;)==null &amp;&amp; session.getAttribute(&quot;acc&quot;)==null){
					String cod = request.getParameter(&quot;ci&quot;).toUpperCase();
					CIManager CIM = new CIManager();
					CittadinoManager CM = new CittadinoManager();
					CartaIdentita CI = CIM.getCartaByNumero(cod);

					if(CI!=null){
						Cittadino c = CM.getCittadinoById(CI.id());
						session.setAttribute(&quot;c&quot;, c);

						AccessManager AM = new AccessManager();
						Accesso ac = AM.getAccesso(c.getLogin());
						session.setAttribute(&quot;acc&quot;, ac);

						NucleoFamiliareManager NFM = new NucleoFamiliareManager();
						int componenti = NFM.getNComponentiNucleo(c.getNucleoFamiliare());
						NucleoFamiliare nf = NFM.getNucleo(c.getNucleoFamiliare());
						if(componenti&gt;1 &amp;&amp; nf.getCapoFamiglia()== c.getIdCittadino()){
							String nc = &quot;si&quot;; 
							session.setAttribute(&quot;newCapo&quot;, nc);
						}

						sc = getServletContext();
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=cancella&amp;page=cittadino&quot;); 
						rd.forward(request,response);
					}
					else{
						ris=&quot;Siamo spiacenti, il codice della carta d'identit non è presente nel database&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
					}
				}
				else{//Se gli attributi sono presenti procedo con la cancellazione
					AccessManager AM = new AccessManager();
					CittadinoManager CM = new CittadinoManager();

					Accesso ac = (Accesso) session.getAttribute(&quot;acc&quot;);
					Cittadino c = (Cittadino) session.getAttribute(&quot;c&quot;);

					String login = ac.getLogin();

					if(request.getParameter(&quot;ci&quot;).equals(&quot;&quot;)){	//Se non c'è il codice della carta d'identit
																//il cittadino da cancellare è solo nel nucleo familiare
						if(AM.eliminaAccesso(login) &amp;&amp; CM.cancellaCittadino(c.getIdCittadino())){	//elimina il cittadino e l'accesso 
																									//controllando che l'esito sia positivo
							NucleoFamiliareManager NFM = new NucleoFamiliareManager();
							NFM.getNComponentiNucleo(c.getNucleoFamiliare());
							ris=&quot;ok&quot;;
							request.setAttribute(&quot;ris&quot;, ris);
							rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 
						}
						else{
							ris=&quot;fallita&quot;;
							request.setAttribute(&quot;ris&quot;, ris);
							rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
						}
					}
					else{	//Se è presente un codice devo sostituire il capo famiglia
						NucleoFamiliareManager NFM = new NucleoFamiliareManager();
						CIManager CIM = new CIManager();
						CartaIdentita CI = CIM.getCartaByNumero(request.getParameter(&quot;ci&quot;)); 
						if(CI!=null){	//Controllo che il nuovo capo famiglia esiste nel db
							Cittadino newCapo = CM.getCittadinoById(CI.id());
							NFM.setCapoFamiglia(c.getNucleoFamiliare(), newCapo.getIdCittadino()); //modifico il capo famiglia del nucleo
							if(CM.cancellaCittadino(c.getIdCittadino())){//elimina il cittadino e l'accesso 
																								//controllando che l'esito sia positivo
								NFM.decrementaComponenti(c.getNucleoFamiliare());	// Decremento il numero di componenti del nucleo
								AM.eliminaAccesso(login);
								ris=&quot;ok&quot;;
								request.setAttribute(&quot;ris&quot;, ris);
								rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 
							}
							else{
								ris=&quot;fallita&quot;;
								request.setAttribute(&quot;ris&quot;, ris);
								rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
							}
						}
						else{
							ris=&quot;Siamo spiacenti, il codice della carta d'identità del nuovo capo famiglia non è presente nel database&quot;;
							request.setAttribute(&quot;ris&quot;, ris);
							rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
						}
					}
					rd.forward(request,response);
					session.removeAttribute(&quot;c&quot;);
					session.removeAttribute(&quot;acc&quot;);
					session.removeAttribute(&quot;newCapo&quot;);
				}
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC173</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Manager.AccessManager;
import Manager.ImpiegatoManager;
import Bean.Accesso;
import Bean.Impiegato;
import DB.DbException;
/**
* La classe ServletEliminaImpiegato ricerca ed elimina un impiegato
* La classe ServletEliminaImpiegato non ha dipendenze
* @author Federico Cinque
*/
public class ServletEliminaImpiegato extends HttpServlet{

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException{
		HttpSession session = request.getSession();
		if(session!=null){	//Se la sessione è nulla effettua il redirect alla pagina di autenticazione
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
				//Se gli attributi di sessione amm e acc sono nulli devo effettuare la ricerca
				if(session.getAttribute(&quot;amm&quot;)==null &amp;&amp; session.getAttribute(&quot;acc&quot;)==null){
					String matricola = (String) request.getParameter(&quot;matricola&quot;);
					ImpiegatoManager IM = new ImpiegatoManager();
					Impiegato imp = IM.ricercaImpiegatoByMatricola(matricola);
					if(imp != null){
					session.setAttribute(&quot;amm&quot;, imp);

					AccessManager AM = new AccessManager();
					Accesso ac = AM.getAccesso(imp.getLogin());
					session.setAttribute(&quot;acc&quot;, ac);

					rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=cancella&amp;page=impiegato&quot;); 
					rd.forward(request,response);
					}
					else{
						ris=&quot;La matricola non corrisponde ad un impiegato&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;); 
						rd.forward(request,response);
					}
				}
				else{	//Se gli attributi sono presenti procedo con la cancellazione

					AccessManager AM = new AccessManager();
					ImpiegatoManager IM = new ImpiegatoManager();

					Impiegato imp = (Impiegato) session.getAttribute(&quot;amm&quot;);

					String matricola = imp.getMatricola();
					String login = imp.getLogin();
					
					if(IM.eliminaImpiegato(matricola) &amp;&amp; AM.eliminaAccesso(login)){ //elimina l'impiegato e l'accesso 
																					//controllando che l'esito sia positivo
						ris=&quot;ok&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 
					}
					else{
						ris=&quot;fallita&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
					}
					
					rd.forward(request,response);
					session.removeAttribute(&quot;amm&quot;);
					session.removeAttribute(&quot;acc&quot;);
				}
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC174</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import Manager.AccessManager;
import Manager.AdminManager;
import Bean.Accesso;
import Bean.Amministratore;
import DB.DbException;
/**
* La classe ServletInserisciAmministratore inserisce un amministratore nel database
* La classe ServletInserisciAmministratore non ha dipendenze
* @author Federico Cinque
*/
public class ServletInserisciAmministratore extends HttpServlet {
	private String nome;
	private String cognome;
	private String email;
	private String matricola;
	private String login;
	private String password;
	private String tipo;

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();

		if(session!=null){	//Se la sessione + nulla effettua il redirect alla pagina di autenticazione
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
				nome = request.getParameter(&quot;nome&quot;);
				cognome = request.getParameter(&quot;cognome&quot;);
				email = request.getParameter(&quot;email&quot;);
				matricola = request.getParameter(&quot;matricola&quot;);
				login = request.getParameter(&quot;login&quot;);
				password = request.getParameter(&quot;password&quot;);
				tipo = request.getParameter(&quot;tipo&quot;);

				AccessManager AM = new AccessManager();
				AdminManager AdM = new AdminManager();

				Accesso ac = new Accesso(login,password,tipo);
				Amministratore am = new Amministratore(nome,cognome,matricola,email,login);

				rd = null;
				sc = getServletContext();

				if(AM.inserisciAccesso(ac) &amp;&amp; AdM.inserisciAdmin(am)){ //inserisco idati relativi all'accesso e all'amministratore
																		//controllando l'esito positivo
					ris=&quot;ok&quot;;
					request.setAttribute(&quot;ris&quot;, ris);
					rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 
				}
				else{
					ris=&quot;fallita&quot;;
					request.setAttribute(&quot;ris&quot;, ris);
					rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				}
				rd.forward(request,response);
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC175</id>
      <content>package Servlet;

import java.io.IOException;
import java.util.Date;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Bean.Cittadino;
import Bean.NucleoFamiliare;
import DB.DbException;
import Manager.CittadinoManager;
import Manager.NucleoFamiliareManager;
/**
* La classe ServletInserisciCittadino inserisce un cittadino nel database
* La classe ServletInserisciCittadino non ha dipendenze
* @author Federico Cinque
*/
public class ServletInserisciCittadino extends HttpServlet {

	private String nome;
	private String cognome;
	private String cf;
	private int giorno;
	private int mese;
	private int anno;
	private Date dataN = new Date();
	private String luogoN;
	private String email;
	private boolean advertise;
	private int idNF;
	private String login;
	private String tipo;
	private Cittadino cittadino;
	NucleoFamiliareManager NFM;

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();
		if(session!=null){	//Se la sessione è nulla effettua il redirect alla pagina di autenticazione
			RequestDispatcher rd = null;
			ServletContext sc = getServletContext();
			String ris;
			try{
				nome = request.getParameter(&quot;nome&quot;);
				cognome = request.getParameter(&quot;cognome&quot;);
				cf = request.getParameter(&quot;cf&quot;).toUpperCase();
				giorno = Integer.parseInt(request.getParameter(&quot;gg&quot;));
				mese = Integer.parseInt(request.getParameter(&quot;mm&quot;));
				anno = Integer.parseInt(request.getParameter(&quot;aa&quot;));
				dataN.setDate(giorno);
				dataN.setMonth(mese);
				dataN.setYear(anno);
				luogoN = request.getParameter(&quot;ln&quot;);
				if(request.getParameter(&quot;email&quot;)!=null)
					email = request.getParameter(&quot;email&quot;);
				else
					email= &quot;&quot;;
				advertise = false;
				idNF = Integer.parseInt(request.getParameter(&quot;nucleof&quot;));
				login = null;
				tipo = &quot;Cittadino&quot;;

				CittadinoManager CM = new CittadinoManager();
				NFM = new NucleoFamiliareManager();

				cittadino = new Cittadino(0,cf,cognome,nome,dataN,luogoN,email,advertise,idNF,login);

				if(idNF==0){	//Se l'id del nucleo familiare è zero, devo creare un nuovo nucleo
					
					int idC = CM.inserisciCittadino(cittadino); //inserisco il cittadino nel db
					cittadino.setIdCittadino(idC);
					idNF=creaNucleoF(); //Salvo l'id del nuovo nucleo
					cittadino.setNucleoFamiliare(idNF); //setto l'id del nucleo del cittadino
					CM.modificaNucleoFamiliare(cittadino.getIdCittadino(), idNF);
					if(idNF!=0 &amp;&amp; idC!=0){ //Se gli id restituiti sono diversi da zero l'operazione è andata a buon fine
						ris=&quot;ok&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 
					}
					else{
						ris=&quot;fallita&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
					}
				}
				else{	// Se l'id del nucleo familiare non è zero, devo aggiungere il cittadino ad un nucleo esistente
					if(NFM.controllaidFamiglia(idNF)){	//controllo l'esistenza del nucleo nel db
						NFM.incrementaComponenti(idNF);	//incremento i componenti del nucleo
						int idC=0;
						if((idC = CM.inserisciCittadino(cittadino))!=0){ //inserisco il cittadino nel db e controllo se l'esito è positivo
							cittadino.setIdCittadino(idC);
							ris=&quot;ok&quot;;
							request.setAttribute(&quot;ris&quot;, ris);
							rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;);
						}
						else{
							ris=&quot;Errore inserimento cittadino&quot;;
							request.setAttribute(&quot;ris&quot;, ris);
							rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
						}
					}
					else{
						ris=&quot;Id non presente&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
					}
				}
				rd.forward(request,response);
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}

	private int creaNucleoF() {
		NucleoFamiliare nf = new NucleoFamiliare();
		nf.setCapoFamiglia(cittadino.getIdCittadino());
		nf.setIdNucleoFamiliare(0);
		nf.setNComponenti(1);
		return NFM.inserisciNucleo(nf);
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC176</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Manager.AccessManager;
import Manager.ImpiegatoManager;
import Bean.Accesso;
import Bean.Impiegato;
import DB.DbException;
/**
* La classe ServletInserisciImpiegato inserisce un impiegato nel database
* La classe ServletInserisciImpiegato non ha dipendenze
* @author Federico Cinque
*/
public class ServletInserisciImpiegato extends HttpServlet {
	private String nome;
	private String cognome;
	private String email;
	private String matricola;
	private String login;
	private String password;
	private String tipo;

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();
		ServletContext sc = getServletContext();
		RequestDispatcher rd = null;
		String ris;
		if(session!=null){	//Se la sessione é nulla effettua il redirect alla pagina di autenticazione
			try{
				nome = request.getParameter(&quot;nome&quot;);
				cognome = request.getParameter(&quot;cognome&quot;);
				email = request.getParameter(&quot;email&quot;);
				matricola = request.getParameter(&quot;matricola&quot;);
				login = request.getParameter(&quot;login&quot;);
				password = request.getParameter(&quot;password&quot;);
				tipo = request.getParameter(&quot;tipo&quot;);

				AccessManager AM = new AccessManager();
				ImpiegatoManager IdM = new ImpiegatoManager();

				Accesso ac = new Accesso(login,password,tipo);
				Impiegato am = new Impiegato(nome,cognome,matricola,email,login);

				if(AM.inserisciAccesso(ac) &amp;&amp; IdM.inserisciImpiegato(am)){	//inserisco idati relativi all'accesso e all'impiegato
																			//controllando l'esito positivo
					ris=&quot;ok&quot;;
					request.setAttribute(&quot;ris&quot;, ris);
					rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 

				}
				else{
					ris=&quot;fallita&quot;;
					request.setAttribute(&quot;ris&quot;, ris);
					rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				}
				rd.forward(request,response);
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC177</id>
      <content>package Servlet;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Manager.AccessManager;
import Manager.AdminManager;
import Manager.CIManager;
import Bean.Accesso;
import Bean.Amministratore;
import Bean.CartaIdentita;
import Bean.Cittadino;
import Manager.CittadinoManager;
import Bean.Impiegato;
import DB.DbException;
import Manager.ImpiegatoManager;
/**
* La classe ServletLogin effettua l'operazione di autenticazione di un utente nel sistema
* La classe ServletLogin non ha dipendenze
* @author Federico Cinque
*/
public class ServletLogin extends HttpServlet {

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		int flag = -1;
		String login = request.getParameter(&quot;login&quot;);
		String password = request.getParameter(&quot;password&quot;);
		String tipo = request.getParameter(&quot;tipo&quot;);

		HttpSession session = request.getSession(true);
		try{
			AccessManager AM = new AccessManager();
			String url;

			Accesso ac = AM.getAccesso(login);

			if(tipo!=null){	//Se tipo  diverso da null la servlet  stata invocata dal lato cittadino
				flag=0;
				if (AM.controllaAccesso(login, password) &amp;&amp; ac.getTipo().equals(&quot;Cittadino&quot;)){

					CittadinoManager CM = new CittadinoManager();
					Cittadino c = CM.getCittadinoByLogin(login);
					CIManager ciM=new CIManager();
					CartaIdentita ci=ciM.getCartaByIdCStri(c.getIdCittadino());
					session.setAttribute(&quot;c&quot;, c);
					session.setAttribute(&quot;ci&quot;, ci);
					url=&quot;/myDoc/user/home.jsp&quot;;
				}
				else
					url=&quot;/myDoc/user/home.jsp?error=e&quot;;
			}
			else{	//Se tipo  null la servlet  stata invocata dal lato amministratore/impiegato
				flag = 1;
				if (AM.controllaAccesso(login, password) &amp;&amp; !ac.getTipo().equals(&quot;Cittadino&quot;)){
					session.setAttribute(&quot;login&quot;, ac.getLogin());
					session.setAttribute(&quot;tipo&quot;, ac.getTipo());
					if(ac.getTipo().equals(&quot;Impiegato&quot;)){
						ImpiegatoManager IM = new ImpiegatoManager();
						Impiegato imp = IM.getImpiegatoByLogin(login);
						session.setAttribute(&quot;imp&quot;, imp);
					}
					else
						if(ac.getTipo().equals(&quot;Amministratore&quot;)){
							AdminManager AdM = new AdminManager();
							Amministratore am = AdM.getAmministratoreByLogin(login);
							session.setAttribute(&quot;am&quot;, am);
						}
					url=&quot;/myDoc/workers/index.jsp&quot;;
				}
				else
					url=&quot;/myDoc/workers/Accesso.jsp?error=e&quot;;
			}
			response.sendRedirect(url);
		}
		catch(DbException e){
			String url;
			if(flag==1)
				url=&quot;/myDoc/workers/Accesso.jsp?error=&quot;+e.getMessage();
			else
				url=&quot;/myDoc/user/home.jsp?error=&quot;+e.getMessage();
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC178</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import Bean.Cittadino;
/**
* La classe ServletLogout effettua l'operazione di logout di un utente dal sistema
* La classe ServletLogout non ha dipendenze
* @author Federico Cinque
*/
public class ServletLogout extends HttpServlet{
	public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();
		String url;
		Cittadino c = (Cittadino) session.getAttribute(&quot;c&quot;);

		if(c != null)
			url=&quot;/myDoc/user/home.jsp&quot;;
		else
			url=&quot;/myDoc/workers/Accesso.jsp&quot;;
		
		session.invalidate();
		response.sendRedirect(url);
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC179</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import Bean.Accesso;
import DB.DbException;
import Manager.AccessManager;
/**
* La classe ServletModificaAccesso che effettua l'operazione di modifica di un accesso
* La classe ServletModificaAccesso non ha dipendenze
* @author Federico Cinque
*/
public class ServletModificaAccesso extends HttpServlet{

	private String login;
	private String password;
	private String cpassword;
	private String tipo;

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();

		if(session!=null){	//Se la sessione é nulla effettua il redirect alla pagina di autenticazione
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
				login = request.getParameter(&quot;login&quot;);
				password = request.getParameter(&quot;password&quot;);
				cpassword = request.getParameter(&quot;cpassword&quot;);
				tipo = request.getParameter(&quot;tipo&quot;);

				AccessManager AM = new AccessManager();
				Accesso ac = new Accesso(login,password,tipo);

				if(AM.modificaAccesso(login, ac)){	//modifico i dati relativi all'accesso controllando che l'esito sia positivo
					ris=&quot;ok&quot;;
					request.setAttribute(&quot;ris&quot;, ris);
					if(ac.getTipo().equals(&quot;Cittadino&quot;))
						rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=riuscita&quot;);
					else
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 
				}
				else{
					ris=&quot;fallita&quot;;
					request.setAttribute(&quot;ris&quot;, ris);
					if(ac.getTipo().equals(&quot;Cittadino&quot;))
						rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=fallita&quot;);
					else
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				}
				rd.forward(request,response);
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{	//questa servlet viene invocata sia dal lato cittadino sia da amm/imp
				//quindi effettuo un controllo da quale url proviene la richiesta
				//cosi posso effettuare il redirect alla pagina corretta
			String from = request.getRequestURL().toString();
			String url;
			if(from.contains(&quot;user&quot;))
				url=&quot;/myDoc/user/home.jsp&quot;;
			else
				url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC180</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Manager.AccessManager;
import Manager.AdminManager;
import Bean.Accesso;
import Bean.Amministratore;
import DB.DbException;
/**
* La classe ServletModificaAmministratore che effettua l'operazione di modifica di un amministratore
* La classe ServletModificaAmministratore non ha dipendenze
* @author Federico Cinque
*/
public class ServletModificaAmministratore extends HttpServlet{

	private String nome;
	private String cognome;
	private String email;
	private String matricola;
	private String login;
	private String password;
	private String tipo;

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException{
		HttpSession session = request.getSession();
		if(session!=null){	//Se la sessione é nulla effettua il redirect alla pagina di autenticazione
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
				//Se gli attributi di sessione amm e acc sono nulli devo effettuare la ricerca
				if(session.getAttribute(&quot;amm&quot;)==null &amp;&amp; session.getAttribute(&quot;acc&quot;)==null){
					String matricola = request.getParameter(&quot;matricola&quot;);
					AdminManager AdM = new AdminManager();
					Amministratore am = AdM.ricercaAdminByMatricola(matricola);
					if(am != null){
						session.setAttribute(&quot;amm&quot;, am);

						AccessManager AM = new AccessManager();
						Accesso ac = AM.getAccesso(am.getLogin());
						session.setAttribute(&quot;acc&quot;, ac);

						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=modifica&amp;page=amministratore&quot;); 
						rd.forward(request,response);
					}
					else{
						ris=&quot;La matricola non corrisponde ad un amministratore&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;); 
						rd.forward(request,response);
					}
				}
				else{
					nome = request.getParameter(&quot;nome&quot;);
					cognome = request.getParameter(&quot;cognome&quot;);
					email = request.getParameter(&quot;email&quot;);
					matricola = request.getParameter(&quot;matricola&quot;);
					login = request.getParameter(&quot;login&quot;);
					password = request.getParameter(&quot;password&quot;);
					tipo = request.getParameter(&quot;tipo&quot;);

					AccessManager AM = new AccessManager();
					AdminManager AdM = new AdminManager();

					Accesso ac = new Accesso(login,password,tipo);
					Amministratore am = new Amministratore(nome,cognome,matricola,email,login);
					Amministratore amOld = (Amministratore) session.getAttribute(&quot;amm&quot;);
					
					if(AM.modificaAccesso(amOld.getLogin(), ac) &amp;&amp; AdM.modificaAdmin(amOld.getMatricola(), am)){ //procedo con la modifica dei dati
						//controllando l'esito
						ris=&quot;ok&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;);
					}
					else{
						ris=&quot;fallita&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
					}
					rd.forward(request,response);
					session.removeAttribute(&quot;amm&quot;);
					session.removeAttribute(&quot;acc&quot;);
				}
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC181</id>
      <content>package Servlet;

import java.io.IOException;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Bean.CartaIdentita;
import Bean.Cittadino;
import Bean.NucleoFamiliare;
import DB.DbException;
import Manager.CIManager;
import Manager.CittadinoManager;
import Manager.NucleoFamiliareManager;
/**
* La classe ServletModificaCittadino che effettua l'operazione di modifica di un cittadino
* La classe ServletModificaCittadino non ha dipendenze
* @author Federico Cinque
*/
public class ServletModificaCittadino extends HttpServlet{

	private String nome;
	private String cognome;
	private String email;
	private int idNF;
	private Cittadino cittadino;
	private NucleoFamiliareManager NFM;
	private CittadinoManager CM;

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException{
		HttpSession session = request.getSession();
		if(session!=null){	//Se la sessione é nulla effettua il redirect alla pagina di autenticazione
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
				//Se l'attributo di sessione citté nullo devo effettuare la ricerca
				if(session.getAttribute(&quot;citt&quot;)==null){
					CittadinoManager CM = new CittadinoManager();
					Cittadino c = null;
					String cod = request.getParameter(&quot;ci&quot;).toUpperCase();
					CIManager CIM = new CIManager();
					CM = new CittadinoManager();
					CartaIdentita CI = CIM.getCartaByNumero(cod);

					if(CI!=null){
						c = CM.getCittadinoById(CI.id());

						NucleoFamiliareManager NFM = new NucleoFamiliareManager();
						int componenti = NFM.getNComponentiNucleo(c.getNucleoFamiliare());
						NucleoFamiliare nf = NFM.getNucleo(c.getNucleoFamiliare());
						if(componenti&gt;1 &amp;&amp; nf.getCapoFamiglia()== c.getIdCittadino()){
							String nc = &quot;si&quot;; 
							session.setAttribute(&quot;newCapo&quot;, nc);
						}

						session.setAttribute(&quot;citt&quot;, c);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=modifica&amp;page=cittadino&quot;);
					}
					else{
						ris=&quot;Siamo spiacenti, il codice della carta d'identit noné presente nel database&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
					}
					rd.forward(request,response);
				}
				else{
					nome = request.getParameter(&quot;nome&quot;);
					cognome = request.getParameter(&quot;cognome&quot;);
					email = request.getParameter(&quot;email&quot;);
					if(request.getParameter(&quot;email&quot;)!=null)
						email = request.getParameter(&quot;email&quot;);
					else
						email= &quot;&quot;;
					idNF = Integer.parseInt(request.getParameter(&quot;nucleof&quot;));

					CM = new CittadinoManager();
					NFM = new NucleoFamiliareManager();

					cittadino = (Cittadino) session.getAttribute(&quot;citt&quot;);
					if(idNF==0){	//Se l'id del nucleoé zero devo creare un nuovo nucleo familiare per il cittadino
						if(NFM.getNucleo(cittadino.getNucleoFamiliare()).getCapoFamiglia() != cittadino.getIdCittadino()){
							NFM.decrementaComponenti(cittadino.getNucleoFamiliare());
							idNF=creaNucleoF();	//Salvo l'id del nuovo nucleo
							cittadino.setNucleoFamiliare(idNF);	//setto l'id del nucleo del cittadino
							//effettuo le modifiche dei dati controllando l'esito positivo
							if(	CM.modificaNucleoFamiliare(cittadino.getIdCittadino(), idNF) &amp;&amp;
									CM.modificaEmail(cittadino.getIdCittadino(),email) &amp;&amp;
									CM.modificaNome(cittadino.getIdCittadino(), nome) &amp;&amp;
									CM.modificaCognome(cittadino.getIdCittadino(), cognome) &amp;&amp;
									idNF!=0){
								ris=&quot;ok&quot;;
								request.setAttribute(&quot;ris&quot;, ris);
								rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 
							}
							else{
								ris=&quot;fallita&quot;;
								request.setAttribute(&quot;ris&quot;, ris);
								rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
							}
						}
						else{
							CIManager CIM = new CIManager();
							CartaIdentita CI = CIM.getCartaByNumero(request.getParameter(&quot;ci&quot;)); 
							if(CI!=null){	//Controllo che il nuovo capo famiglia esiste nel db
								Cittadino newCapo = CM.getCittadinoById(CI.id());
								NFM.setCapoFamiglia(cittadino.getNucleoFamiliare(), newCapo.getIdCittadino()); //modifico il capo famiglia del nucleo
								NFM.decrementaComponenti(cittadino.getNucleoFamiliare());
								idNF=creaNucleoF();	//Salvo l'id del nuovo nucleo
								cittadino.setNucleoFamiliare(idNF);	//setto l'id del nucleo del cittadino
								//effettuo le modifiche dei dati controllando l'esito positivo
								if(idNF!=0){
									if(	CM.modificaNucleoFamiliare(cittadino.getIdCittadino(), idNF) &amp;&amp;
											CM.modificaEmail(cittadino.getIdCittadino(),email) &amp;&amp;
											CM.modificaNome(cittadino.getIdCittadino(), nome) &amp;&amp;
											CM.modificaCognome(cittadino.getIdCittadino(), cognome)){
										ris=&quot;ok&quot;;
										request.setAttribute(&quot;ris&quot;, ris);
										rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 
									}
									else{
										ris=&quot;fallita&quot;;
										request.setAttribute(&quot;ris&quot;, ris);
										rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
									}
								}
								else{
									ris=&quot;Errore creazione nuovo nucleo&quot;;
									request.setAttribute(&quot;ris&quot;, ris);
									rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
								}
							}
							else{
								ris=&quot;Siamo spiacenti, il codice della carta d'identità non è presente nel db&quot;;
								request.setAttribute(&quot;ris&quot;, ris);
								rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
							}
						}
					}
					else{	// Se l'id del nucleo familiare noné zero, devo aggiungere il cittadino ad un nucleo esistente
						if(NFM.controllaidFamiglia(idNF)){	//controllo l'esistenza del nucleo nel db
							if(NFM.getNucleo(cittadino.getNucleoFamiliare()).getCapoFamiglia() != cittadino.getIdCittadino()){
								NFM.incrementaComponenti(idNF);	//incremento i componenti del nucleo
								cittadino.setNucleoFamiliare(idNF);	//setto l'id del nucleo del cittadino
								//effettuo le modifiche dei dati controllando l'esito positivo
								if(	CM.modificaNucleoFamiliare(cittadino.getIdCittadino(), idNF) &amp;&amp;
										CM.modificaEmail(cittadino.getIdCittadino(),email) &amp;&amp;
										CM.modificaNome(cittadino.getIdCittadino(), nome) &amp;&amp;
										CM.modificaCognome(cittadino.getIdCittadino(), cognome) &amp;&amp;
										idNF!=0){
									ris=&quot;ok&quot;;
									request.setAttribute(&quot;ris&quot;, ris);
									rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;);
								}
								else{
									ris=&quot;fallita&quot;;
									request.setAttribute(&quot;ris&quot;, ris);
									rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
								}
							}
							CIManager CIM = new CIManager();
							CartaIdentita CI = CIM.getCartaByNumero(request.getParameter(&quot;ci&quot;)); 
							if(CI!=null){	//Controllo che il nuovo capo famiglia esiste nel db
								Cittadino newCapo = CM.getCittadinoById(CI.id());
								NFM.setCapoFamiglia(cittadino.getNucleoFamiliare(), newCapo.getIdCittadino()); //modifico il capo famiglia del nucleo
								NFM.decrementaComponenti(cittadino.getNucleoFamiliare());
								cittadino.setNucleoFamiliare(idNF);	//setto l'id del nucleo del cittadino
								NFM.incrementaComponenti(idNF);
								//effettuo le modifiche dei dati controllando l'esito positivo
								if(	CM.modificaNucleoFamiliare(cittadino.getIdCittadino(), idNF) &amp;&amp;
										CM.modificaEmail(cittadino.getIdCittadino(),email) &amp;&amp;
										CM.modificaNome(cittadino.getIdCittadino(), nome) &amp;&amp;
										CM.modificaCognome(cittadino.getIdCittadino(), cognome)){
									ris=&quot;ok&quot;;
									request.setAttribute(&quot;ris&quot;, ris);
									rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 
								}
								else{
									ris=&quot;fallita&quot;;
									request.setAttribute(&quot;ris&quot;, ris);
									rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
								}
							}
							else{
								ris=&quot;Siamo spiacenti, il codice della carta d'identità del nuovo capofamiglia non è presente nel db&quot;;
								request.setAttribute(&quot;ris&quot;, ris);
								rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
							}
						}
						else{
							ris=&quot;Id non presente&quot;;
							request.setAttribute(&quot;ris&quot;, ris);
							rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
						}
					}
					rd.forward(request,response);
					session.removeAttribute(&quot;citt&quot;);
					session.removeAttribute(&quot;newCapo&quot;);
				}
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}

	private int creaNucleoF() {
		NucleoFamiliare nf = new NucleoFamiliare();
		nf.setCapoFamiglia(cittadino.getIdCittadino());
		nf.setIdNucleoFamiliare(0);
		nf.setNComponenti(1);
		return NFM.inserisciNucleo(nf);
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC182</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Manager.AccessManager;
import Manager.ImpiegatoManager;
import Bean.Accesso;
import Bean.Impiegato;
import DB.DbException;
/**
* La classe ServletModificaImpiegato che effettua l'operazione di modifica di un impiegato
* La classe ServletModificaImpiegato non ha dipendenze
* @author Federico Cinque
*/
public class ServletModificaImpiegato extends HttpServlet{

	private String nome;
	private String cognome;
	private String email;
	private String matricola;
	private String login;
	private String password;
	private String tipo;

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();
		if(session!=null){	//Se la sessioneè nulla effettua il redirect alla pagina di autenticazione
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
				//Se gli attributi di sessione amm e acc sono nulli devo effettuare la ricerca
				if(session.getAttribute(&quot;amm&quot;)==null &amp;&amp; session.getAttribute(&quot;acc&quot;)==null){
					matricola = request.getParameter(&quot;matricola&quot;);
					ImpiegatoManager IM = new ImpiegatoManager();
					Impiegato imp = IM.ricercaImpiegatoByMatricola(matricola);
					if(imp != null){
						session.setAttribute(&quot;amm&quot;, imp);

						AccessManager AM = new AccessManager();
						Accesso ac = AM.getAccesso(imp.getLogin());
						session.setAttribute(&quot;acc&quot;, ac);

						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=modifica&amp;page=impiegato&quot;); 
						rd.forward(request,response);
					}
					else{
						ris=&quot;La matricola non corrisponde ad un impiegato&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;); 
						rd.forward(request,response);
					}
				}
				else{
					nome = request.getParameter(&quot;nome&quot;);
					cognome = request.getParameter(&quot;cognome&quot;);
					email = request.getParameter(&quot;email&quot;);
					matricola = request.getParameter(&quot;matricola&quot;);
					login = request.getParameter(&quot;login&quot;);
					password = request.getParameter(&quot;password&quot;);
					tipo = request.getParameter(&quot;tipo&quot;);

					AccessManager AM = new AccessManager();
					ImpiegatoManager IM = new ImpiegatoManager();

					Accesso ac = new Accesso(login,password,tipo);
					Impiegato imp = new Impiegato(nome,cognome,matricola,email,login);
					Impiegato impOld = (Impiegato) session.getAttribute(&quot;amm&quot;);
					
					if(AM.modificaAccesso(impOld.getLogin(), ac) &amp;&amp; IM.modificaImpiegato(impOld.getMatricola(), imp)){	//procedo con la modifica dei dati
						//controllando l'esito
						ris=&quot;ok&quot;;
						request.setAttribute(&quot;ris&quot;, ris); 
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=riuscita&quot;); 

					}
					else{
						ris=&quot;fallita&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
					}
					rd.forward(request,response);
					session.removeAttribute(&quot;amm&quot;);
					session.removeAttribute(&quot;acc&quot;);
				}
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC183</id>
      <content>package Servlet;
import javax.servlet.http.*;
import javax.servlet.*;
import java.io.*;
import java.util.ArrayList;
import javax.swing.*;
import DB.DbCartaIdentita;
import DB.DbException;

public class ServletModificaResidenza extends HttpServlet{

	public void init(ServletConfig conf)throws ServletException{
		super.init(conf);
	}
	/**
	 * metodo che cerca i file contenenti
	 * le richieste di cambio di residenza
	 * da parte dei cittadini.Tale cartella viene
	 * salvata sul server su cui l'impiegato
	 * può accedervi per reperire le informazioni
	 * utili alla compilazione del modulo
	 * che deve essere registrato all'interno
	 * dell'archivio comunale 
	 */
	public class CercaFiles {
		//contatore usato per numerare i file ottenuti
		private int count = 0;

		private File to;
		private String interno;

		private File from;

		public CercaFiles(){
			//costruttore di default
		}

		public String main(int id_citizen,String date){
			//nel caso dell'impiegato la path è c:\\RichiesteCambioResidenza
			//directory dove cercare i file con determinate estensioni
			from = new File(&quot;C:\\RichiesteCambioResidenza&quot;);

			//nome del file da cercare. Ad esempio cerco un file di nome pippo inserirò pippo
			//se non specificato cercherà tutti i file con qualsiasi nome
			//mi salvo come stringa l'id del cittadino per poi confrontarla con
			//l'id del cittadino che mi arriva dal database per cercare il
			//file del cambio associato a quel cittadino
			String id_citt=String.valueOf(id_citizen);
			String dataric=date;

			String param=&quot;interno&quot;;
			String param1=&quot;esterno&quot;;
			//nome del file da cercare
			String nome = dataric+&quot;_&quot;+id_citt+&quot;_&quot;.concat(param);
			String nomefile2=dataric+&quot;_&quot;+id_citt+&quot;_&quot;.concat(param1);

			String[] splitter=nome.split(&quot;_&quot;); 

			//estensione del file da cercare. Ad esempio *.mp3 inseriro .mp3
			//se non specificato cercherà tutti i files con qualsiasi estensione
			String tipo = &quot;.pdf&quot;;

			File newfile=esploraFile(from,nome,tipo);
			if(newfile!=null){
				interno=&quot;interno&quot;;
			}else{
				newfile=esploraFile(from,nomefile2,tipo);
				if(newfile!=null){
					//file esterno
					interno=&quot;esterno&quot;;
				}
				else{
					interno=null;//file non presente
				}
			}
			return interno;
		}
		/**
		 * from è la cartella in cui cercare il
		 * file di nome &quot;nome&quot; e di tipo &quot;.pdf&quot;
		 * @param from
		 * @param nome
		 * @param tipo
		 */

		protected File esploraFile(File from, String nome, String tipo) {
			//utilizziamo per la ricerca un filtro
			File[] files = from.listFiles(new Filter(nome, tipo));
			//ordiniamo i file nella lista secondo la data
			if(files.length&gt;1||files.length==0){
				return null;
			}else{
				return files[0];

			}

		}

		class Filter implements FilenameFilter {
			//estensione del file
			private String tipo, nome;

			public Filter(String nome, String tipo) {
				this.nome = nome;
				this.tipo = tipo;
			}

			//accettiamo tutti i file con estensione s e le directory che non siano
			//nascoste
			public boolean accept(File dir, String file) {
				File f = new File(dir, file);

				//controllo sul tipo.
				//Ad esempio se cerco \&quot;pippo.txt\&quot; la indexOf(.txt) è uguale a 6 ed è uguale
				// ed è uguale a 10(\&quot;pippo.txt\&quot;.length()) - 4 (\&quot;.txt\&quot;.length)

				boolean flag1=true;
				if(tipo!=null &amp;&amp; tipo!=&quot;\\&quot;)
					flag1=(file.indexOf(tipo) == file.length()-tipo.length());

				//controllo sul nome
				//flag2 è true se il file contiene la parola cercata

				boolean flag2=true;
				if(nome!=null &amp;&amp; nome!=&quot;\\&quot;)
					flag2=file.toUpperCase().indexOf(nome.toUpperCase())!=-1;
				//ritorno i file che passano il controllo del tipo e del nome le directory

				return ( ( flag1 &amp;&amp; flag2 ) || f.isDirectory()) &amp;&amp; !f.isHidden();
			}
		}

		public void doPost(HttpServletRequest request,HttpServletResponse response)
		throws ServletException,IOException{

			//innanzitutto mi recupero la sessione di lavoro del cittadino
			HttpSession session=request.getSession();
			int idCittadino;
			String idtrovato;
			/**
			 * se la sessione è stata creata correttamente 
			 * all'accesso dell'impiegato, viene mandato in exe
			 * il metodo che controlla se sono presenti file pdf
			 * riguardanti il cambio di residenza interno o
			 * esterno richiesti dai cittadini
			 */	 
			if(session!=null){
				ServletContext sc=getServletContext();
				RequestDispatcher rd=null;
				String ris;
				try{
					/**
					 * (1)	cosa deve fare la servlet:
					 * 		deve prendere l'id del cittadino
					 * 		di cui ha inserito il codice della carta di identità
					 * 		dal form e lo passa al metodo main 
					 * 		per cercare il file corrispondente
					 */
					/**
					 * (2)	il codice della carta di identità e la data della richiesta
					 * 		li prende con request.getParameter
					 * 		salvandoli nelle apposite variabili,
					 * 		dopodichè viene chiamato il metodo che restituisce
					 * 		l'id di un cittadino dopo avergli 
					 * 		passato nome, cognome e codice_fiscale di
					 * 		quest'ultimo.
					 */
					String cod_carta=request.getParameter(&quot;cod_carta&quot;);
					String data=request.getParameter(&quot;year&quot;).concat(request.getParameter(&quot;month&quot;).concat(request.getParameter(&quot;day&quot;)));
					/**
					 * una volta salvati i parametri, li passo
					 * al metodo che restituisce l'id di questo
					 * particolare cittadino che ha inviato la
					 * richiesta di cambio di residenza e di cui
					 * se ne vuole cercare il file 
					 */
					DbCartaIdentita dbcarta=new DbCartaIdentita();
					idCittadino=dbcarta.ricercaCartaIdentitaByNumero(cod_carta).id();
					String risp;
					if(idCittadino==-1){
						risp=&quot;Non è possibile recuperare l'id del cittadino all'interno del database&quot;;
						response.sendRedirect(&quot;http://localhost:8080/E_ANCI/index.jsp?error=e&quot;);//da modificare i collegamenti
						request.setAttribute(&quot;risp&quot;, risp);
					}
					else{
						/**
						 * una volta conosciuto l'id del cittadino
						 * lo passo al metodo di ricerca del file
						 * ad esso corrispondente
						 */
						CercaFiles search=new CercaFiles();
						idtrovato=search.main(idCittadino,data);
						/**
						 * ora nella variabile idtrovato c'è l'esito della ricerca
						 * del file relativa ad un determinato cittadino 
						 * che ha inviato la richiesta di cambio di residenza.
						 * tale valore andrà controllato, se è true si lancia 
						 * all'impiegato il modulo da compilare per mantenere traccia 
						 * della richiesta dopo aver effettuato i controlli necessari
						 */
						if(idtrovato==null){
							ris=&quot;File della richiesta di cambio di residenza non trovato&quot;;
							request.setAttribute(&quot;ris&quot;, ris);
							rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);//da modificare i collegamenti
						}
						else
							if(idtrovato.equals(&quot;interno&quot;)){
								rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=pra&amp;page=modulone&quot;);//da modificare i collegamenti
							}
							else if(idtrovato.equals(&quot;esterno&quot;)){
								rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=pra&amp;page=modulone&quot;);//da modificare i collegamenti
							}
						rd.forward(request, response);
					}
				}catch(DbException e){
					ris=e.getMessage();
					request.setAttribute(&quot;ris&quot;, ris);
					rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);//da modificare i collegamenti
					rd.forward(request,response);
				}

			}else{
				String url=&quot;/workers/Accesso.jsp&quot;;//da modificare i collegamenti
				response.sendRedirect(url);
			}
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC184</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Bean.Accesso;
import DB.DbException;
import Manager.AccessManager;
/**
* La classe ServletMostraAccesso mostra i dati relativi all'accesso di un impieagto o amministratore
* La classe ServletMostraAccesso non ha dipendenze
* @author Federico Cinque
*/
public class ServletMostraAccesso extends HttpServlet{
	public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();

		if(session!=null){
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
			Accesso ac = null;
			AccessManager AM = new AccessManager();
			String login;

			login = (String) session.getAttribute(&quot;login&quot;);
			ac = AM.getAccesso(login);

			//inviare i dati
			rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=mostra&amp;page=accesso&quot;);

			request.setAttribute(&quot;accesso&quot;, ac);
			rd.forward(request,response);
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url;
			url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC185</id>
      <content>package Servlet;

import java.io.IOException;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Bean.Accesso;
import DB.DbException;
import Bean.Cittadino;
import Manager.AccessManager;
/**
* La classe ServletMostraAccessoA mostra i dati relativi all'accesso di un cittadino
* La classe ServletMostraAccessoA non ha dipendenze
* @author Federico Cinque
*/
public class ServletMostraAccessoA extends HttpServlet{
	public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();

		if(session!=null){
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
				Accesso ac = null;
				AccessManager AM = new AccessManager();
				String login;
				if(session.getAttribute(&quot;c&quot;)!=null){
					Cittadino c = (Cittadino) session.getAttribute(&quot;c&quot;);
					login=c.getLogin();
					ac = AM.getAccesso(login);
					rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=mostra&amp;page=accesso&quot;);
				}
				request.setAttribute(&quot;accesso&quot;, ac);
				rd.forward(request,response);
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url;
			url=&quot;/myDoc/user/home.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC186</id>
      <content>package Servlet;

import java.io.IOException;
import java.util.Random;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import Manager.AccessManager;
import Manager.CIManager;
import Manager.CittadinoManager;
import Bean.Accesso;
import Bean.CartaIdentita;
import Bean.Cittadino;
import DB.DbException;
/**
* La classe ServletRecuperoPassword gestisce l'operazione di recupero password per un cittadino
* La classe ServletRecuperoPassword non ha dipendenze
* @author Federico Cinque
*/
public class ServletRecuperoPassword extends HttpServlet{

	private String email;
	private String ci;
	private String login;
	private String tipo;

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		RequestDispatcher rd = null;
		ServletContext sc = getServletContext();
		String ris;

		try{
			ci = request.getParameter(&quot;ci&quot;).toUpperCase();
			login = request.getParameter(&quot;login&quot;);
			tipo = &quot;Cittadino&quot;;

			CittadinoManager CM = new CittadinoManager();
			CIManager CIM = new CIManager();
			AccessManager AM = new AccessManager();
			CartaIdentita CI = CIM.getCartaByNumero(ci);

			if(CI!=null){
				if(AM.controllaLogin(login)){
					Accesso ac = AM.getAccesso(login);
					Cittadino c = CM.getCittadinoById(CI.id());
					if(c.getLogin().equals(login)){
						String p = generaPassword();	//nuova password auto-generata
						ac.setPassword(p);
						AM.modificaAccesso(login, ac);

						//inviare l'email a c.getEmail();

						ris=&quot;E' stata inviata un email al suo indirizzo di posta elettronica&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=riuscita&quot;);
					}
					else{
						ris=&quot;La login non corrisponde alla codice della carta&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=fallita&quot;);
					}
				}
				else{
					ris=&quot;Siamo spiacenti, la login nonè presente&quot;;
					request.setAttribute(&quot;ris&quot;, ris);
					rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=fallita&quot;);
				}
			}
			else{
				ris=&quot;Siamo spiacenti, il codice della carta d'identit nonè presente nel database&quot;;
				request.setAttribute(&quot;ris&quot;, ris);
				rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=fallita&quot;);
			}
			rd.forward(request,response);
		}
		catch(DbException e){
			ris=e.getMessage();
			request.setAttribute(&quot;ris&quot;, ris);
			rd=sc.getRequestDispatcher(&quot;/user/index.jsp?func=operazione&amp;page=fallita&quot;);
			rd.forward(request,response);
		}
	}

	private static String generaPassword() {
		String pass=&quot;&quot;;
		Random r = new Random();
		for(int i=0;i&lt;8;i++){
			int x = r.nextInt(10); // genera un intero tra 0 e 9
			char c = (char) ((int) 'A' + r.nextInt(26)); // genera un char tra 'A' e 'Z
			boolean s = r.nextBoolean();
			if(s)
				pass=pass+c;
			else
				pass=pass+x;
		}
		return pass;
	}

}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC187</id>
      <content>package Servlet;

import java.io.IOException;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import Manager.AccessManager;
import Manager.CIManager;
import Manager.CittadinoManager;
import Bean.Accesso;
import Bean.CartaIdentita;
import Bean.Cittadino;
import DB.DbException;
/**
* La classe ServletRegistraCittadino gestisce l'operazione di registrazione 
* di un cittadino nel sistema
* La classe ServletRegistraCittadino non ha dipendenze
* @author Federico Cinque
*/
public class ServletRegistraCittadino extends HttpServlet {
	private String nome;
	private String cognome;
	private String email;
	private String ci;
	private String cf;
	private String login;
	private String password;
	private String tipo;

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		RequestDispatcher rd = null;
		ServletContext sc = getServletContext();
		String ris;
		try{
			nome = request.getParameter(&quot;nome&quot;);
			cognome = request.getParameter(&quot;cognome&quot;);
			email = request.getParameter(&quot;email&quot;);
			ci = request.getParameter(&quot;ci&quot;);
			cf = request.getParameter(&quot;cf&quot;).toUpperCase();
			login = request.getParameter(&quot;login&quot;);
			password = request.getParameter(&quot;password&quot;);
			tipo = &quot;Cittadino&quot;;

			CittadinoManager CM = new CittadinoManager();
			CIManager CIM = new CIManager();
			AccessManager AM = new AccessManager();
			CartaIdentita CI = CIM.getCartaByNumero(ci);

			if(CI!=null){
				if(!AM.controllaLogin(login)){
					Accesso ac = new Accesso(login,password,tipo);
					Cittadino c = CM.getCittadinoById(CI.id());
					if(c.getCodiceFiscale().equals(cf) &amp;&amp; c.getCognome().equals(cognome) &amp;&amp; c.getNome().equals(nome)){
						if(AM.inserisciAccesso(ac) &amp;&amp; CM.modificaLogin(c.getIdCittadino(), login) &amp;&amp; CM.modificaEmail(c.getIdCittadino(), email)){
							ris=&quot;ok&quot;;
							request.setAttribute(&quot;ris&quot;, ris);
							rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=riuscita&quot;);
						}
						else{
							ris=&quot;fallita&quot;;
							request.setAttribute(&quot;ris&quot;, ris);
							rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=fallita&quot;);
						}
					}
					else{
						ris=&quot;I dati inseriti non corrispondono&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=fallita&quot;);
					}
				}
				else{
					ris=&quot;Siamo spiacenti, la login é gi presente&quot;;
					request.setAttribute(&quot;ris&quot;, ris);
					rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=fallita&quot;);
				}
			}
			else{
				ris=&quot;Siamo spiacenti, il codice della carta d'identit noné presente nel database&quot;;
				request.setAttribute(&quot;ris&quot;, ris);
				rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=fallita&quot;);
			}
			rd.forward(request,response);
		}
		catch(DbException e){
			ris=e.getMessage();
			request.setAttribute(&quot;ris&quot;, ris);
			rd=sc.getRequestDispatcher(&quot;/user/home.jsp?func=operazione&amp;page=fallita&quot;);
			rd.forward(request,response);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC188</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import Bean.Amministratore;
import DB.DbException;
import Manager.AdminManager;
/**
* La classe ServletRicercaAmministratore ricerca e restituisce i dati di un amministratore
* La classe ServletRicercaAmministratore non ha dipendenze
* @author Federico Cinque
*/
public class ServletRicercaAmministratore extends HttpServlet{

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();
		if(session!=null){
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
				String matricola = request.getParameter(&quot;matricola&quot;);
				AdminManager AdM = new AdminManager();
				Amministratore A = AdM.ricercaAdminByMatricola(matricola);

				if(A != null){
					request.setAttribute(&quot;ris&quot;, A);
					rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=mostra&amp;page=datiA&quot;); 
				}
				else{
					ris=&quot;Amministratore non trovato&quot;;
					request.setAttribute(&quot;ris&quot;, ris);
					rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				}
				rd.forward(request,response);
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}

		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC189</id>
      <content>package Servlet;

import java.io.IOException;
import java.util.ArrayList;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Bean.CartaIdentita;
import Bean.Cittadino;
import DB.DbException;
import Manager.CIManager;
import Manager.CittadinoManager;
/**
* La classe ServletRicercaCittadino ricerca e restituisce i dati di un cittadino
* La classe ServletRicercaCittadino non ha dipendenze
* @author Federico Cinque
*/
public class ServletRicercaCittadino extends HttpServlet{

	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();
		Cittadino c = null;
		ServletContext sc = getServletContext();
		RequestDispatcher rd = null;
		String ris;
		if(session!=null){
			try{
				CittadinoManager CM = new CittadinoManager();
				if(request.getParameter(&quot;ci&quot;)!=null){
					String cod = request.getParameter(&quot;ci&quot;).toUpperCase();
					CIManager CIM = new CIManager();
					CartaIdentita CI = CIM.getCartaByNumero(cod);
					if(CI!=null){
						c = CM.getCittadinoById(CI.id());
						session.setAttribute(&quot;ci&quot;, c);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=mostra&amp;page=risultati&quot;);
					}
					else{
						ris=&quot;Siamo spiacenti, il codice della carta d'identità nonè presente nel database&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=mostra&amp;page=risultati&quot;);
					}
				}
				else{
					String nome = request.getParameter(&quot;nome&quot;);
					String cognome = request.getParameter(&quot;cognome&quot;);
					ArrayList&lt;Cittadino&gt; cittadini = (ArrayList&lt;Cittadino&gt;) CM.ricercaCittadino(nome,cognome);
					if(cittadini.size()&gt;0){
						request.setAttribute(&quot;ris&quot;, cittadini);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=mostra&amp;page=risultati&quot;); 
					}
					else{
						ris=&quot;Siamo spiacenti, nessun risultato&quot;;
						request.setAttribute(&quot;ris&quot;, ris);
						rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
					}
				}
				rd.forward(request,response);
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}

}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC190</id>
      <content>package Servlet;

import java.io.IOException;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import Bean.Impiegato;
import DB.DbException;
import Manager.ImpiegatoManager;
/**
* La classe ServletRicercaImpiegato ricerca e restituisce i dati di un impiegato
* La classe ServletRicercaImpiegato non ha dipendenze
* @author Federico Cinque
*/
public class ServletRicercaImpiegato extends HttpServlet{
	public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();
		if(session!=null){
			ServletContext sc = getServletContext();
			RequestDispatcher rd = null;
			String ris;
			try{
				String matricola = request.getParameter(&quot;matricola&quot;);		
				ImpiegatoManager IdM = new ImpiegatoManager();
				Impiegato I = IdM.ricercaImpiegatoByMatricola(matricola);

				sc = getServletContext();
				rd = null;

				if(I!=null){
					request.setAttribute(&quot;ris&quot;, I);
					rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=mostra&amp;page=datiI&quot;); 
				}
				else{
					ris=&quot;Impiegato non trovato&quot;;
					request.setAttribute(&quot;ris&quot;, ris);
					rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				}
				rd.forward(request,response);
			}
			catch(DbException e){
				ris=e.getMessage();
				request.setAttribute(&quot;ris&quot;, ris);
				rd=sc.getRequestDispatcher(&quot;/workers/index.jsp?func=operazione&amp;page=fallita&quot;);
				rd.forward(request,response);
			}
		}
		else{
			String url=&quot;/myDoc/workers/Accesso.jsp&quot;;
			response.sendRedirect(url);
		}
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC191</id>
      <content>package Servlet;
import Bean.*;
import DB.*;
import java.io.IOException;
import java.util.ArrayList;
import javax.servlet.*;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
* La classe ServletRicercaPratica restituisce una pratica specificata nel motore di ricerca
* La classe dipende dalla classe DbRichieste
* @author Christian Ronca
*/

public class ServletRicercaPratica extends HttpServlet {
	
	public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		int cod = Integer.parseInt(request.getParameter(&quot;codice&quot;));
		String value = request.getParameter(&quot;valore&quot;);
		
		int idp = 0, idr = 0;
		String idr_attesa=&quot;&quot;, idr_lavorazione=&quot;&quot;, idr_completato=&quot;&quot;;
		
	 ArrayList&lt;Richiesta&gt; arrayList;
	 Richiesta ric = null;
	 DbRichiesta dbric = null;
	 
	 try {
	 	dbric = new DbRichiesta();
	 	System.out.println(&quot;ok&quot;);
		
			if(value.equals(&quot;idp&quot;)) {
				ric = dbric.getRichiestaById(cod);
		 	request.setAttribute(&quot;ris&quot;, ric);
			} else if(value.equals(&quot;idr&quot;)) {
				arrayList = (ArrayList&lt;Richiesta&gt;)dbric.getRichiestaByRichiedente(cod);
		 	request.setAttribute(&quot;ris&quot;, arrayList);
			} else if((value.equals(&quot;accettata&quot;)) || value.equals(&quot;rifiutata&quot;)) {
				arrayList = (ArrayList&lt;Richiesta&gt;)dbric.getRichiestaByStato(cod, value);
		 	request.setAttribute(&quot;ris&quot;, arrayList);
			} else {
				arrayList = null;
			}

	 } catch(Exception e) {
	 	//e.getMessage().toString();
	 	e.printStackTrace();
	 }
	 
	 ServletContext sc = getServletContext(); 
		RequestDispatcher rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=visualizza&amp;page=DatiPratica&quot;); 
		rd.forward(request,response);
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC192</id>
      <content>package Servlet;
import javax.servlet.*;
import javax.servlet.http.*;
import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.Element;
import com.lowagie.text.Font;
import com.lowagie.text.PageSize;
import com.lowagie.text.Paragraph;
import com.lowagie.text.pdf.PdfPTable;
import com.lowagie.text.pdf.PdfWriter;
import Bean.*;
import DB.*;
import Manager.*;
import java.io.*;
import java.util.GregorianCalendar;
import java.util.Random;
public class ServletRisposta extends HttpServlet{
	/**
	 * servlet di risposta lato server destinata al client
	 */
	public void doPost(HttpServletRequest request, HttpServletResponse response)throws IOException,ServletException{
		GregorianCalendar gc = new GregorianCalendar();
		int gg = gc.get(GregorianCalendar.DATE);
		int mm = gc.get(GregorianCalendar.MONTH) + 1;
		int year = gc.get(GregorianCalendar.YEAR);
		String now = &quot;&quot; + year + mm + gg;
		String now2 = &quot;&quot; + year +&quot;-&quot; + mm + &quot;-&quot; + gg;
		
		HttpSession session = request.getSession();
		int idCitt = ((Cittadino)session.getAttribute(&quot;c&quot;)).getIdCittadino();
		String inout = &quot;&quot;;
		
		try {
			String nome_comune			= request.getParameter(&quot;comunename&quot;).toUpperCase();
			String nome					= request.getParameter(&quot;name&quot;).toUpperCase();
			String surname				= request.getParameter(&quot;surname&quot;).toUpperCase();
			String name_citta			= request.getParameter(&quot;citta&quot;).toUpperCase();
			String gg_date				= request.getParameter(&quot;gg&quot;);
			String mm_date				= request.getParameter(&quot;mm&quot;);
			String aa_date				= request.getParameter(&quot;aa&quot;);
			String newcomune			= request.getParameter(&quot;newcomune&quot;).toUpperCase();
			String indir				= request.getParameter(&quot;via&quot;).toUpperCase();
			String numero_civico		= request.getParameter(&quot;civico&quot;);
			String indirnew				= request.getParameter(&quot;newvia&quot;).toUpperCase();
			String num_civnew			= request.getParameter(&quot;num&quot;);
			String pref					= request.getParameter(&quot;pref&quot;);
			String tel					= request.getParameter(&quot;tel&quot;);
			String cntlr				= request.getParameter(&quot;radio&quot;);
			String check				= request.getParameter(&quot;check&quot;);
			
			String parent1				= request.getParameter(&quot;parentela1&quot;).toUpperCase();
			String surname1				= request.getParameter(&quot;surname1&quot;).toUpperCase();
			String name1				= request.getParameter(&quot;name1&quot;).toUpperCase();
			String luogo1				= request.getParameter(&quot;luogo1&quot;).toUpperCase();
			String gg1					= request.getParameter(&quot;gg1&quot;);
			String mm1					= request.getParameter(&quot;mm1&quot;);
			String aa1					= request.getParameter(&quot;aa1&quot;);
			String parent2				= request.getParameter(&quot;parentela2&quot;).toUpperCase();
			String surname2				= request.getParameter(&quot;surname2&quot;).toUpperCase();
			String name2				= request.getParameter(&quot;name2&quot;).toUpperCase();
			String luogo2				= request.getParameter(&quot;luogo2&quot;).toUpperCase();
			String gg2					= request.getParameter(&quot;gg2&quot;);
			String mm2					= request.getParameter(&quot;mm2&quot;);
			String aa2					= request.getParameter(&quot;aa2&quot;);
			String parent3				= request.getParameter(&quot;parentela3&quot;).toUpperCase();
			String surname3				= request.getParameter(&quot;surname3&quot;).toUpperCase();
			String name3				= request.getParameter(&quot;name3&quot;).toUpperCase();
			String luogo3				= request.getParameter(&quot;luogo3&quot;).toUpperCase();
			String gg3					= request.getParameter(&quot;gg3&quot;);
			String mm3					= request.getParameter(&quot;mm3&quot;);
			String aa3					= request.getParameter(&quot;aa3&quot;);
			String parent4				= request.getParameter(&quot;parentela4&quot;).toUpperCase();
			String surname4				= request.getParameter(&quot;surname4&quot;).toUpperCase();
			String name4				= request.getParameter(&quot;name4&quot;).toUpperCase();
			String luogo4				= request.getParameter(&quot;luogo4&quot;).toUpperCase();
			String gg4					= request.getParameter(&quot;gg4&quot;);
			String mm4					= request.getParameter(&quot;mm4&quot;);
			String aa4					= request.getParameter(&quot;aa4&quot;);
			String parent5				= request.getParameter(&quot;parentela5&quot;).toUpperCase();
			String surname5				= request.getParameter(&quot;surname5&quot;).toUpperCase();
			String name5				= request.getParameter(&quot;name5&quot;).toUpperCase();
			String luogo5				= request.getParameter(&quot;luogo5&quot;).toUpperCase();
			String gg5					= request.getParameter(&quot;gg5&quot;);
			String mm5					= request.getParameter(&quot;mm5&quot;);
			String aa5					= request.getParameter(&quot;aa5&quot;);
			String parent6				= request.getParameter(&quot;parentela6&quot;).toUpperCase();
			String surname6				= request.getParameter(&quot;surname6&quot;).toUpperCase();
			String name6				= request.getParameter(&quot;name6&quot;).toUpperCase();
			String luogo6				= request.getParameter(&quot;luogo6&quot;).toUpperCase();
			String gg6					= request.getParameter(&quot;gg6&quot;);
			String mm6					= request.getParameter(&quot;mm6&quot;);
			String aa6					= request.getParameter(&quot;aa6&quot;);

			String nome11				= request.getParameter(&quot;nome11&quot;).toUpperCase();
			String nome12				= request.getParameter(&quot;nome12&quot;).toUpperCase();
			String rapporto				= request.getParameter(&quot;rapporto&quot;).toUpperCase();
			String ab_libera			= request.getParameter(&quot;abitaz&quot;);
			String nametab1				= request.getParameter(&quot;nametab1&quot;).toUpperCase();
			String surnametab1			= request.getParameter(&quot;surnametab1&quot;).toUpperCase();
			String nametab2				= request.getParameter(&quot;nametab2&quot;).toUpperCase();
			String surnametab2			= request.getParameter(&quot;surnametab2&quot;).toUpperCase();
			String nametab3				= request.getParameter(&quot;nametab3&quot;).toUpperCase();
			String surnametab3			= request.getParameter(&quot;surnametab3&quot;).toUpperCase();
			String nametab4				= request.getParameter(&quot;nametab4&quot;).toUpperCase();
			String surnametab4			= request.getParameter(&quot;surnametab4&quot;).toUpperCase();
			String nametab5				= request.getParameter(&quot;nametab5&quot;).toUpperCase();
			String surnametab5			= request.getParameter(&quot;surnametab5&quot;).toUpperCase();
			String nametab6				= request.getParameter(&quot;nametab6&quot;).toUpperCase();
			String surnametab6			= request.getParameter(&quot;surnametab6&quot;).toUpperCase();
			String nametab7				= request.getParameter(&quot;nametab7&quot;).toUpperCase();
			String surnametab7			= request.getParameter(&quot;surnametab7&quot;).toUpperCase();

			if(cntlr.equals(&quot;stesso&quot;)) {
				inout = &quot;interno&quot;;
			} else {
				inout = &quot;altro&quot;;
			}
			
			Document document = new Document(PageSize.A4);
			PdfWriter.getInstance(document, response.getOutputStream());
			FileOutputStream fout = new FileOutputStream(&quot;webapps//myDoc//workers//docs_cittadino//&quot; + now + &quot;_&quot; + idCitt+ &quot;_&quot; + inout +&quot;.pdf&quot;);
			PdfWriter.getInstance(document, fout);
			response.sendRedirect(&quot;/myDoc/user/home.jsp?func=risposta&amp;page=utente&quot;);
			document.open();
			
			Paragraph spazio = new Paragraph(&quot;\n&quot;);
			Paragraph anagrafe_comune = new Paragraph(&quot;Anagrafe del comune di &quot; + nome_comune, new Font(Font.HELVETICA, 10, Font.BOLD));
			anagrafe_comune.setAlignment(Element.ALIGN_RIGHT);
			document.add(anagrafe_comune);
			
			Paragraph oggetto = new Paragraph(&quot;OGGETTO: DICHIARAZIONE DI CAMBIAMENTO DI ABITAZIONE&quot;, new Font(Font.HELVETICA, 12, Font.BOLD));
			oggetto.setAlignment(Element.ALIGN_CENTER);
			document.add(oggetto);
			
			Paragraph sottoscritto = new Paragraph(&quot; Io sottoscritto/a &quot; + surname + &quot; &quot; + nome + &quot; nato/a in &quot; + name_citta +&quot; il &quot; + gg_date+&quot;/&quot;+mm_date+&quot;/&quot;+aa_date + 
					&quot; già residente in via &quot; + indir +&quot; &quot;+ numero_civico + &quot; dichiaro, ai sensi e per gli effetti del combinato disposto dagli articoli 10,&quot; +
					&quot; lettera a) e 13 del D.P.R. 30/05/1989, n 223 di essermi trasferito nel comune di &quot;+ newcomune +&quot; in via &quot; + indirnew + &quot; &quot; +num_civnew + &quot; tel: &quot; + pref + &quot; &quot; + tel +
					&quot; unitamente ai seguenti familiari/conviventi:\n &quot;);
			sottoscritto.setAlignment(Element.ALIGN_JUSTIFIED);
			document.add(sottoscritto);
			
			//tabella stato di famiglia
			PdfPTable sf = new PdfPTable(5);
			sf.setWidthPercentage(100);
			sf.addCell(new Paragraph(&quot;PARENTELA&quot;));
			sf.addCell(new Paragraph(&quot;NOME&quot;));
			sf.addCell(new Paragraph(&quot;COGNOME&quot;));
			sf.addCell(new Paragraph(&quot;LUOGO DI NASCITA&quot;));
			sf.addCell(new Paragraph(&quot;DATA&quot;));
			sf.addCell(new Paragraph(parent1));
			sf.addCell(new Paragraph(surname1));
			sf.addCell(new Paragraph(name1));
			sf.addCell(new Paragraph(luogo1));
			sf.addCell(new Paragraph(gg1+&quot;/&quot;+mm1+&quot;/&quot;+aa1));
			sf.addCell(new Paragraph(parent2));
			sf.addCell(new Paragraph(surname2));
			sf.addCell(new Paragraph(name2));
			sf.addCell(new Paragraph(luogo2));
			sf.addCell(new Paragraph(gg2+&quot;/&quot;+mm2+&quot;/&quot;+aa2));
			document.add(sf);
			
			Paragraph mendace = new Paragraph(&quot;Dichiaro, ai sensi e per gli effetti di cui art. 46 e 47 del DPR 445/00 e pienamente consapevole &quot; +
					&quot;delle responsabilità civili e penali previste in caso di dichiarazione mendace che:\n\n&quot;);
			mendace.setAlignment(Element.ALIGN_JUSTIFIED);
			document.add(mendace);
			
			if(ab_libera.equals(&quot;transfer&quot;)) {
				Paragraph ab = new Paragraph(&quot; - l'abitazione nella quale mi sono trasferito/a è libera da persone e/o cose;\n\n\n&quot;);
				document.add(ab);
			} else {
				Paragraph occ = new Paragraph(&quot; - è occupata da terze parti, sotto riportate: \n\n&quot;);
				document.add(occ);
				PdfPTable altri_occupanti = new PdfPTable(2);
				altri_occupanti.setWidthPercentage(100);
				altri_occupanti.addCell(new Paragraph(&quot;NOME&quot;));
				altri_occupanti.addCell(new Paragraph(&quot;COGNOME&quot;));
				altri_occupanti.addCell(new Paragraph(nametab1));
				altri_occupanti.addCell(new Paragraph(surnametab1));
				altri_occupanti.addCell(new Paragraph(nametab2));
				altri_occupanti.addCell(new Paragraph(surnametab2));
				altri_occupanti.addCell(new Paragraph(nametab3));
				altri_occupanti.addCell(new Paragraph(surnametab3));
				altri_occupanti.addCell(new Paragraph(nametab4));
				altri_occupanti.addCell(new Paragraph(surnametab4));
				altri_occupanti.addCell(new Paragraph(nametab5));
				altri_occupanti.addCell(new Paragraph(surnametab5));
				altri_occupanti.addCell(new Paragraph(nametab6));
				altri_occupanti.addCell(new Paragraph(surnametab6));
				altri_occupanti.addCell(new Paragraph(nametab7));
				altri_occupanti.addCell(new Paragraph(surnametab7));
				document.add(altri_occupanti);
				
				if(check != null) {
					Paragraph p = new Paragraph(&quot;\nche tra il/la Sig./ra &quot; + nome11 + &quot; ed il/la Sig./ra &quot; + nome12 +&quot; sussiste il seguente rapporto di: &quot; +rapporto + &quot;\n\n&quot;);
					document.add(p);
				} else {
					Paragraph p1 = new Paragraph(&quot;\nche non sussiste nessun rapporto di parentela con le persoche che occupano già l'alloggio e quelle che vi sono trasferite\n\n&quot;);
					document.add(p1);
				}
			}

			Paragraph sdata = new Paragraph(&quot;Data: &quot;+gg+&quot;/&quot;+mm+&quot;/&quot;+year, new Font(Font.HELVETICA, 12, Font.NORMAL));
			sdata.setAlignment(Element.ALIGN_LEFT);
			document.add(sdata);
			
			Paragraph firma_dichiarante = new Paragraph(&quot;_________________\nFirma del dichiarante\n\n&quot;, new Font(Font.HELVETICA, 12, Font.NORMAL));
			firma_dichiarante.setAlignment(Element.ALIGN_RIGHT);
			document.add(firma_dichiarante);
			
			document.close();
			
		} catch(DocumentException e) {
			e.printStackTrace();
		}
		
		DbRichiesta dbr = new DbRichiesta();
		Richiesta ric = new Richiesta(&quot;Cambio Residenza&quot;, now2, idCitt, &quot;In lavorazione&quot;, &quot;/docs_cittadino/&quot;+ now + &quot;_&quot; + idCitt+ &quot;_&quot; + inout +&quot;.pdf&quot;);
		dbr.inserisciRichiesta(ric);
		
	}

}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC193</id>
      <content>package Servlet;
import Bean.*;
import DB.*;
import java.io.IOException;
import java.util.ArrayList;
import javax.servlet.*;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

/**
* La classe ServletStatoDiFamiglia restituisce una lista dei membri di una famiglia
* La classe dipende dalla classe DbNucleoFamiliare
* @author Christian Ronca
*/

public class ServletStatoDiFamiglia extends HttpServlet {
	private static final long serialVersionUID = -6835425792119775069L;

	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		int id = Integer.parseInt(request.getParameter(&quot;id&quot;));
		//int id = 200101;
		
		HttpSession session = request.getSession(true);
	 ArrayList&lt;Cittadino&gt; arrayList = null;
	 //Richiesta ric = null;

	 try {
	 	DbNucleoFamiliare dbnc =new DbNucleoFamiliare();
	 	arrayList = (ArrayList&lt;Cittadino&gt;)dbnc.getStatoFamiglia(id);
	 	for(int i=0; i&lt;arrayList.size();i++) {
	 		System.out.println(arrayList.get(i).getNome());
	 	}
	 	session.setAttribute(&quot;array&quot;, arrayList);
	 } catch(Exception e) {
	 	//e.getMessage().toString();
	 	e.printStackTrace();
	 }
	 
	 ServletContext sc = getServletContext();
		RequestDispatcher rd = sc.getRequestDispatcher(&quot;/user/home.jsp?func=serv&amp;page=stato_famiglia&quot;); 
		rd.forward(request,response);
	}
}</content>
      <parent_id/>
    </artifact>
    <artifact>
      <id>CC194</id>
      <content>package Servlet;
import java.io.IOException;
import java.util.ArrayList;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import Bean.*;
import DB.*;

/**
* La classe ServletVisualizzaPratiche restituisce una lista di richieste
* La classe dipende dalla classe DbRichieste
* @author Christian Ronca
*/

public class ServletVisualizzaPratiche extends HttpServlet {
	private static final long serialVersionUID = -6835425792119775069L;

	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		HttpSession session = request.getSession(true);
	 ArrayList&lt;Richiesta&gt; arrayList = null;
	 
	 try {
	 	DbRichiesta dbnc =new DbRichiesta();
	 	arrayList = (ArrayList&lt;Richiesta&gt;)dbnc.getRichieste();
	 	session.setAttribute(&quot;array&quot;, arrayList);
	 } catch(Exception e) {
	 	//e.getMessage().toString();
	 	e.printStackTrace();
	 }
	 
	 session.setAttribute(&quot;array&quot;, arrayList);
	 ServletContext sc = getServletContext();
		RequestDispatcher rd = sc.getRequestDispatcher(&quot;/workers/index.jsp?func=pra&amp;page=visualizza&quot;); 
		rd.forward(request,response);
	}
}</content>
      <parent_id/>
    </artifact>
  </artifacts>
</artifacts_collection>
