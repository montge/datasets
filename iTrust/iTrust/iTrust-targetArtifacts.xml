<?xml version="1.0" ?>
<artifacts_collection>
    <collection_info>
        <id>CC</id>
        <name>iTrust Target Artifacts</name>
        <version>1.1</version>
        <description>Class code</description>
        <content_location>external</content_location>
    </collection_info>
    <artifacts>
        <artifact>
            <id>CC_BeanBuilder</id>
            <content>package edu.ncsu.csc.itrust;

import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * Takes a parameter map and creates a bean from that map of the appropriate type.
 * @param &lt;T&gt; The type to be returned from the appropriate parameter map.
 */
public class BeanBuilder&lt;T&gt; {
	/**
	 * The code here is not obvious, but this method should not need rewriting unless a bug is found
	 * 
	 * @param map -
	 *            typically a request.getParameterMap; also can be a HashMap
	 * @param bean -
	 *            an instantiated bean to be loaded. Loaded bean is returned.
	 * @return a loaded &quot;bean&quot;
	 * @throws Exception -
	 *             Several exceptions are thrown here, so promotion seemed fitting
	 */
	// this warning is only suppressed because Map isn't parameterized (old JSP)
	@SuppressWarnings(&quot;unchecked&quot;)
	public T build(Map map, T bean) throws Exception {
		// JavaBeans should not have overloaded methods, according to their API
		// (a stupid limitation!)
		// Nevertheless, we should check for it
		checkOverloadedMethods(bean);

		// Use an introspector to find all of the getXXX or setXXX, we only want
		// the setXXX
		PropertyDescriptor[] propertyDescriptors = Introspector.getBeanInfo(bean.getClass())
				.getPropertyDescriptors();
		for (PropertyDescriptor descriptor : propertyDescriptors) {
			// if object is null, either it was ignored or empty - just go with
			// bean's default
			String[] value = (String[]) map.get(descriptor.getName());
			Method writeMethod = descriptor.getWriteMethod();
			if (!&quot;class&quot;.equals(descriptor.getName()) &amp;&amp; value != null &amp;&amp; writeMethod != null) {
				// descriptor's name is the name of your property; like
				// firstName
				// only take the first string
				try {
					// Skip the setters for enumerations
					if (writeMethod.getParameterTypes()[0].getEnumConstants() == null)
						writeMethod.invoke(bean, new Object[] { value[0] });
				} catch (IllegalArgumentException e) {
					// Throw a more informative exception
					throw new IllegalArgumentException(e.getMessage() + &quot; with &quot; + writeMethod.getName()
							+ &quot; and &quot; + value[0]);
				}
			}
		}
		return bean;
	}

	/**
	 * Checks for overloaded methods
	 * 
	 * @param bean item to check
	 */
	private void checkOverloadedMethods(T bean) {
		Method[] methods = bean.getClass().getDeclaredMethods();
		HashMap&lt;String, String&gt; nameMap = new HashMap&lt;String, String&gt;(methods.length);
		for (Method method : methods) {
			if (nameMap.get(method.getName()) != null)
				throw new IllegalArgumentException(bean.getClass().getName()
						+ &quot; should not have any overloaded methods, like &quot; + method.getName());
			if (!&quot;equals&quot;.equals(method.getName())) // allow an equals override
				nameMap.put(method.getName(), &quot;exists&quot;);
		}

	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_DBUtil</id>
            <content>package edu.ncsu.csc.itrust;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import edu.ncsu.csc.itrust.dao.DAOFactory;

/**
 * Provides a few database utilties
 * 
 * @author Andy
 * 
 */
public class DBUtil {
	/**
	 * Used to check if we can actually obtain a connection.
	 * 
	 * @return
	 */
	public static boolean canObtainProductionInstance() {
		try {
			DAOFactory.getProductionInstance().getConnection().close();
			return true;
		} catch (SQLException e) {
			System.out.println(e);
			return false;
		}
	}

	/**
	 * Close the prepared statement and the connection in a proper way
	 * 
	 * @param conn
	 * @param ps
	 */
	public static void closeConnection(Connection conn, PreparedStatement ps) {
		try {
			if (ps != null)
				ps.close();
			if (conn != null)
				conn.close();
		} catch (SQLException e) {
			System.err.println(&quot;Error closing connections&quot;);
			e.printStackTrace();
		}
	}

	/**
	 * Returns the last ID that was generated for an auto-increment column. Please note that this does NOT
	 * cause transaction problems! last_insert_id() returns the last generated ID on a per-connection basis.
	 * See the MySQL documentation at the following location to confirm this:
	 * {@link http://dev.mysql.com/doc/refman/5.0/en/getting-unique-id.html}
	 * 
	 * Don't believe me? see {@link AutoIncrementTest}
	 * 
	 * @param conn
	 * @return last generated id
	 * @throws SQLException
	 */
	public static long getLastInsert(Connection conn) throws SQLException {
		ResultSet rs = conn.createStatement().executeQuery(&quot;SELECT LAST_INSERT_ID()&quot;);
		rs.next();
		return rs.getLong(1);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_DateUtil</id>
            <content>package edu.ncsu.csc.itrust;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

/**
 * Provides a few extra date utilities
 * 
 * @author Andy
 * 
 */
public class DateUtil {
	public static final long YEAR_IN_MS = 1000L * 60L * 60L * 24L * 365L;

	/**
	 * Returns a MM/dd/yyyy format of the date for the given years ago
	 * 
	 * @param years
	 * @return
	 */
	public static String yearsAgo(long years) {
		long time = System.currentTimeMillis();
		return new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).format(new Date(time - years * YEAR_IN_MS));
	}

	/**
	 * Checks to see if a given date is within a range of months &lt;strong&gt;INCLUSIVELY&lt;/strong&gt;, agnostic of
	 * the year. &lt;br /&gt;
	 * &lt;br /&gt;
	 * 
	 * The range &quot;wraps&quot; so that if the first month is after the second month, then the definition of &quot;is in
	 * month range&quot; is:&lt;br /&gt;
	 * the date falls outside of secondMonth, firstMonth, but including secondMonth and firstMonth.
	 * 
	 * Modular arithmetic is used to adjust month values into the valid range.
	 * 
	 * @param date
	 * @param firstMonth
	 * @param secondMonth
	 * @return
	 */
	public static boolean isInMonthRange(java.util.Date date, int firstMonth, int secondMonth) {
		Calendar cal = new GregorianCalendar();
		cal.setTime(date);
		firstMonth %= 12;
		secondMonth %= 12;
		if (secondMonth &gt;= firstMonth) {
			return ((cal.get(Calendar.MONTH) &gt;= firstMonth) &amp;&amp; (cal.get(Calendar.MONTH) &lt;= secondMonth));
		}
		return ((cal.get(Calendar.MONTH) &gt;= firstMonth) || (cal.get(Calendar.MONTH) &lt;= secondMonth));
	}

	/**
	 * Same as isInMonthRange but uses the current date as the date value.
	 * 
	 * @see DateUtil#isInMonthRange(Date, int, int)
	 * @param firstMonth
	 * @param secondMonth
	 * @return
	 */
	public static boolean currentlyInMonthRange(int firstMonth, int secondMonth) {
		return isInMonthRange(new Date(), firstMonth, secondMonth);
	}

	/**
	 * Returns the date a certain number of years ago
	 * @param years how many years ago
	 * @return the date it was however many years ago
	 */
	public static Date getDateXyearsAgoFromNow(int years) {
		Calendar cal = new GregorianCalendar();
		cal.add(Calendar.YEAR, -years);
		return cal.getTime();
	}

	/**
	 * Returns the date a certain number of years ago
	 * @param years how many years ago
	 * @return the date it was however many years ago
	 */
	public static java.sql.Date getSQLdateXyearsAgoFromNow(int years) {
		return new java.sql.Date(getDateXyearsAgoFromNow(years).getTime());
	}

	/**
	 * Returns the date a certain number of days ago
	 * @param days how many days ago
	 * @return the date it was however many days ago
	 */
	public static Date getDateXDaysAgoFromNow(int days) {
		Calendar cal = new GregorianCalendar();
		cal.add(Calendar.DAY_OF_YEAR, -days);
		return cal.getTime();
	}
	
	/**
	 * Returns the date a certain number of days ago
	 * @param days how many days ago
	 * @return the date it was however many days ago
	 */
	public static java.sql.Date getSQLdateXDaysAgoFromNow(int days) {
		return new java.sql.Date(getDateXDaysAgoFromNow(days).getTime());
	}

	/**
	 * &lt;!--Pass in INSTANTIATED sql date objects and they will be set to the specified range, ie, FROM
	 * &lt;current year&gt; - yearsAgo1/monthValue1/01 TO &lt;current year&gt; - yearsAgo2/monthValue2/&lt;last day of
	 * month2&gt;--&gt; Pass in INSTANTIATED sql date objects and they will be set to the specified range, ie, FROM
	 * &amp;lt;current year&amp;gt; - yearsAgo1/monthValue1/01 TO &amp;lt;current year&amp;gt; -
	 * yearsAgo2/monthValue2/&amp;lt;last day of month2&amp;gt;
	 * 
	 * @param month1
	 *            First sql.Date object to be set
	 * @param monthValue1
	 * @param yearsAgo1
	 * @param month2
	 *            Second sql.Date object to be set
	 * @param monthValue2
	 * @param yearsAgo2
	 */
	public static void setSQLMonthRange(java.sql.Date month1, int monthValue1, int yearsAgo1,
			java.sql.Date month2, int monthValue2, int yearsAgo2) {
		GregorianCalendar cal = new GregorianCalendar();
		cal.add(Calendar.YEAR, -yearsAgo1);
		cal.set(Calendar.MONTH, monthValue1);
		cal.set(Calendar.DAY_OF_MONTH, 1);
		month1.setTime(cal.getTimeInMillis());
		cal.add(Calendar.YEAR, yearsAgo1);
		cal.add(Calendar.YEAR, -yearsAgo2);
		cal.set(Calendar.MONTH, monthValue2);
		cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
		month2.setTime(cal.getTimeInMillis());
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EmailUtil</id>
            <content>package edu.ncsu.csc.itrust;

import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Sends email to users. Since we don't want to train spammers in 326, this just inserts into a database. If
 * we put this into an actual system, we would replace this class with stuff from javax.mail
 * 
 * @author Andy
 * 
 */
public class EmailUtil {
	private DAOFactory factory;

	public EmailUtil(DAOFactory factory) {
		this.factory = factory;
	}

	// DO NOT SEND REAL EMAILS!!!!!
	// Sending emails - even to a throwaway account, is a waste of bandwidth and looks very suspicious.
	// If you want to know how to send emails from Java, just Google it on your own time.
	public void sendEmail(Email email) throws DBException {
		factory.getFakeEmailDAO().sendEmailRecord(email);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_HtmlEncoder</id>
            <content>package edu.ncsu.csc.itrust;

/**
 * Escapes a few key HTML characters and does some other checking
 * 
 * @author Andy
 * 
 */
public class HtmlEncoder {
	/**
	 *  Escapes a few key HTML characters
	 * @param input String to check and escape
	 * @return
	 */
	public static String encode(String input) {
		if (input == null)
			return input;
		String str = input.replaceAll(&quot;&lt;&quot;, &quot;&amp;lt;&quot;);
		str = str.replaceAll(&quot;&gt;&quot;, &quot;&amp;gt;&quot;);
		str = str.replaceAll(&quot;\n&quot;, &quot;&lt;br /&gt;&quot;);
		return str;
	}

	/**
	 * Checks URL
	 * 
	 * @param input URL to check
	 * @return false if the input contains http://, true otherwise
	 */
	public static boolean URLOnSite(String input) {
		return !(input.contains(&quot;http://&quot;));
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_Localization</id>
            <content>package edu.ncsu.csc.itrust;

import java.util.Locale;

/** Provides a singleton for accessing the current locale of iTrust
 *  Could possibly load the country and language from a file.
 *
 */
public class Localization {
	private Locale currentLocale;
	
	public Localization(){
		currentLocale = new Locale(&quot;en&quot;,&quot;US&quot;);
	}

	/**
	 * Returns the current locale
	 * @return the current locale
	 */
	public Locale getCurrentLocale(){
		return currentLocale;
	}
	
	static Localization currentInstance = null;
	
	/**
	 * singleton method, may want to make this thread safe, as far as I know
	 * iTrust doesn't do any multithreading though...
	 * @return Localization instance
	 */
	public static Localization instance(){
		if(currentInstance == null){
			currentInstance = new Localization();
		}
		return currentInstance;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_Messages</id>
            <content>package edu.ncsu.csc.itrust;

import java.util.MissingResourceException;
import java.util.ResourceBundle;

public class Messages {
	private static final String BUNDLE_NAME = &quot;edu.ncsu.csc.itrust.messages&quot;; //$NON-NLS-1$

	private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle.getBundle(BUNDLE_NAME,Localization.instance().getCurrentLocale());

	public static String getString(String key) {
		try {
			return RESOURCE_BUNDLE.getString(key);
		} catch (MissingResourceException e) {
			return '!' + key + '!';
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ParameterUtil</id>
            <content>package edu.ncsu.csc.itrust;

import java.util.HashMap;
import java.util.Map;

/**
 * Provides a utility method that converts the &quot;Map&quot; from the JSP container to a type-checked hashmap
 * 
 * @author Andy
 * 
 */
public class ParameterUtil {
	/**
	 * Provides a utility method that converts the &quot;Map&quot; from the JSP container to a type-checked hashmap
	 * @param params Map to convert
	 * @return converted Map
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static HashMap&lt;String, String&gt; convertMap(Map params) {
		HashMap&lt;String, String&gt; myMap = new HashMap&lt;String, String&gt;();
		for (Object key : params.keySet()) {
			String[] value = ((String[]) params.get(key));
			if (value != null)
				myMap.put(key.toString(), value[0]);
			else
				myMap.put(key.toString(), null);
		}
		return myMap;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_RandomPassword</id>
            <content>package edu.ncsu.csc.itrust;

import java.util.Random;

/**
 * Generates a random string of characters
 * 
 * @author Andy
 * 
 */
public class RandomPassword {
	private static final Random rand = new Random();

	/**
	 * Returns a string of random characters
	 * 
	 * @return a string of random characters
	 */
	public static String getRandomPassword() {
		String str = &quot;&quot;;
		for (int i = 0; i &lt; 10; i++) {
			str += (char) (rand.nextInt(26) + 'a');
		}
		return str;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SessionTimeoutListener</id>
            <content>package edu.ncsu.csc.itrust.server;

import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * A listener which will time the user out after a pre-specified time limit. 
 */
public class SessionTimeoutListener implements HttpSessionListener {
	private DAOFactory factory;

	/**
	 * The default constructor.
	 */
	public SessionTimeoutListener() {
		this.factory = DAOFactory.getProductionInstance();
	}

	/**
	 * The specialized constructor, which takes a particular DAOFactory to be used when checking for the pre-specified
	 * timeout limit.
	 * @param factory The DAOFactory to be used.
	 */
	public SessionTimeoutListener(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Called when the HttpSession is created, this method pulls the pre-specified limit from the
	 * database and sets it as a property of the HttpSession.
	 * @param arg0 The HttpSessionEven which just occurred.
	 */
	public void sessionCreated(HttpSessionEvent arg0) {
		HttpSession session = arg0.getSession();
		int mins = 20;
		try {
			mins = factory.getAccessDAO().getSessionTimeoutMins();
		} catch (DBException e) {
			System.err.println(&quot;Unable to set session timeout, defaulting to 20 minutes&quot;);
			e.printStackTrace();
		}
		if (mins &lt; 1)
			mins = 1;
		session.setMaxInactiveInterval(mins * 60);
	}

	/**
	 * Must be declared for compliance with the interface. Not implemented.
	 */
	public void sessionDestroyed(HttpSessionEvent arg0) {
		// nothing to do here
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AddApptAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.sql.SQLException;
import java.sql.Timestamp;
import edu.ncsu.csc.itrust.beans.ApptBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.ApptDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.ApptBeanValidator;

public class AddApptAction {
	private long loggedInMID;
	private ApptDAO apptDAO;
	private TransactionDAO transDAO;
	private PatientDAO patientDAO;
	private PersonnelDAO personnelDAO;
	private ApptBeanValidator validator = new ApptBeanValidator();
	
	public AddApptAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.apptDAO = factory.getApptDAO();
		this.transDAO = factory.getTransactionDAO();
		this.patientDAO = factory.getPatientDAO();
		this.personnelDAO = factory.getPersonnelDAO();
	}
	
	public String addAppt(ApptBean appt) throws FormValidationException, SQLException {
		validator.validate(appt);
		if(appt.getDate().before(new Timestamp(System.currentTimeMillis()))) {
			return &quot;The scheduled date of this Appointment (&quot;+appt.getDate()+&quot;) has already passed.&quot;;
		}
		
		try {
			apptDAO.scheduleAppt(appt);
			transDAO.logTransaction(TransactionType.ADD_APPT, loggedInMID, 0L,
					&quot;Added Appointment &quot; + appt.getApptType());
			return &quot;Success: &quot; + appt.getApptType() + &quot; for &quot; + appt.getDate() + &quot; added&quot;;
		}
		catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		} 
	}
	
	/**
	 * Gets a users's name from their MID
	 * 
	 * @param mid the MID of the user
	 * @return the user's name
	 * @throws iTrustException
	 */
	public String getName(long mid) throws iTrustException {
		if(mid &lt; 7000000000L)
			return patientDAO.getName(mid);
		else
			return personnelDAO.getName(mid);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AddERespAction</id>
            <content>package edu.ncsu.csc.itrust.action;


import edu.ncsu.csc.itrust.RandomPassword;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.Role;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.AddPersonnelValidator;

/**
 * Used for Add Personnel page (addPersonnel.jsp). This just adds an empty HCP/UAP, creates a random password
 * for them.
 * 
 * Very similar to {@link AddOfficeVisitAction} and {@link AddPatientAction}
 * 
 * @author Andy Meneely
 * 
 * Copied from AddHCPAction 
 */


public class AddERespAction {
	private PersonnelDAO personnelDAO;
	private AuthDAO authDAO;
	private TransactionDAO transDAO;
	private long loggedInMID;

/**
 * Sets up the defaults for the class
 * 
 * @param factory factory for creating the defaults.
 * @param loggedInMID person currently logged in 
 * @author Andy Meneely
 */	
	
	public AddERespAction(DAOFactory factory, long loggedInMID) {
		this.personnelDAO = factory.getPersonnelDAO();
		this.authDAO = factory.getAuthDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
	}

	/**
	 * Adds the new user.  Event is logged.
	 * 
	 * @param p bean containing the information for the new user
	 * @return MID of the new user.
	 * @throws FormValidationException
	 * @throws iTrustException
	 */
	public long add(PersonnelBean p) throws FormValidationException, iTrustException {
		new AddPersonnelValidator().validate(p);
		long newMID = personnelDAO.addEmptyPersonnel(Role.ER);
		p.setMID(newMID);
		personnelDAO.editPersonnel(p);
		String pwd = authDAO.addUser(newMID, Role.ER, RandomPassword.getRandomPassword());
		p.setPassword(pwd);

		transDAO.logTransaction(TransactionType.CREATE_DISABLE_ER, loggedInMID, newMID, &quot;Added New &quot; + p.getRole().name());
		return newMID;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AddHCPAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.RandomPassword;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.Role;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.AddPersonnelValidator;

/**
 * Used for Add Personnel page (addPersonnel.jsp). This just adds an empty HCP/UAP, creates a random password
 * for them.
 * 
 * Very similar to {@link AddOfficeVisitAction} and {@link AddPatientAction}
 * 
 * @author Andy Meneely
 * 
 */
public class AddHCPAction {
	private PersonnelDAO personnelDAO;
	private AuthDAO authDAO;
	private TransactionDAO transDAO;
	private long loggedInMID;

	/**
	 * Sets up the defaults for the class
	 * 
	 * @param factory factory for creating the defaults.
	 * @param loggedInMID person currently logged in 
	 * @author Andy Meneely
	 */	
	
	public AddHCPAction(DAOFactory factory, long loggedInMID) {
		this.personnelDAO = factory.getPersonnelDAO();
		this.authDAO = factory.getAuthDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
	}
	
	/**
	 * Adds the new user.   Event is logged.
	 * 
	 * @param p bean containing the information for the new user
	 * @return MID of the new user.
	 * @throws FormValidationException
	 * @throws iTrustException
	 */
	public long add(PersonnelBean p) throws FormValidationException, iTrustException {
		new AddPersonnelValidator().validate(p);
		long newMID = personnelDAO.addEmptyPersonnel(Role.HCP);
		p.setMID(newMID);
		personnelDAO.editPersonnel(p);
		String pwd = authDAO.addUser(newMID, Role.HCP, RandomPassword.getRandomPassword());
		p.setPassword(pwd);
		//transDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID);
		transDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID, newMID, &quot;Added New HCP&quot;);
		return newMID;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AddOfficeVisitAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.action.base.PatientBaseAction;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Used for Document Office Visit page (documentOfficeVisit.jsp). This just adds an empty office visit, and
 * provides a list of office visits in case you want to edit an old office visit.
 * 
 * Very similar to {@link AddPatientAction}
 * 
 * @author Andy Meneely
 * 
 */
public class AddOfficeVisitAction extends PatientBaseAction {
	private DAOFactory factory;
	private OfficeVisitDAO ovDAO;
	private TransactionDAO transDAO;

	/**
	 * Sets up the defaults for the class
	 * @param factory
	 * @param pidString
	 *            Patient ID to be validated by the superclass, {@link PatientBaseAction}
	 * @throws iTrustException
	 */
	public AddOfficeVisitAction(DAOFactory factory, String pidString) throws iTrustException {
		super(factory, pidString);
		this.factory = factory;
		this.transDAO = factory.getTransactionDAO();
		ovDAO = factory.getOfficeVisitDAO();
	}

	/**
	 * Adds an empty office visit
	 * 
	 * @param loggedInMID
	 *            For logging purposes
	 * @return Office visit ID (primary key) of the new office visit
	 * @throws DBException
	 */
	public long addEmptyOfficeVisit(long loggedInMID) throws DBException {
		OfficeVisitBean ov = new OfficeVisitBean();
		ov.setHcpID(loggedInMID);
		ov.setPatientID(pid);
		long visitID = ovDAO.add(ov);
		transDAO.logTransaction(TransactionType.DOCUMENT_OFFICE_VISIT, loggedInMID, pid, &quot;visit id: &quot;
				+ visitID);
		return visitID;
	}

	/**
	 * Lists all office visits for a particular patient, regardless of who originally documented the office
	 * visit.
	 * 
	 * @return List of office visits,
	 * @throws iTrustException
	 */
	public List&lt;OfficeVisitBean&gt; getAllOfficeVisits() throws iTrustException {
		return ovDAO.getAllOfficeVisits(pid);
	}

	/**
	 * Returns the full name of the patient with this MID
	 * 
	 * @return name in the form of a string
	 * @throws DBException
	 * @throws iTrustException
	 */
	public String getUserName() throws DBException, iTrustException {
		return factory.getAuthDAO().getUserName(pid);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AddPHAAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.RandomPassword;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.Role;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.AddPersonnelValidator;

/**
 * Used for Add Personnel page (addPersonnel.jsp). This just adds an empty PHA, creates a random password
 * for them.
 * 
 * Very similar to {@link AddOfficeVisitAction} and {@link AddPatientAction}
 * 
 */
public class AddPHAAction {
	private PersonnelDAO personnelDAO;
	private AuthDAO authDAO;
	private TransactionDAO transDAO;
	private long loggedInMID;

	/**
	 * Sets up the defaults for the class
	 * 
	 * @param factory factory for creating the defaults.
	 * @param loggedInMID person currently logged in 
	 * @author Andy Meneely
	 */	
	
	public AddPHAAction(DAOFactory factory, long loggedInMID) {
		this.personnelDAO = factory.getPersonnelDAO();
		this.authDAO = factory.getAuthDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
	}
	
	/**
	 * Adds the new user.   Event is logged.
	 * 
	 * @param p bean containing the information for the new user
	 * @return MID of the new user.
	 * @throws FormValidationException
	 * @throws iTrustException
	 */
	public long add(PersonnelBean p) throws FormValidationException, iTrustException {
		new AddPersonnelValidator().validate(p);
		long newMID = personnelDAO.addEmptyPersonnel(Role.PHA);
		p.setMID(newMID);
		personnelDAO.editPersonnel(p);
		String pwd = authDAO.addUser(newMID, Role.PHA, RandomPassword.getRandomPassword());
		p.setPassword(pwd);
		//transDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID);
		transDAO.logTransaction(TransactionType.CREATE_DISABLE_PHA, loggedInMID, newMID, &quot;Added New PHA&quot;);
		return newMID;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AddPatientAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.RandomPassword;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.Role;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.validate.AddPatientValidator;

/**
 * Used for Add Patient page (addPatient.jsp). This just adds an empty patient, creates a random password for
 * that patient.
 * 
 * Very similar to {@link AddOfficeVisitAction}
 * 
 * @author Andy Meneely
 * 
 */
public class AddPatientAction {
	private TransactionDAO transDAO;
	private PatientDAO patientDAO;
	private AuthDAO authDAO;
	private long loggedInMID;

	/**
	 * Just the factory and logged in MID
	 * 
	 * @param factory
	 * @param loggedInMID
	 */
	public AddPatientAction(DAOFactory factory, long loggedInMID) {
		this.patientDAO = factory.getPatientDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
		this.authDAO = factory.getAuthDAO();
	}

	/**
	 * Creates a new patient, returns the new MID. Adds a new user to the table along with a random password.
	 * 
	 * @return the new MID of the patient
	 * @throws DBException
	 * @throws FormValidationException
	 */
	public long addPatient(PatientBean p) throws DBException, FormValidationException {
		new AddPatientValidator().validate(p);
		long newMID = patientDAO.addEmptyPatient();
		p.setMID(newMID);
		String pwd = authDAO.addUser(newMID, Role.PATIENT, RandomPassword.getRandomPassword());
		p.setPassword(pwd);
		patientDAO.editPatient(p);
		transDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID, newMID, &quot;New Patient Added&quot;);
		return newMID;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AddRemoteMonitoringDataAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.beans.RemoteMonitoringDataBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.RemoteMonitoringDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.RemoteMonitoringDataBeanValidator;

/**
 * Handles adding remote monitoring patient data to the database
 * 
 */
public class AddRemoteMonitoringDataAction {
	private RemoteMonitoringDataBeanValidator validator = new RemoteMonitoringDataBeanValidator();
	private RemoteMonitoringDAO rmDAO;
	private TransactionDAO transDAO;
	private AuthDAO authDAO;
	private long loggedInMID;
	private long patientMID;

	/**
	 * Constructor
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person recording the patient's data.
	 * @param patientMID The MID of the patient
	 */
	public AddRemoteMonitoringDataAction(DAOFactory factory, long loggedInMID, long patientMID) {
		this.loggedInMID = loggedInMID;
		this.rmDAO = factory.getRemoteMonitoringDAO();
		this.transDAO = factory.getTransactionDAO();
		this.authDAO = factory.getAuthDAO();
		this.patientMID = patientMID;
	}

	/**
	 * Adds a patients remote monitoring data to the database.
	 * 
	 * @param glucoseLevel
	 * @throws DBException
	 */
	public void addRemoteMonitoringData(int glucoseLevel)
	  throws DBException, FormValidationException,iTrustException {
		//Validation - Only need to validate the three integer parameters
		RemoteMonitoringDataBean m = new RemoteMonitoringDataBean();
		m.setGlucoseLevel(glucoseLevel);
		m.setDiastolicBloodPressure(60);
		m.setSystolicBloodPressure(60);
		validator.validate(m);
		m.setDiastolicBloodPressure(-1);
		m.setSystolicBloodPressure(-1);
		//Log transaction
		transDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID);
		String role;
		if (loggedInMID == patientMID){
			role = &quot;self-reported&quot;;
		} else if (authDAO.getUserRole(loggedInMID).getUserRolesString().equals(&quot;uap&quot;)){
			role = &quot;case-manager&quot;;
		} else {
			role = &quot;patient representative&quot;;
		}		
		//Store in DB
		rmDAO.storePatientData(patientMID, glucoseLevel, role, loggedInMID);
	}
	
	/**
	 * Adds a patients remote monitoring data to the database.
	 * 
	 * @param systolicBloodPressure
	 * @param diastolicBloodPressure
	 * @throws DBException
	 */
	public void addRemoteMonitoringData(int systolicBloodPressure, int diastolicBloodPressure)
	  throws DBException, FormValidationException,iTrustException {
		//Validation - Only need to validate the three integer parameters
		RemoteMonitoringDataBean m = new RemoteMonitoringDataBean();
		m.setSystolicBloodPressure(systolicBloodPressure);
		m.setDiastolicBloodPressure(diastolicBloodPressure);
		validator.validate(m);
		
		//Log transaction
		transDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID);
		String role;
		if (loggedInMID == patientMID){
			role = &quot;self-reported&quot;;
		} else if (authDAO.getUserRole(loggedInMID).getUserRolesString().equals(&quot;uap&quot;)){
			role = &quot;case-manager&quot;;
		} else {
			role = &quot;patient representative&quot;;
		}		
		//Store in DB
		rmDAO.storePatientData(patientMID, systolicBloodPressure, diastolicBloodPressure, role, loggedInMID);
	}
	
	/**
	 * Adds a patients remote monitoring data to the database.
	 * 
	 * @param systolicBloodPressure
	 * @param diastolicBloodPressure
	 * @param glucoseLevel
	 * @throws DBException
	 */
	public void addRemoteMonitoringData(int systolicBloodPressure, int diastolicBloodPressure, int glucoseLevel)
	  throws DBException, FormValidationException,iTrustException {
		//Validation - Only need to validate the three integer parameters
		RemoteMonitoringDataBean m = new RemoteMonitoringDataBean();
		m.setSystolicBloodPressure(systolicBloodPressure);
		m.setDiastolicBloodPressure(diastolicBloodPressure);
		m.setGlucoseLevel(glucoseLevel);
		validator.validate(m);
		
		//Log transaction
		transDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID);
		String role;
		if (loggedInMID == patientMID){
			role = &quot;self-reported&quot;;
		} else if (authDAO.getUserRole(loggedInMID).getUserRolesString().equals(&quot;uap&quot;)){
			role = &quot;case-manager&quot;;
		} else {
			role = &quot;patient representative&quot;;
		}		
		//Store in DB
		rmDAO.storePatientData(patientMID, systolicBloodPressure, diastolicBloodPressure, glucoseLevel, role, loggedInMID);
	}
	
	/**
	 * returns the patient name
	 * 
	 * @return patient name
	 * @throws DBException
	 * @throws iTrustException
	 */
	public String getPatientName(long pid) throws DBException, iTrustException {
		return authDAO.getUserName(pid);
	}
	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AddUAPAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.RandomPassword;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.Role;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.AddPersonnelValidator;

/**
 * Used for Add Personnel page (addPersonnel.jsp). This just adds an empty HCP/UAP, creates a random password
 * for them.
 * 
 * Very similar to {@link AddOfficeVisitAction} and {@link AddPatientAction}
 * 
 * @author Andy Meneely
 * 
 */
public class AddUAPAction {
	private PersonnelDAO personnelDAO;
	private AuthDAO authDAO;
	private TransactionDAO transDAO;
	private long loggedInMID;

	/**
	 * Sets up the defaults for the class
	 * 
	 * @param factory factory for creating the defaults.
	 * @param loggedInMID person currently logged in 
	 * @author Andy Meneely
	 */	
	public AddUAPAction(DAOFactory factory, long loggedInMID) {
		this.personnelDAO = factory.getPersonnelDAO();
		this.authDAO = factory.getAuthDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
	}
	
	
	/**
	 * Adds the new user.  Event is logged.
	 * 
	 * @param p bean containing the information for the new user
	 * @return MID of the new user.
	 * @throws FormValidationException
	 * @throws iTrustException
	 */
	public long add(PersonnelBean p) throws FormValidationException, iTrustException {
		new AddPersonnelValidator().validate(p);
		long newMID = personnelDAO.addEmptyPersonnel(Role.UAP);
		p.setMID(newMID);
		personnelDAO.editPersonnel(p);
		String pwd = authDAO.addUser(newMID, Role.UAP, RandomPassword.getRandomPassword());
		p.setPassword(pwd);
		transDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID, newMID, &quot;New UAP Added&quot;);
		return newMID;
	}


}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ChangeSessionTimeoutAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AccessDAO;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Used to change the session timeout, sessionTimeout.jsp. Note that a change to this timeout only gets
 * reflected on new sessions.
 * 
 * @author Andy Meneely
 * 
 */
public class ChangeSessionTimeoutAction {
	private AccessDAO accessDAO;

	/**
	 * Sets up defualts.
	 * 
	 * @param factory
	 * @author Andy Meneely
	 */
	public ChangeSessionTimeoutAction(DAOFactory factory) {
		this.accessDAO = factory.getAccessDAO();
	}

	/**
	 * Changes the session timeout, the complicated logic of this is somewhat regrettably in the DAO,
	 * {@link AccessDAO}
	 * 
	 * @param minuteString
	 *            Pass the number of minutes in the form of a string, greater than 0.
	 * @throws FormValidationException
	 * @throws DBException
	 * @author Andy Meneely
	 */
	public void changeSessionTimeout(String minuteString) throws FormValidationException, DBException {
		try {
			Integer minutes = Integer.valueOf(minuteString);
			if (minutes &lt; 1)
				throw new FormValidationException(&quot;Must be a number greater than 0&quot;);
			accessDAO.setSessionTimeoutMins(minutes);
		} catch (NumberFormatException e) {
			throw new FormValidationException(&quot;That is not a number&quot;);
		}
	}

	/**
	 * Returns the current session timeout in minutes, as reflected in the database
	 * 
	 * @return the number of minutes it would take for an inactive session to timeout
	 * @throws DBException
	 * @author Andy Meneely
	 */
	public int getSessionTimeout() throws DBException {
		return accessDAO.getSessionTimeoutMins();
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ChronicDiseaseRiskAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.action.base.PatientBaseAction;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.NoHealthRecordsException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.risk.ChronicDiseaseMediator;
import edu.ncsu.csc.itrust.risk.RiskChecker;

/**
 * 
 * Used for chronicDiseaseRisks.jsp. Passes most of the logic off to {@link ChronicDiseaseMediator}, and the
 * various subclasses of {@link RiskChecker}.
 * 
 * @author Andy Meneely
 * 
 */
public class ChronicDiseaseRiskAction extends PatientBaseAction {
	private AuthDAO authDAO;
	private long loggedInMID;
	private ChronicDiseaseMediator diseaseMediator;
	private TransactionDAO transDAO;

	/**
	 * 
	 * @param factory
	 * @param loggedInMID
	 * @param pidString
	 *            The patient ID to be validated and used
	 * @throws iTrustException
	 * @throws DBException
	 * @throws NoHealthRecordsException
	 *             This is thrown if a patient is added without any health records to be checked. Try to avoid
	 *             having this exception be thrown in a normal flow of events.
	 * @author Andy Meneely
	 */
	public ChronicDiseaseRiskAction(DAOFactory factory, long loggedInMID, String pidString)
			throws iTrustException, DBException, NoHealthRecordsException {
		super(factory, pidString);
		this.authDAO = factory.getAuthDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
		this.diseaseMediator = new ChronicDiseaseMediator(factory, pid);
	}

	/**
	 * Returns the ID of the patient to be checked.
	 * 
	 * @return patient ID whose risk we are checking
	 * @author Andy Meneely
	 */
	public long getPatientID() {
		return pid;
	}

	/**
	 * Gives the full name of the patient
	 * 
	 * @return Full name of the patient who we are checking
	 * @throws DBException
	 * @throws iTrustException
	 * @author Andy Meneely
	 */
	public String getUserName() throws DBException, iTrustException {
		return authDAO.getUserName(pid);
	}

	/**
	 * Returns the risks for which this patient is at risk for. All logic has been passed to
	 * {@link ChronicDiseaseMediator} and the subclasses of {@link RiskChecker}.
	 * 
	 * @return List of risks
	 * @throws iTrustException
	 * @throws DBException
	 * @author Andy Meneely
	 */
	public List&lt;RiskChecker&gt; getDiseasesAtRisk() throws iTrustException, DBException {
		transDAO.logTransaction(TransactionType.IDENTIFY_RISK_FACTORS, loggedInMID, pid, &quot;&quot;);
		return diseaseMediator.getDiseaseAtRisk();
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_DeclareHCPAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.Role;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Used by the patient to declare HCPs as &quot;designated&quot;, in editHCPs.jsp.
 * 
 * @author Andy Meneely
 * 
 */
public class DeclareHCPAction {
	private TransactionDAO transDAO;
	private PatientDAO patientDAO;
	private AuthDAO authDAO;
	private long loggedInMID;

	/**
	 * Sets up defaults
	 * 
	 * @param factory The DAO factory to be used for generating the DAOs for this action.
	 * @param loggedInMID
	 *            This patient
	 * @author Andy Meneely
	 */
	public DeclareHCPAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.transDAO = factory.getTransactionDAO();
		this.patientDAO = factory.getPatientDAO();
		this.authDAO = factory.getAuthDAO();
	}

	/**
	 * Lists the declared HCPs for this current patient
	 * 
	 * @return Returns a list of the declared HCPs
	 * @throws iTrustException
	 * @author Andy Meneely
	 */
	public List&lt;PersonnelBean&gt; getDeclaredHCPS() throws iTrustException {
		return patientDAO.getDeclaredHCPs(loggedInMID);
	}

	/**
	 * Validate an HCP's MID and declare them, if possible
	 * 
	 * @param hcpStr
	 *            The MID of an HCP to declare
	 * @return A status message,
	 * @throws iTrustException
	 * @author Andy Meneely
	 */
	public String declareHCP(String hcpStr) throws iTrustException {
		try {
			long hcpID = Long.valueOf(hcpStr);
			if (authDAO.getUserRole(hcpID) != Role.HCP)
				throw new iTrustException(&quot;This user is not a licensed healthcare professional!&quot;);

			boolean confirm = patientDAO.declareHCP(loggedInMID, hcpID);

			if (confirm) {
				transDAO.logTransaction(TransactionType.DECLARE_HCP, loggedInMID, hcpID,
						&quot;patient declared hcp&quot;);
				return &quot;HCP successfully declared&quot;;
			} else
				return &quot;HCP not declared&quot;;
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;HCP's MID not a number&quot;);
		} 
	}

	/**
	 * Validate an HCP's MID and undeclare them, if possible
	 * 
	 * @param input
	 *            The MID of an HCP to undeclare
	 * @return
	 * @throws iTrustException
	 * @author Andy Meneely
	 */
	public String undeclareHCP(String input) throws iTrustException {
		try {
			long hcpID = Long.valueOf(input);
			boolean confirm = patientDAO.undeclareHCP(loggedInMID, hcpID);
			if (confirm) {
				transDAO.logTransaction(TransactionType.DECLARE_HCP, loggedInMID, hcpID,
						&quot;patient undeclared hcp&quot;);
				return &quot;HCP successfully undeclared&quot;;
			} else
				return &quot;HCP not undeclared&quot;;
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;HCP's MID not a number&quot;);
		} 
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_DrugInteractionAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.beans.DrugInteractionBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.DrugInteractionDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.DrugInteractionValidator;

/**
 * Used by EditDrugInteraction.jsp to edit and get information about drug interactions.
 * 
 */
public class DrugInteractionAction {
	private DrugInteractionDAO drugDAO;
	private TransactionDAO tranDAO;
	private DrugInteractionValidator validator;
	long loggedInMID;

	/**
	 * Sets up defaults
	 * 
	 * @param factory The DAO factory to be used for generating the DAOs for this action.
	 * 
	 */
	public DrugInteractionAction(DAOFactory factory, long loggedInMID) {
		this.drugDAO = factory.getDrugInteractionDAO();
		this.tranDAO = factory.getTransactionDAO();
		this.validator = new DrugInteractionValidator();
		this.loggedInMID = loggedInMID;
	}
	
	/**
	 * Method to report an interaction
	 * @param firstDrug
	 * @param secondDrug
	 * @param description
	 * @return
	 */
	
	public String reportInteraction(String firstDrug, String secondDrug, String description) throws iTrustException,FormValidationException{
		if (firstDrug.equals(secondDrug)){
			return &quot;Interactions can only be recorded between two different drugs&quot;;
		}
		DrugInteractionBean drugInt = new DrugInteractionBean();
		drugInt.setFirstDrug(firstDrug);
		drugInt.setSecondDrug(secondDrug);
		drugInt.setDescription(description);
		
		try {
			validator.validate(drugInt);
			if (drugDAO.reportInteraction(firstDrug,secondDrug,description)){
				tranDAO.logTransaction(TransactionType.DRUG_INTERACTION, loggedInMID);
				return &quot;Interaction recorded successfully&quot;;
			} else {
				return &quot;Interaction could not be added&quot;;
			}
		} catch (DBException e){
			e.printStackTrace();
			return e.getMessage();
			}
		}

	/**
	 * Method to delete an interaction
	 * @param firstDrug
	 * @param secondDrug
	 * @return
	 */
	public String deleteInteraction(String firstDrug,String secondDrug) throws iTrustException, FormValidationException{
		DrugInteractionBean drugInt = new DrugInteractionBean();
		drugInt.setFirstDrug(firstDrug);
		drugInt.setSecondDrug(secondDrug);
		drugInt.setDescription(&quot;blank&quot;);
		
		try {
			validator.validate(drugInt);
			if (drugDAO.deleteInteraction(firstDrug,secondDrug)){
				tranDAO.logTransaction(TransactionType.DRUG_INTERACTION, loggedInMID);
				return &quot;Interaction deleted successfully&quot;;
			} else {
				return &quot;Interaction could not be deleted&quot;;
			}
		} catch (DBException e){
			e.printStackTrace();
			throw new iTrustException(e.getMessage());
		}
	}
	
	/**
	 * Method to return a list of drug interactions for a given drug
	 * @param drugCode - The ND Code of the drug
	 * @return
	 */
	public List&lt;DrugInteractionBean&gt; getInteractions(String drugCode) throws iTrustException {
		try {
			return drugDAO.getInteractions(drugCode);
		} catch (DBException e){
			throw new iTrustException(e.getMessage());
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EditApptTypeAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.beans.ApptTypeBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.ApptTypeDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.validate.ApptTypeBeanValidator;

public class EditApptTypeAction {
	private long loggedInMID;
	private ApptTypeDAO apptTypeDAO;
	private TransactionDAO transDAO;
	private ApptTypeBeanValidator validator = new ApptTypeBeanValidator();
	
	public EditApptTypeAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.apptTypeDAO = factory.getApptTypeDAO();
		this.transDAO = factory.getTransactionDAO();
	}
	
	public List&lt;ApptTypeBean&gt; getApptTypes() throws SQLException {
		return apptTypeDAO.getApptTypes();
	}
	
	public String addApptType(ApptTypeBean apptType) throws SQLException, FormValidationException {
		validator.validate(apptType);
		
		List&lt;ApptTypeBean&gt; list = this.getApptTypes();
		for(ApptTypeBean a : list) {
			if(a.getName().equals(apptType.getName()))
				return &quot;Appointment Type: &quot;+apptType.getName()+&quot; already exists.&quot;;
		}
		
		try {
			if (apptTypeDAO.addApptType(apptType)) {
				transDAO.logTransaction(TransactionType.ADD_APPT_TYPE, loggedInMID, 0L,
						&quot;Added Appointment Type &quot; + apptType.getName());
				return &quot;Success: &quot; + apptType.getName() + &quot; - Duration: &quot; + apptType.getDuration() + &quot; added&quot;;
			} else
				return &quot;The database has become corrupt. Please contact the system administrator for assistance.&quot;;
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		} 
	}
	
	public String editApptType(ApptTypeBean apptType) throws SQLException, FormValidationException {
		validator.validate(apptType);
		
		List&lt;ApptTypeBean&gt; list = this.getApptTypes();
		int flag = 0;
		for(ApptTypeBean a : list) {
			if(a.getName().equals(apptType.getName())) {
				flag = 1;
				if(a.getDuration() == apptType.getDuration())
					return &quot;Appointment Type: &quot;+apptType.getName()+&quot; already has a duration of &quot;+apptType.getDuration()+&quot; minutes.&quot;;
				break;
			}
		}
		if(flag == 0) {
			return &quot;Appointment Type: &quot;+apptType.getName()+&quot; you are trying to update does not exist.&quot;;
		}
		
		try {
			if (apptTypeDAO.editApptType(apptType)) {
				transDAO.logTransaction(TransactionType.UPDATE_APPT_TYPE, loggedInMID, 0L,
						&quot;Updated Appointment Type &quot; + apptType.getName());
				return &quot;Success: &quot; + apptType.getName() + &quot; - Duration: &quot; + apptType.getDuration() + &quot; updated&quot;;
			} else
				return &quot;The database has become corrupt. Please contact the system administrator for assistance.&quot;;
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		}
	}
	
	public int getDurationByType(String at) throws SQLException {
		List&lt;ApptTypeBean&gt; list = this.getApptTypes();
		for(ApptTypeBean a : list) {
			if(a.getName().equals(at))
				return a.getDuration();
		}
		return 0;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EditHealthHistoryAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.action.base.PatientBaseAction;
import edu.ncsu.csc.itrust.beans.HealthRecord;
import edu.ncsu.csc.itrust.beans.forms.HealthRecordForm;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.HealthRecordsDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.HealthRecordFormValidator;

/**
 * Edits the health history of a patient, used by editBasicHealth.jsp
 * 
 * @author laurenhayward
 * 
 */
public class EditHealthHistoryAction extends PatientBaseAction {
	private TransactionDAO transDAO;
	private HealthRecordsDAO hrDAO;
	private AuthDAO authDAO;
	private long loggedInMID;
	private HealthRecordFormValidator validator = new HealthRecordFormValidator();

	/**
	 * The patient ID is validated by the superclass
	 * 
	 * @param factory The DAOFactory which will be used to generate the DAOs used for this action.
	 * @param loggedInMID The user authorizing this action.
	 * @param pidString The patient (or other user) who is being edited.
	 * @throws iTrustException
	 */
	public EditHealthHistoryAction(DAOFactory factory, long loggedInMID, String pidString)
			throws iTrustException {
		super(factory, pidString);
		this.hrDAO = factory.getHealthRecordsDAO();
		this.authDAO = factory.getAuthDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
	}

	/**
	 * returns the patient name
	 * 
	 * @return patient name
	 * @throws DBException
	 * @throws iTrustException
	 */
	public String getPatientName() throws DBException, iTrustException {
		return authDAO.getUserName(pid);
	}

	/**
	 * Adds a health record for the given patient
	 * 
	 * @param pid  The patient record who is being edited.
	 * @param hr  The filled out health record form to be added.
	 * @return message - &quot;Information Recorded&quot; or exception's message
	 * @throws FormValidationException
	 */
	public String addHealthRecord(long pid, HealthRecordForm hr) throws FormValidationException,
			iTrustException {
		validator.validate(hr);
		HealthRecord record = transferForm(pid, hr);
		hrDAO.add(record);
		transDAO.logTransaction(TransactionType.ENTER_EDIT_PHR, loggedInMID, pid, &quot;EditHealthHistory - Add Record&quot;);
		return &quot;Information Recorded&quot;;
	}

	
/**
 * Moves the information from the form to a HealthRecord
 * 
 * @param pid Patient of interest
 * @param form Form to be translated
 * @return a HealthRecord containing all the information in the form
 * @throws FormValidationException
 */
	
	private HealthRecord transferForm(long pid, HealthRecordForm form) throws FormValidationException {
		HealthRecord record = new HealthRecord();
		record.setPatientID(pid);
		record.setPersonnelID(loggedInMID);
		record.setBloodPressureD(Integer.valueOf(form.getBloodPressureD()));
		record.setBloodPressureN(Integer.valueOf(form.getBloodPressureN()));
		record.setCholesterolHDL(Integer.valueOf(form.getCholesterolHDL()));
		record.setCholesterolLDL(Integer.valueOf(form.getCholesterolLDL()));
		record.setCholesterolTri(Integer.valueOf(form.getCholesterolTri()));
		if (record.getTotalCholesterol() &lt; 100 || record.getTotalCholesterol() &gt; 600)
			throw new FormValidationException(&quot;Total cholesterol must be in [100,600]&quot;);
		record.setHeight(Double.valueOf(form.getHeight()));
		record.setWeight(Double.valueOf(form.getWeight()));
		record.setSmoker(Boolean.valueOf(form.getIsSmoker()));
		return record;
	}

	/**
	 * Returns a list of all HealthRecords for the given patient
	 * 
	 * @param pid  The ID of the patient to look up
	 * @return list of HealthRecords
	 * @throws iTrustException
	 */
	public List&lt;HealthRecord&gt; getAllHealthRecords(long pid) throws iTrustException {
		transDAO.logTransaction(TransactionType.VIEW_HEALTH_RECORDS, loggedInMID, pid, &quot;EditHealthHistory - View Records&quot;);
		return hrDAO.getAllHealthRecords(pid);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EditMonitoringListAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.beans.RemoteMonitoringDataBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.RemoteMonitoringDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Handles changes (adds and removes) to the monitoring list for a certain HCP.
 * 
 */
public class EditMonitoringListAction {
	private RemoteMonitoringDAO rmDAO;
	private TransactionDAO transDAO;
	private AuthDAO authDAO;
	private long loggedInMID;

	/**
	 * Constructor
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the HCP editing their monitoring list.
	 */
	public EditMonitoringListAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.rmDAO = factory.getRemoteMonitoringDAO();
		this.transDAO = factory.getTransactionDAO();
		this.authDAO = factory.getAuthDAO();
	}

	/**
	 * Adds a patient to the current HCP's remote monitoring list
	 * 
	 * @param patientMID the patient
	 * @return true if added successfully. False if already in list.
	 * @throws DBException
	 */
	public boolean addToList(long patientMID) throws DBException {
		transDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID, patientMID, &quot;add&quot;);
		return rmDAO.addPatientToList(patientMID, loggedInMID);
	}
	
	/**
	 * Removes a patient from the current HCP's remote monitoring list
	 * 
	 * @param patientMID the patient
	 * @return true if removed successfully. False if not in list.
	 * @throws DBException
	 */
	public boolean removeFromList(long patientMID) throws DBException {
		transDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID, patientMID, &quot;delete&quot;);
		return rmDAO.removePatientFromList(patientMID, loggedInMID);
	}
	
	/**
	 * Returns whether a patient is in an HCP's list already
	 * @param patientMID the patient
	 * @return true if in DB, false otherwise
	 * @throws DBException
	 */
	public boolean isPatientInList(long patientMID) throws DBException {
		List&lt;RemoteMonitoringDataBean&gt; dataset = rmDAO.getPatientsData(loggedInMID);
		for(RemoteMonitoringDataBean d: dataset) {
			if(d.getPatientMID() == patientMID)
				return true;
		}
		return false;
	}
	
	/**
	 * returns the patient name
	 * 
	 * @return patient name
	 * @throws DBException
	 * @throws iTrustException
	 */
	public String getPatientName(long pid) throws DBException, iTrustException {
		return authDAO.getUserName(pid);
	}
	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EditOfficeVisitAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import edu.ncsu.csc.itrust.action.base.OfficeVisitBaseAction;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.HospitalBean;
import edu.ncsu.csc.itrust.beans.LabProcedureBean;
import edu.ncsu.csc.itrust.beans.MedicationBean;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.beans.PrescriptionBean;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.DrugInteractionBean;
import edu.ncsu.csc.itrust.beans.AllergyBean;
import edu.ncsu.csc.itrust.beans.PrescriptionReportBean;
import edu.ncsu.csc.itrust.beans.forms.EditOfficeVisitForm;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AllergyDAO;
import edu.ncsu.csc.itrust.dao.mysql.DrugInteractionDAO;
import edu.ncsu.csc.itrust.dao.mysql.HospitalsDAO;
import edu.ncsu.csc.itrust.dao.mysql.LabProcedureDAO;
import edu.ncsu.csc.itrust.dao.mysql.NDCodesDAO;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.EditOfficeVisitValidator;

/**
 * Edits the office visits of a patient Used by editOfficeVisit.jsp
 * 
 * @author laurenhayward
 * 
 */
public class EditOfficeVisitAction extends OfficeVisitBaseAction {
	private EditOfficeVisitValidator validator = new EditOfficeVisitValidator();
	private PersonnelDAO personnelDAO;
	private HospitalsDAO hospitalDAO;
	private OfficeVisitDAO ovDAO;
	private LabProcedureDAO lpDAO;
	private TransactionDAO transDAO;
	private DrugInteractionDAO drugDAO;
	private AllergyDAO allergyDAO;
	private PatientDAO patDAO;
	private NDCodesDAO ndcDAO;
	private long loggedInMID;
	private long pid;

	/**
	 * Used to identify the subactions that can comprise an office visit action.
	 * Subactions help direct the action's logic because sometimes multiple 
	 * office visit actions can occur within one transaction.
	 */
	private enum OVSubAction {
		ADD_DIAGNOSIS,
		REMOVE_DIAGNOSIS,
		ADD_PROCEDURE,
		REMOVE_PROCEDURE,
		ADD_MEDICATION,
		REMOVE_MEDICATION,
		ADD_LAB_PROCEDURE,
		REMOVE_LAB_PROCEDURE,
		ADD_IMMUNIZATION,
		REMOVE_IMMUNIZATION
	};

	/**
	 * Patient id and office visit id validated by super class
	 * 
	 * @param factory The DAOFactory to be used in creating the DAOs for this action.
	 * @param loggedInMID The MID of the user who is authorizing this action.
	 * @param pidString The patient who this action is performed on.
	 * @param ovIDString The ID of the office visit in play.
	 * @throws iTrustException
	 */
	public EditOfficeVisitAction(DAOFactory factory, long loggedInMID, String pidString, String ovIDString)
			throws iTrustException {
		super(factory, pidString, ovIDString);
		pid = Long.parseLong(pidString);
		ovDAO = factory.getOfficeVisitDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.hospitalDAO = factory.getHospitalsDAO();
		this.lpDAO = factory.getLabProcedureDAO();
		this.transDAO = factory.getTransactionDAO();
		this.drugDAO = factory.getDrugInteractionDAO();
		this.allergyDAO = factory.getAllergyDAO();
		this.ndcDAO = factory.getNDCodesDAO();
		this.patDAO = factory.getPatientDAO();
		this.loggedInMID = loggedInMID;
	}

	/**
	 * Returns the office visit bean for the office visit
	 * 
	 * @return the OfficeVisitBean of the office visit
	 * @throws iTrustException
	 */
	public OfficeVisitBean getOfficeVisit() throws iTrustException {
		OfficeVisitBean officeVisit = ovDAO.getOfficeVisit(ovID);
		transDAO.logTransaction(TransactionType.VIEW_OFFICE_VISIT, loggedInMID, pid, &quot;EditOffceVisit - View office visits&quot;);
		return officeVisit;
	}
	
	/**
	 * Returns a list of the lab procedures that have been done in an office visit.
	 * 
	 * @param mid the doctor the visit was with
	 * @param ovid the office visit's id
	 * @return a list of the lab procedures that were done in that visit
	 * @throws DBException
	 */

	public List&lt;LabProcedureBean&gt; getLabProcedures(long mid, long ovid) throws DBException {
		transDAO.logTransaction(TransactionType.VIEW_LAB_PROCEDURE, loggedInMID, pid, &quot;EditOffceVisit - View lab procedures&quot;);
		return lpDAO.getAllLabProceduresForDocOV(mid, ovid);
	}

	/**
	 * This is a list of all hospitals, ordered by the office visit's hcp FIRST
	 * 
	 * @param hcpID
	 * @return
	 * @throws iTrustException
	 */
	public List&lt;HospitalBean&gt; getHospitals(long hcpID) throws iTrustException {
		List&lt;HospitalBean&gt; hcpsHospitals = personnelDAO.getHospitals(hcpID);
		List&lt;HospitalBean&gt; allHospitals = hospitalDAO.getAllHospitals();
		return combineLists(hcpsHospitals, allHospitals);
	}

	
	/**
	 * Combines two lists of hospitals
	 * 
	 * @param hcpsHospitals hospitals the HCP is assigned to
	 * @param allHospitals all hopsitals
	 * @return the combined list
	 */
	private List&lt;HospitalBean&gt; combineLists(List&lt;HospitalBean&gt; hcpsHospitals, List&lt;HospitalBean&gt; allHospitals) {
		for (HospitalBean hos : allHospitals) {
			if (!hcpsHospitals.contains(hos))
				hcpsHospitals.add(hos);
		}
		return hcpsHospitals;
	}

	/**
	 * Updates the office visit with information from the form passed in
	 * 
	 * @param form
	 *            information to update
	 * @return &quot;success&quot; or exception's message
	 * @throws FormValidationException
	 */
	public String updateInformation(EditOfficeVisitForm form) throws FormValidationException {
		String confirm = &quot;&quot;;
		try {
			checkAddSubAction(OVSubAction.ADD_DIAGNOSIS, form.getAddDiagID(), ovID, null);
			checkAddSubAction(OVSubAction.ADD_PROCEDURE, form.getAddProcID(), ovID, null);
			checkAddSubAction(OVSubAction.ADD_IMMUNIZATION, form.getAddImmunizationID(), ovID, null, form.getHcpID());
			checkAddSubAction(OVSubAction.ADD_LAB_PROCEDURE, form.getAddLabProcID(), ovID, null);
			checkAddPrescription(form, ovID);
			checkRemoveSubAction(OVSubAction.REMOVE_DIAGNOSIS, form.getRemoveDiagID());
			checkRemoveSubAction(OVSubAction.REMOVE_LAB_PROCEDURE, form.getRemoveLabProcID());
			checkRemoveSubAction(OVSubAction.REMOVE_PROCEDURE, form.getRemoveProcID());
			checkRemoveSubAction(OVSubAction.REMOVE_IMMUNIZATION, form.getRemoveImmunizationID());
			checkRemoveSubAction(OVSubAction.REMOVE_MEDICATION, form.getRemoveMedID());
			updateOv(form);
			transDAO.logTransaction(TransactionType.DOCUMENT_OFFICE_VISIT, loggedInMID, getOfficeVisit().getPatientID(), &quot;EditOfficeVisit - edited office visit &quot; + ovID);
			confirm = &quot;success&quot;;
			return confirm;
		} catch (iTrustException e) {
			e.printStackTrace();
			return e.getMessage();
		}
	}
	
	public String hasInteraction(String drug, String pid, String startdate, String enddate) throws iTrustException{
		String response = &quot;&quot;;
		try {

			SimpleDateFormat original = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;);
			SimpleDateFormat needed = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);
			
			Date start = original.parse(startdate);
			startdate = needed.format(start);
			Date end = original.parse(enddate);
			enddate = needed.format(end);
			
			
			startdate = startdate.replaceAll(&quot;/&quot;, &quot;-&quot;);
			enddate = enddate.replaceAll(&quot;/&quot;, &quot;-&quot;);
			List&lt;PrescriptionReportBean&gt; prBeanList = ovDAO.getPrescriptionReportsByDate(Long.parseLong(pid), startdate, enddate);
			List&lt;DrugInteractionBean&gt; dBeanList = drugDAO.getInteractions(drug);
			for (PrescriptionReportBean prBean : prBeanList){
				String presDrug = prBean.getPrescription().getMedication().getNDCode();
				for (DrugInteractionBean dBean : dBeanList){
					String intDrug1 = dBean.getFirstDrug();
					String intDrug2 = dBean.getSecondDrug();
					
					if (presDrug.equals(intDrug1) &amp;&amp; drug.equals(intDrug2)){
						response += &quot;Currently Prescribed: &quot; + prBean.getPrescription().getMedication().getDescription() + 
						&quot;. Start Date: &quot; + prBean.getPrescription().getStartDateStr() 
						+ &quot;, End Date: &quot; + prBean.getPrescription().getEndDateStr() + &quot;. &quot;;
						response += &quot;Interactions: &quot; + prBean.getPrescription().getMedication().getDescription() + &quot; - &quot; + ndcDAO.getNDCode((dBean.getSecondDrug())).getDescription() + &quot;. &quot;;
						response += &quot;Description: &quot; + dBean.getDescription() + &quot;  &quot;;
					} else if (presDrug.equals(intDrug2) &amp;&amp; drug.equals(intDrug1)){
						response += &quot;Currently Prescribed: &quot; + prBean.getPrescription().getMedication().getDescription() + &quot;. Start Date: &quot; + prBean.getPrescription().getStartDateStr() 
						+ &quot;, End Date: &quot; + prBean.getPrescription().getEndDateStr() + &quot;. &quot;;
						response += &quot;Interactions: &quot; + prBean.getPrescription().getMedication().getDescription() + &quot; - &quot; + ndcDAO.getNDCode(dBean.getFirstDrug()).getDescription() + &quot;. &quot;;
						response += &quot;Description: &quot; + dBean.getDescription() + &quot;  &quot;;
					}
				}
			}

		} catch (DBException e){
			e.printStackTrace();
			throw new iTrustException(e.getMessage());
		} catch (ParseException e){
			e.printStackTrace();
			throw new iTrustException(e.getMessage());
		}
		return response;
	}
	
	public String  isAllergyOnList(String patMID, String ndcode) throws iTrustException{
		String response = &quot;&quot;;
		try {
			List&lt;AllergyBean&gt; allergyList = allergyDAO.getAllergies(Long.parseLong(patMID));
			if (allergyList.isEmpty()) return response;
			MedicationBean medBean = ndcDAO.getNDCode(ndcode);
			if(medBean == null) return response;
			String newDrug = medBean.getDescription();
			for (AllergyBean allergyBean : allergyList){
				String currentAllerDrug = allergyBean.getDescription();
				//Allergy: Aspirin. First Found: 12/20/2008. 
				if (newDrug.equals(currentAllerDrug)){
					response += &quot;Allergy: &quot; + newDrug + &quot;. First Found: &quot; + allergyBean.getFirstFoundStr();
				}
			}
		} catch (DBException e){
			e.printStackTrace();
			throw new iTrustException(e.getMessage());
		}
		return response;
	}
	
	/**
	 * 
	 * Sends e-mail regarding the prescribed dangerous drug.
	 * 
	 * @param hcpID HCP the prescription is made by
	 * @param patID ID of the patient prescription is for
	 * @param problem The allergy and/or interaction that is the problem
	 * @return the sent e-mail
	 * @throws DBException
	 */	
	public Email makeEmailApp(long hcpID, String patID, String problem) throws DBException, iTrustException {
		PatientBean p = patDAO.getPatient(Long.parseLong(patID));
		String hcpName = personnelDAO.getName(hcpID);
		Email email = new Email();
		email.setFrom(&quot;no-reply@itrust.com&quot;);
		email.setToList(Arrays.asList(p.getEmail()));
		email.setSubject(&quot;HCP has prescribed you a potentially dangerous medication&quot;);
		email.setBody(String
				.format(
					&quot;%s has prescribed a medication that you are allergic to or that has a known interaction with a drug you are currently taking. %s&quot;,
					hcpName, problem));
		return email;
	}
	
/**
 * Adds a prescription to an office visit
 * 
 * @param form the information about the prescription
 * @param ovID the id for the office visit
 * @throws DBException
 * @throws FormValidationException
 */
	
	private void checkAddPrescription(EditOfficeVisitForm form, long ovID) throws DBException,
			FormValidationException {
		if (form.getAddMedID() != null &amp;&amp; !&quot;&quot;.equals(form.getAddMedID())) {
			new EditOfficeVisitValidator(true).validate(form);
			PrescriptionBean pres = new PrescriptionBean();
			pres.setDosage(Integer.valueOf(form.getDosage()));
			pres.setEndDateStr(form.getEndDate());
			pres.setStartDateStr(form.getStartDate());
			pres.setInstructions(form.getInstructions());
			MedicationBean med = new MedicationBean();
			med.setNDCode(form.getAddMedID());
			pres.setMedication(med);
			pres.setVisitID(ovID);
			transDAO.logTransaction(TransactionType.ADD_PRESCRIPTION, loggedInMID, pid, &quot;EditOffceVisit - Add prescription - &quot; + pres.getMedication().getNDCode());
			ovDAO.addPrescription(pres);
		}
	}

	/**
	 * Updates the office visit.
	 * 
	 * @param form form with all the information
	 * @throws DBException
	 * @throws FormValidationException
	 */
	private void updateOv(EditOfficeVisitForm form) throws DBException, FormValidationException {
		validator.validate(form);
		OfficeVisitBean ov = new OfficeVisitBean(ovID);
		ov.setNotes(form.getNotes());
		ov.setVisitDateStr(form.getVisitDate());
		ov.setHcpID(Long.valueOf(form.getHcpID()));
		ov.setPatientID(Long.valueOf(form.getPatientID()));
		ov.setHospitalID(form.getHospitalID());
		transDAO.logTransaction(TransactionType.UPDATE_OFFICE_VISIT, loggedInMID, pid, &quot;EditOffceVisit - Update office visit&quot;);
		ovDAO.update(ov);
	}

	
	/**
	 * Adds a diagnosis or a procedure to an office visit
	 * 
	 * @param action the type of action to add
	 * @param code the CPT code of the action
	 * @param visitID the office visit to add the action to
	 * @param dateOfDeath the date of death, if needed
	 * @return true if the operation completed; false if the code was null
	 * @throws DBException
	 * @throws iTrustException
	 */
	
	private boolean checkAddSubAction(OVSubAction action, String code, long visitID, String dateOfDeath)
			throws DBException, iTrustException {
		if (code == null || &quot;&quot;.equals(code)) {
			return false;
		} else {
			switch (action) {
			case ADD_DIAGNOSIS:
				ovDAO.addDiagnosisToOfficeVisit(Double.valueOf(code), visitID);
				break;
			case ADD_IMMUNIZATION:
			case ADD_PROCEDURE:
				ovDAO.addProcedureToOfficeVisit(code, visitID, &quot;&quot;);
				break;
			case ADD_LAB_PROCEDURE:
				ovDAO.addLabProcedureToOfficeVisit(code, visitID, pid);
				break;
			default:
				return false;
			}
			return true;
		}
	}
	
	private boolean checkAddSubAction(OVSubAction action, String code, long visitID, String dateOfDeath, String hcpid)
	throws DBException, iTrustException {
		if (code == null || &quot;&quot;.equals(code)) {
			return false;
		} else {
			ovDAO.addProcedureToOfficeVisit(code, visitID, hcpid);
			return true;
		}
	 }
	
	/**
	 * Removes an action from an office visit
	 * 
	 * @param action type of action to remove
	 * @param input id for the action to remove
	 * @return true if the operation completed; false if the code was null
	 * @throws DBException
	 */

	private boolean checkRemoveSubAction(OVSubAction action, String input) throws DBException {
		if (input == null || &quot;&quot;.equals(input))
			return false;
		long removeID;
		try {
			removeID = Long.valueOf(input);
		} catch (NumberFormatException e) {
			e.printStackTrace();
			return false;
		}
		switch (action) {
		case REMOVE_DIAGNOSIS:
			ovDAO.removeDiagnosisFromOfficeVisit(removeID);
			break;
		case REMOVE_IMMUNIZATION:
		case REMOVE_PROCEDURE:
			ovDAO.removeProcedureFromOfficeVisit(removeID);
			break;
		case REMOVE_MEDICATION:
			ovDAO.removePrescription(removeID);
			break;
		case REMOVE_LAB_PROCEDURE:
			ovDAO.removeLabProcedureFromOfficeVisit(removeID);
			break;
		}
		return true;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EditPHRAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.EmailUtil;
import edu.ncsu.csc.itrust.action.base.PatientBaseAction;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.beans.AllergyBean;
import edu.ncsu.csc.itrust.beans.DiagnosisBean;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.FamilyMemberBean;
import edu.ncsu.csc.itrust.beans.HealthRecord;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AllergyDAO;
import edu.ncsu.csc.itrust.dao.mysql.FamilyDAO;
import edu.ncsu.csc.itrust.dao.mysql.HealthRecordsDAO;
import edu.ncsu.csc.itrust.dao.mysql.ICDCodesDAO;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.NoHealthRecordsException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.risk.ChronicDiseaseMediator;
import edu.ncsu.csc.itrust.risk.RiskChecker;
import edu.ncsu.csc.itrust.validate.AllergyBeanValidator;


/**
 * Edits the patient health record for a given patient Used by editPHR.jsp
 * 
 * @author laurenhayward
 * 
 */
public class EditPHRAction extends PatientBaseAction {
	private DAOFactory factory;
	private PatientDAO patientDAO;
	private AllergyDAO allergyDAO;
	private FamilyDAO familyDAO;
	private HealthRecordsDAO hrDAO;
	private OfficeVisitDAO ovDAO;
	private TransactionDAO transDAO;
	private ICDCodesDAO icdDAO;
	private long loggedInMID;
	private ChronicDiseaseMediator diseaseMediator;
	private PersonnelDAO personnelDAO;
	private PersonnelBean HCPUAP;
	private PatientBean patient;
	private EmailUtil emailutil;
	
	/**
	 * Super class validates the patient id
	 * 
	 * @param factory The DAOFactory to be used in creating DAOs for this action.
	 * @param loggedInMID The MID of the currently logged in user who is authorizing this action.
	 * @param pidString The MID of the patient whose personal health records are being added.
	 * @throws iTrustException
	 * @throws DBException
	 * @throws NoHealthRecordsException
	 */
	public EditPHRAction(DAOFactory factory, long loggedInMID, String pidString) throws iTrustException,
			DBException {
		super(factory, pidString);
		this.patientDAO = factory.getPatientDAO();
		this.allergyDAO = factory.getAllergyDAO();
		this.familyDAO = factory.getFamilyDAO();
		this.hrDAO = factory.getHealthRecordsDAO();
		this.ovDAO = factory.getOfficeVisitDAO();
		this.transDAO = factory.getTransactionDAO();
		this.icdDAO = factory.getICDCodesDAO();
		this.loggedInMID = loggedInMID;
		this.personnelDAO = factory.getPersonnelDAO();
		this.HCPUAP = personnelDAO.getPersonnel(loggedInMID);
		this.patient = patientDAO.getPatient(pid);
		emailutil = new EmailUtil(factory);
		this.factory = factory;
	}

	/**
	 * Adds an allergy to the patient's records
	 * 
	 * @param pid
	 * @param description
	 * @return &quot;Allergy Added&quot;, exception message, a list of invalid fields, or &quot;&quot; (only if description is
	 *         null)
	 * @throws iTrustException
	 */
	public String updateAllergies(long pid, String description) throws iTrustException {
		
		emailutil.sendEmail(makeEmail());
		
		if (description != null &amp;&amp; !description.equals(&quot;&quot;)) {
			try {
				AllergyBean bean = new AllergyBean();
				bean.setDescription(description);
				AllergyBeanValidator abv = new AllergyBeanValidator();
				abv.validate(bean);
				allergyDAO.addAllergy(pid, description);
				transDAO.logTransaction(TransactionType.ENTER_EDIT_PHR, loggedInMID, pid, &quot;EditPHR - added allergy &quot; + description);
				return &quot;Allergy Added&quot;;
			} catch (FormValidationException e2) {
				return &quot;&lt;span class=error&gt;Error: Invalid Fields--&quot; + e2.getErrorList() + &quot;&lt;/span&gt;&lt;p /&gt;&quot;;
			}
		} else
			return &quot;&quot;;
	}

	/**
	 * Returns a PatientBean for the patient
	 * 
	 * @return PatientBean
	 * @throws iTrustException
	 */
	public PatientBean getPatient() throws iTrustException {
		transDAO.logTransaction(TransactionType.VIEW_RECORDS, loggedInMID, pid, &quot;EditPHR - view patient record &quot;);
		return patientDAO.getPatient(pid);
	}

	/**
	 * Returns a list of AllergyBeans for the patient
	 * 
	 * @return list of AllergyBeans
	 * @throws iTrustException
	 */
	public List&lt;AllergyBean&gt; getAllergies() throws iTrustException {
		return allergyDAO.getAllergies(pid);
	}

	/**
	 * Returns a list of FamilyMemberBeans for the patient
	 * 
	 * @return list of FamilyMemberBeans
	 * @throws iTrustException
	 */
	public List&lt;FamilyMemberBean&gt; getFamily() throws iTrustException {
		List&lt;FamilyMemberBean&gt; fam = new ArrayList&lt;FamilyMemberBean&gt;();
		List&lt;FamilyMemberBean&gt; parents = null;
		parents = familyDAO.getParents(pid);
		fam.addAll(parents);
		fam.addAll(familyDAO.getSiblings(pid));
		fam.addAll(familyDAO.getChildren(pid));

		
		if(parents != null) {
			List&lt;FamilyMemberBean&gt; grandparents = new ArrayList&lt;FamilyMemberBean&gt;();
			for(FamilyMemberBean parent : parents) {
				grandparents.addAll(familyDAO.getParents(parent.getMid()));
			}
			
			fam.addAll(grandparents);
			
			for(FamilyMemberBean gp : grandparents) {
				gp.setRelation(&quot;Grandparent&quot;);
			}
		}
		transDAO.logTransaction(TransactionType.VIEW_RECORDS, loggedInMID, pid, &quot;EditPHR - view patient family information &quot;);
		return fam;
	}


	/**
	 * Returns a list of HealthRecords for the patient
	 * 
	 * @return
	 * @throws iTrustException
	 */
	public List&lt;HealthRecord&gt; getAllHealthRecords() throws iTrustException {
		List&lt;HealthRecord&gt; allHealthRecords = hrDAO.getAllHealthRecords(pid);
		transDAO.logTransaction(TransactionType.VIEW_HEALTH_RECORDS, loggedInMID, pid, &quot;EditPHR - Viewed patient records&quot;);
		return allHealthRecords;
	}

	/**
	 * Returns a list of OfficeVisitBeans
	 * 
	 * @return
	 * @throws iTrustException
	 */
	public List&lt;OfficeVisitBean&gt; getAllOfficeVisits() throws iTrustException {
		transDAO.logTransaction(TransactionType.VIEW_OFFICE_VISIT, loggedInMID, pid, &quot;EditPHR - view patient office visits &quot;);
		return ovDAO.getAllOfficeVisits(pid);
	}

	/**
	 * Returns a complete OfficeVisitBean given a visitID
	 * 
	 * @return
	 * @throws iTrustException
	 */
	public OfficeVisitBean getCompleteOfficeVisit(long visitID) throws iTrustException {
		return ovDAO.getOfficeVisit(visitID);
	}
	
	/**
	 * Returns a list of diseases for which the patient is at risk
	 * 
	 * @return list of RiskCheckers
	 * @throws iTrustException
	 * @throws DBException
	 */
	public List&lt;RiskChecker&gt; getDiseasesAtRisk() throws NoHealthRecordsException,iTrustException,DBException {
		this.diseaseMediator = new ChronicDiseaseMediator(factory, pid);
		transDAO.logTransaction(TransactionType.IDENTIFY_RISK_FACTORS, loggedInMID, pid, &quot;Check for risk factors&quot;);
		return diseaseMediator.getDiseaseAtRisk();
	}
	
	/**
	 * Checks to see if a particular family member has high blood pressure
	 * 
	 * @param member the family member to check
	 * @return true if the family member has high blood pressure.  False if there are no records or the family member does not have high blood pressure
	 * @throws iTrustException
	 */
	public boolean doesFamilyMemberHaveHighBP(FamilyMemberBean member) throws iTrustException {
		List&lt;HealthRecord&gt; records = hrDAO.getAllHealthRecords(member.getMid());
		if(records.size() == 0)
			return false;
		for(HealthRecord record : records) {
			if(record.getBloodPressureSystolic() &gt; 240 || record.getBloodPressureDiastolic() &gt; 120 )
				return true;
		}
		return false;
	}
	
	/**
	 * Checks to see if a particular family member has high cholesterol
	 * 
	 * @param member the family member to check
	 * @return true if the family member has high cholesterol.  False if there are no records or the family member does not
	 * @throws iTrustException
	 */	
	public boolean doesFamilyMemberHaveHighCholesterol(FamilyMemberBean member) throws iTrustException {
		List&lt;HealthRecord&gt; records = hrDAO.getAllHealthRecords(member.getMid());
		if(records.size() == 0)
			return false;
		for(HealthRecord record : records) {
			if(record.getCholesterolHDL() &lt; 35 || record.getCholesterolLDL() &gt; 250 )
				return true;
		}
		return false;
	}
	
	/**
	 * Checks to see if a particular family member has diabetes
	 * 
	 * @param member the family member to check
	 * @return true if the family member has diabetes.  False if there are no records or the family member does not
	 * @throws iTrustException
	 */	

	public boolean doesFamilyMemberHaveDiabetes(FamilyMemberBean member) throws iTrustException {
		List&lt;DiagnosisBean&gt; diagnoses = patientDAO.getDiagnoses(member.getMid());
		if(diagnoses.size() == 0)
			return false;
		for(DiagnosisBean diag : diagnoses) {
			if(diag.getICDCode().startsWith(&quot;250&quot;))
				return true;
		}
		return false;
	}
	
	/**
	 * Checks to see if a particular family member has cancer
	 * 
	 * @param member the family member to check
	 * @return true if the family member has cancer.  False if there are no records or the family member does not
	 * @throws iTrustException
	 */	

	public boolean doesFamilyMemberHaveCancer(FamilyMemberBean member) throws iTrustException {
		List&lt;DiagnosisBean&gt; diagnoses = patientDAO.getDiagnoses(member.getMid());
		if(diagnoses.size() == 0)
			return false;
		for(DiagnosisBean diag : diagnoses) {
			if(diag.getICDCode().startsWith(&quot;199&quot;))
				return true;
		}
		return false;
	}
	
	/**
	 * Checks to see if a particular family member has heart disease
	 * 
	 * @param member the family member to check
	 * @return true if the family member has heart disease.  False if there are no records or the family member does not
	 * @throws iTrustException
	 */	
	public boolean doesFamilyMemberHaveHeartDisease(FamilyMemberBean member) throws iTrustException {
		List&lt;DiagnosisBean&gt; diagnoses = patientDAO.getDiagnoses(member.getMid());
		if(diagnoses.size() == 0)
			return false;
		for(DiagnosisBean diag : diagnoses) {
			if(diag.getICDCode().startsWith(&quot;402&quot;))
				return true;
		}
		return false;
	}
	
	/**
	 * Checks to see if a particular family member smokes
	 * 
	 * @param member the family member to check
	 * @return true if the family member smokes.  False if there are no records or the family member does not
	 * @throws iTrustException
	 */	
	public boolean isFamilyMemberSmoker(FamilyMemberBean member) throws iTrustException {
		List&lt;HealthRecord&gt; records = hrDAO.getAllHealthRecords(member.getMid());
		if(records.size() == 0)
			return false;
		for(HealthRecord record : records) {
			if(record.isSmoker())
				return true;
		}
		return false;
	}
	

	/**
	 * Checks to see if the family member is dead and returns their cause of death if so
	 * 
	 * @param member the family member to check
	 * @return the cause of death if there is one; otherwise null
	 * @throws iTrustException
	 */
	public String getFamilyMemberCOD(FamilyMemberBean member) throws iTrustException {
		PatientBean patient = patientDAO.getPatient(member.getMid());
		if(patient.getCauseOfDeath() == null)
			return &quot;&quot;;
		DiagnosisBean diag = icdDAO.getICDCode(patient.getCauseOfDeath());
		if(diag == null)
			return &quot;&quot;;
		return diag.getDescription();
	}
	
	/**
	 * Creates a fake e-mail to notify the user that their records have been altered.
	 * 
	 * @return the e-mail to be sent
	 * @throws DBException
	 */
	private Email makeEmail() throws DBException{

		Email email = new Email();
		List&lt;PatientBean&gt; reps = patientDAO.getRepresenting(patient.getMID());
		
		List&lt;String&gt; toAddrs = new ArrayList&lt;String&gt;();
		toAddrs.add(patient.getEmail());
		for (PatientBean r: reps) {
			toAddrs.add(r.getEmail());
		}
		
		email.setFrom(&quot;no-reply@itrust.com&quot;);
    	email.setToList(toAddrs); // patient and personal representative
    	email.setSubject(String.format(&quot;Your medical records have been altered&quot;));
    	email.setBody(&quot;Health care professional &quot;+ HCPUAP.getFullName() +&quot; has altered your medical records. &quot; +
    				&quot;She is not on your list of designated health care professionals.&quot;);
		return email;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EditPatientAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.action.base.PatientBaseAction;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.PatientValidator;
import edu.ncsu.csc.itrust.EmailUtil;


/**
 * Edits a patient Used by editPatient.jsp
 * 
 * @author laurenhayward
 * 
 */
public class EditPatientAction extends PatientBaseAction {
	private TransactionDAO transDAO;
	private PatientValidator validator = new PatientValidator();
	private PatientDAO patientDAO;
	private long loggedInMID;
	private EmailUtil emailutil;

	/**
	 * The super class validates the patient id
	 * 
	 * @param factory The DAOFactory used to create the DAOs for this action.
	 * @param loggedInMID The MID of the user who is authorizing this action.
	 * @param pidString The MID of the patient being edited.
	 * @throws iTrustException
	 */
	public EditPatientAction(DAOFactory factory, long loggedInMID, String pidString) throws iTrustException {
		super(factory, pidString);
		this.patientDAO = factory.getPatientDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
		emailutil = new EmailUtil(factory);
	}

	/**
	 * Takes the information out of the PatientBean param and updates the patient's information
	 * 
	 * @param p
	 *            the new patient information
	 * @throws iTrustException
	 * @throws FormValidationException
	 */
	public void updateInformation(PatientBean p) throws iTrustException, FormValidationException {
		p.setMID(pid); // for security reasons
		validator.validate(p);
		patientDAO.editPatient(p);
		transDAO.logTransaction(TransactionType.ENTER_EDIT_DEMOGRAPHICS, loggedInMID, pid, &quot;EditPatient - Made Changes&quot;);
		emailutil.sendEmail(makeEmail());
	}

	/**
	 * Returns a PatientBean for the patient
	 * 
	 * @return the PatientBean
	 * @throws DBException
	 */
	public PatientBean getPatient() throws DBException {
		transDAO.logTransaction(TransactionType.ENTER_EDIT_DEMOGRAPHICS, loggedInMID, pid, &quot;EditPatient - View Patient&quot;);
		return patientDAO.getPatient(this.getPid());
	}

	/**
	 *  Creates and e-mail to inform the patient that their information has been updated.
	 *  
	 * @return the email with the notice
	 * @throws DBException
	 */
	private Email makeEmail() throws DBException{

		Email email = new Email();
		List&lt;PatientBean&gt; reps = patientDAO.getRepresenting(pid);
		PatientBean pb = patientDAO.getPatient(pid);
		
		List&lt;String&gt; toAddrs = new ArrayList&lt;String&gt;();
		toAddrs.add(pb.getEmail());
		for (PatientBean r: reps) {
			toAddrs.add(r.getEmail());
		}
		
		email.setFrom(&quot;no-reply@itrust.com&quot;);
    	email.setToList(toAddrs); // patient and personal representative
    	email.setSubject(String.format(&quot;Patient Information Updated&quot;));
    	email.setBody(&quot;Dear &quot; + pb.getFullName() + &quot;,\n\tYour patient record information has been updated. &quot; + 
    			&quot;Please login to iTrust to see who has viewed your records.&quot;);
		return email;
	}
	
	public void editMessageFilter(String filter) throws iTrustException, FormValidationException {
		PatientBean b = this.getPatient();
		b.setMessageFilter(filter);
		this.updateInformation(b);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EditPersonnelAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.action.base.PersonnelBaseAction;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.Role;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.PersonnelValidator;

/**
 * Edits the designated personnel Used by admin/editPersonnel.jsp, staff/editMyDemographics.jsp,
 * editPersonnel.jsp
 * 
 * @author laurenhayward
 * 
 */
public class EditPersonnelAction extends PersonnelBaseAction {
	private long loggedInMID;
	private PersonnelDAO personnelDAO;
	private TransactionDAO transDAO;
	private AuthDAO authDAO;
	private PersonnelValidator validator = new PersonnelValidator();;

	/**
	 * Super class validates the patient id
	 * 
	 * @param factory The DAOFactory used to create the DAOs for this action.
	 * @param loggedInMID The MID of the user editing this personnel.
	 * @param pidString The ID of the user being edited.
	 * @throws iTrustException
	 */
	public EditPersonnelAction(DAOFactory factory, long loggedInMID, String pidString) throws iTrustException {
		super(factory, pidString);

		this.authDAO = factory.getAuthDAO();
		long pidlong = Long.parseLong(pidString);
		Role editor = authDAO.getUserRole(loggedInMID);
		Role editing = authDAO.getUserRole(pidlong);

		if (editor == editing &amp;&amp; pidlong != loggedInMID)
			throw new iTrustException(&quot;You can only edit your own demographics!&quot;);
		else if (editor == Role.HCP &amp;&amp; editing == Role.ADMIN || editor == Role.UAP &amp;&amp; editing == Role.HCP
				|| editor == Role.ADMIN &amp;&amp; editing == Role.UAP)
			throw new iTrustException(&quot;You are not authorized to edit this record!&quot;);

		this.personnelDAO = factory.getPersonnelDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
	}

	/**
	 * Takes information from the personnelForm param and updates the patient
	 * 
	 * @param personnelForm
	 *            PersonnelBean with new information
	 * @throws iTrustException
	 * @throws FormValidationException
	 */
	public void updateInformation(PersonnelBean personnelForm) throws iTrustException,
			FormValidationException {
		personnelForm.setMID(pid);
		validator.validate(personnelForm);
		personnelDAO.editPersonnel(personnelForm);
		transDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID);
	}
	
	public void editMessageFilter(String filter) throws iTrustException, FormValidationException {
		PersonnelBean b = personnelDAO.getPersonnel(this.getPid());
		b.setMessageFilter(filter);
		this.updateInformation(b);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EditPrescriptionAction</id>
            <content>package edu.ncsu.csc.itrust.action;


import edu.ncsu.csc.itrust.beans.PrescriptionBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;


/**
 * Edits a patient's prescription information.  Used by hcp-uap/editPrescription.jsp
 * @author Ben Smith
 */
public class EditPrescriptionAction {

	private OfficeVisitDAO ovDAO;


	/**
	 * Creates a new action by initializing the office visit
	 * database access object.
	 * 
	 * @param factory
	 * @throws iTrustException
	 */
	public EditPrescriptionAction(DAOFactory factory) throws iTrustException {
		this.ovDAO = factory.getOfficeVisitDAO();

	}

	/**
	 * Edits an existing prescription in the database.
	 * 
	 * @param pres The prescription bean that has been changed.
	 * @throws DBException
	 */
	public void editPrescription(PrescriptionBean pres) throws DBException {
		
		ovDAO.editPrescription(pres);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EditRepresentativesAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.action.base.PatientBaseAction;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.Role;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Edits a patient's personal representatives. Used by hcp/editRepresentatives.jsp
 * 
 * @author laurenhayward
 * 
 */
public class EditRepresentativesAction extends PatientBaseAction {
	private PatientDAO patientDAO;
	private TransactionDAO transDAO;
	private AuthDAO authDAO;
	private long loggedInMID;

	/**
	 * Super class validates the patient mid
	 * 
	 * @param factory The DAOFactory used in creating the DAOs for this action.
	 * @param loggedInMID The MID of the patient editing his/her representatives.
	 * @param pidString The MID of the representative in question.
	 * @throws iTrustException
	 */
	public EditRepresentativesAction(DAOFactory factory, long loggedInMID, String pidString)
			throws iTrustException {
		super(factory, pidString);
		this.loggedInMID = loggedInMID;
		this.transDAO = factory.getTransactionDAO();
		this.patientDAO = factory.getPatientDAO();
		this.authDAO = factory.getAuthDAO();
	}

	/**
	 * Return a list of patients that pid represents
	 * 
	 * @param pid The id of the personnel we are looking up representees for.
	 * @return a list of PatientBeans
	 * @throws iTrustException
	 */
	public List&lt;PatientBean&gt; getRepresented(long pid) throws iTrustException {
		return patientDAO.getRepresented(pid);
	}

	/**
	 * Makes the patient (pid) represent the input mid parameter
	 * 
	 * @param pidString
	 *            the mid of the person who will be represented (the representee)
	 * @return a message
	 * @throws iTrustException
	 */
	public String addRepresentative(String pidString) throws iTrustException {
		try {
			long representee = Long.valueOf(pidString);
			if (authDAO.getUserRole(representee) != Role.PATIENT)
				throw new iTrustException(&quot;This user is not a patient!&quot;);
			else if (super.pid == representee)
				throw new iTrustException(&quot;This user cannot represent themselves.&quot;);

			boolean confirm = patientDAO.addRepresentative(pid, representee);
			if (confirm) {
				transDAO.logTransaction(TransactionType.DECLARE_REPRESENTATIVE, loggedInMID, pid, &quot;patient &quot;
						+ pid + &quot; now represents patient &quot; + representee);
				return &quot;Patient represented&quot;;
			} else
				return &quot;No change made&quot;;
		} catch (NumberFormatException e) {
			return &quot;MID not a number&quot;;
		}
	}

	/**
	 * Makes the patient (pid) no longer represent the input mid param
	 * 
	 * @param input
	 *            the mid of the person be represented (representee)
	 * @return a message
	 * @throws iTrustException
	 */
	public String removeRepresentative(String input) throws iTrustException {
		try {
			long representee = Long.valueOf(input);
			boolean confirm = patientDAO.removeRepresentative(pid, representee);
			if (confirm) {
				transDAO.logTransaction(TransactionType.DECLARE_REPRESENTATIVE, loggedInMID, pid, &quot;patient &quot;
						+ pid + &quot; no longer represents patient &quot; + representee);
				return &quot;Patient represented&quot;;
			} else
				return &quot;No change made&quot;;
		} catch (NumberFormatException e) {
			return &quot;MID not a number&quot;;
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EmergencyReportAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.ArrayList;
import java.util.List;
import java.util.Calendar;
import edu.ncsu.csc.itrust.action.base.PatientBaseAction;
import edu.ncsu.csc.itrust.beans.AllergyBean;
import edu.ncsu.csc.itrust.beans.DiagnosisBean;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.PrescriptionBean;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AllergyDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.enums.PrescriptionAlerts;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.EmailUtil;
import edu.ncsu.csc.itrust.beans.ProcedureBean;

/**
 * Creates a new Emergency Report Used by emergencyReport.jsp
 * 
 * @author laurenhayward
 * 
 */
public class EmergencyReportAction extends PatientBaseAction {
	private TransactionDAO transDAO;
	private PatientDAO patientDAO;
	private AllergyDAO allergyDAO;
	private OfficeVisitDAO ovDAO;
	private PatientBean pb;
	private EmailUtil emailutil;
	private long loggedInMID;

	/**
	 * The super class handles validating the pid Logs viewing of the report
	 * 
	 * @param factory The DAOFactory used in creating the DAOs for this action.
	 * @param loggedInMID The MID of the user who is looking at the emergency report.
	 * @param pidString The ID of the patient whose report is being generated.
	 * @throws iTrustException
	 */
	public EmergencyReportAction(DAOFactory factory, long loggedInMID, String pidString) throws iTrustException {
		super(factory, pidString);
		this.patientDAO = factory.getPatientDAO();
		this.allergyDAO = factory.getAllergyDAO();
		this.transDAO = factory.getTransactionDAO();
		this.ovDAO = factory.getOfficeVisitDAO();
		this.loggedInMID = loggedInMID;
		emailutil = new EmailUtil(factory);
		
		pb = patientDAO.getPatient(this.pid);
		transDAO.logTransaction(TransactionType.VIEW_EMERGENCY_REPORT, this.loggedInMID, Long.valueOf(pidString), &quot;viewed emergency report&quot;);
		emailutil.sendEmail(makeEmail());
	}

	/**
	 * Returns the patient's name
	 * 
	 * @return patient's full name
	 */
	public String getPatientName() {
		return (pb.getFirstName() + &quot; &quot; + pb.getLastName());
	}

	/**
	 * Returns the patient's age
	 * 
	 * @return patient's age
	 */
	public String getPatientAge() {
		return Integer.toString(pb.getAge());
	}
	
	/**
	 * Returns the patient's gender
	 * 
	 * @return patient's gender
	 */
	public String getPatientGender() {
		return pb.getGender().toString();
	}
	
	/**
	 * Returns the patient's emergency contact
	 * 
	 * @return patient's emergency contact
	 */
	public String getPatientEmergencyContact() {
		return pb.getEmergencyName() + &quot; &quot; + pb.getEmergencyPhone();
	}
	
	/**
	 * Returns the patient's blood type
	 * 
	 * @return the patient's blood type
	 */
	public String getBloodType() {
		return pb.getBloodType() + &quot;&quot;;
	}

	/**
	 * Returns a list of allergies for the given patient
	 * 
	 * @return a list of AllergyBeans
	 * @throws iTrustException
	 */
	public List&lt;AllergyBean&gt; getAllergies() throws iTrustException {
		return allergyDAO.getAllergies(this.pid);
	}

	/**
	 * Returns a list of prescriptions the patient is currently taking
	 * 
	 * @return a list of PrescriptionBeans for which the patient is currently taking
	 * @throws iTrustException
	 */
	public List&lt;PrescriptionBean&gt; getCurrentPrescriptions() throws iTrustException {
		List&lt;PrescriptionBean&gt; allPrescriptions = patientDAO.getCurrentPrescriptions(this.pid);
		ArrayList&lt;PrescriptionBean&gt; warningList = new ArrayList&lt;PrescriptionBean&gt;();
		for (int i = 0; i &lt; allPrescriptions.size(); i++) {
			if (PrescriptionAlerts.isAlert(allPrescriptions.get(i).getMedication().getNDCode()))
				warningList.add(allPrescriptions.get(i));
		}
		return warningList;
	}

	/**
	 * Returns a list of diagnoses that are in the range indicated by the DiagnosisRange enum
	 * 
	 * @return list of DiagnosisBeans
	 * @throws iTrustException
	 */
	public List&lt;DiagnosisBean&gt; getWarningDiagnoses() throws iTrustException {
		try {
			boolean dup = false;
			List&lt;DiagnosisBean&gt; allDiagnoses = patientDAO.getDiagnoses(this.pid);
			ArrayList&lt;DiagnosisBean&gt; warningList = new ArrayList&lt;DiagnosisBean&gt;();
			for (DiagnosisBean bean: allDiagnoses) {
				OfficeVisitBean ovb = ovDAO.getOfficeVisit(bean.getVisitID());

				if(ovb == null){
					continue;
					
				}
				if (&quot;yes&quot;.equals(bean.getClassification()) || (ovb.getVisitDate().getTime() &gt; Calendar.getInstance().getTimeInMillis() - 30 * 24 * 60 * 60 * 1000))  {
					for (DiagnosisBean wbean: warningList) {
						if (bean.getDescription().equals(wbean.getDescription())) {
							dup = true;
						}
					}
					if (!dup) {
						warningList.add(bean);
					}
				}
			}
			return warningList;
		} catch (DBException dbe) {
			throw new iTrustException(dbe.getMessage());
		}
	}

	/**
	 * Returns a list of prescriptions the patient is currently taking
	 * 
	 * @return a list of PrescriptionBeans for which the patient is currently taking
	 * @throws iTrustException
	 */
	public List&lt;ProcedureBean&gt; getImmunizations() throws iTrustException {
		List&lt;ProcedureBean&gt; allImmunizations = patientDAO.getImmunizationProcedures(this.pid);
		return allImmunizations;
	}
	
	/**
	 * Creates a fake e-mail to notify the user that an emergency report has been created and viewed.
	 * 
	 * @return the e-mail to be sent
	 * @throws DBException
	 */
	private Email makeEmail() throws DBException{

		Email email = new Email();
		List&lt;PatientBean&gt; reps = patientDAO.getRepresenting(pb.getMID());
		
		List&lt;String&gt; toAddrs = new ArrayList&lt;String&gt;();
		toAddrs.add(pb.getEmail());
		for (PatientBean r: reps) {
			toAddrs.add(r.getEmail());
		}
		
		email.setFrom(&quot;no-reply@itrust.com&quot;);
    	email.setToList(toAddrs); // patient and personal representative
    	email.setSubject(String.format(&quot;Emergency Report Viewed Notification&quot;));
    	email.setBody(&quot;Dear &quot; + pb.getFullName() + &quot;,\n An emergency report has been generated. &quot; + 
    			&quot;Please login to iTrust to see who has viewed your records.&quot;);
		return email;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_GenerateCalendarAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.action.EditApptTypeAction;
import edu.ncsu.csc.itrust.action.ViewMyApptsAction;
import edu.ncsu.csc.itrust.action.ViewMyRecordsAction;
import edu.ncsu.csc.itrust.beans.ApptBean;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.beans.LabProcedureBean;
import java.util.List;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Calendar;

/**
 * Action class for calendar.jsp
 * @author Software Engineering Team 13, 2010 &quot;Project Zephyr&quot;
 *
 */
public class GenerateCalendarAction {
	private ViewMyApptsAction a_action;
	private EditApptTypeAction types;
	private ViewMyRecordsAction r_action;
	private List&lt;ApptBean&gt; send;
	
	/**
	 * Set up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the user who is viewing the calendar
	 */
	public GenerateCalendarAction(DAOFactory factory, long loggedInMID) {
		a_action = new ViewMyApptsAction(factory, loggedInMID);
		types = new EditApptTypeAction(factory, loggedInMID);
		r_action = new ViewMyRecordsAction(factory, loggedInMID);
		send = new ArrayList&lt;ApptBean&gt;();
	}
	
	/**
	 * Return the send request for an AppointmentBean
	 * @return the send request for an AppointmentBean
	 */
	public List&lt;ApptBean&gt; getSend() {
		return send;
	}
	
	/**
	 * Check appointments appearing on the calendar for conflicts 
	 * with other appointments on the calendar. 
	 * 
	 * The array from this method is used to determine what appointments
	 * will appear in bold on the calendar.
	 * 
	 * @return An array of items that are in conflict with other items.
	 * @throws SQLException
	 */
	public boolean[] getConflicts() throws SQLException {
		boolean conflicts[] = new boolean[send.size()];
		for(int i=0; i&lt;send.size(); i++) {
			ApptBean ab = send.get(i);
			long t = ab.getDate().getTime();
			long m = types.getDurationByType(ab.getApptType()) * 60L * 1000L;
			Timestamp time = new Timestamp(t+m);
			for(int j=i+1; j&lt;send.size(); j++) {
				if(send.get(j).getDate().before(time)) {
					conflicts[i] = true;
					conflicts[j] = true;
				}
			}
		}
		return conflicts;
	}
	
	/**
	 * Creates a hash table with all of the Appointments to be 
	 * displayed on the calendar for the month and year being viewed.
	 * 
	 * @param thisMonth The month of the calendar to be rendered
	 * @param thisYear The year of the calendar to be rendered
	 * @return A Hashtable containing the AppointmentBeans to be rendered
	 * @throws SQLException
	 */
	public Hashtable&lt;Integer, ArrayList&lt;ApptBean&gt;&gt; getApptsTable(int thisMonth, int thisYear) throws SQLException {
		List&lt;ApptBean&gt; appts = a_action.getMyAppointments();
		Hashtable&lt;Integer, ArrayList&lt;ApptBean&gt;&gt; atable = new Hashtable&lt;Integer, ArrayList&lt;ApptBean&gt;&gt;();
		Calendar a = Calendar.getInstance();
		for(ApptBean b : appts) {
			a.setTimeInMillis(b.getDate().getTime());
			if(a.get(Calendar.MONTH) == thisMonth &amp;&amp; a.get(Calendar.YEAR) == thisYear) {
				if(!atable.containsKey(a.get(Calendar.DAY_OF_MONTH)))
					atable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList&lt;ApptBean&gt;());
				ArrayList&lt;ApptBean&gt; l = atable.get(a.get(Calendar.DAY_OF_MONTH));
				l.add(b);
				send.add(b);
				atable.put(a.get(Calendar.DAY_OF_MONTH), l);
			}
		}
		return atable;
	}
	
	/**
	 * Creates a hash table with all of the Office Visits to be 
	 * displayed on the calendar for the month and year being viewed.
	 * 
	 * @param thisMonth The month of the calendar to be rendered
	 * @param thisYear The year of the calendar to be rendered
	 * @return A Hashtable containing the OfficeVisitBeans to be rendered
	 * @throws SQLException
	 */
	public Hashtable&lt;Integer, ArrayList&lt;OfficeVisitBean&gt;&gt; getOfficeVisitsTable(int thisMonth, int thisYear) throws iTrustException {
		List&lt;OfficeVisitBean&gt; officeVisits = r_action.getAllOfficeVisits();
		Hashtable&lt;Integer, ArrayList&lt;OfficeVisitBean&gt;&gt; rtable = new Hashtable&lt;Integer, ArrayList&lt;OfficeVisitBean&gt;&gt;();
		Calendar a = Calendar.getInstance();
		for(OfficeVisitBean b : officeVisits) {
			a.setTimeInMillis(b.getVisitDate().getTime());
			if(a.get(Calendar.MONTH) == thisMonth &amp;&amp; a.get(Calendar.YEAR) == thisYear) {
				if(!rtable.containsKey(a.get(Calendar.DAY_OF_MONTH)))
					rtable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList&lt;OfficeVisitBean&gt;());
				ArrayList&lt;OfficeVisitBean&gt; l = rtable.get(a.get(Calendar.DAY_OF_MONTH));
				l.add(b);
				rtable.put(a.get(Calendar.DAY_OF_MONTH), l);
			}
		}
		return rtable;
	}
	
	/**
	 * Creates a hash table with all of the lab procedures to be 
	 * displayed on the calendar for the month and year being viewed.
	 * 
	 * @param thisMonth The month of the calendar to be rendered
	 * @param thisYear The year of the calendar to be rendered
	 * @return A Hashtable containing the LabProcedureBeans to be rendered
	 * @throws SQLException
	 */
	public Hashtable&lt;Integer, ArrayList&lt;LabProcedureBean&gt;&gt; getLabProceduresTable(int thisMonth, int thisYear) throws iTrustException {
		List&lt;LabProcedureBean&gt; procs = r_action.getLabs();
		Hashtable&lt;Integer, ArrayList&lt;LabProcedureBean&gt;&gt; ptable = new Hashtable&lt;Integer, ArrayList&lt;LabProcedureBean&gt;&gt;();
		Calendar a = Calendar.getInstance();
		for(LabProcedureBean b : procs) {
			a.setTimeInMillis(b.getTimestamp().getTime());
			if(a.get(Calendar.MONTH) == thisMonth &amp;&amp; a.get(Calendar.YEAR) == thisYear) {
				if(!ptable.containsKey(a.get(Calendar.DAY_OF_MONTH)))
					ptable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList&lt;LabProcedureBean&gt;());
				ArrayList&lt;LabProcedureBean&gt; l = ptable.get(a.get(Calendar.DAY_OF_MONTH));
				l.add(b);
				ptable.put(a.get(Calendar.DAY_OF_MONTH), l);
			}
		}
		return ptable;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_GetUserNameAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Handles Getting the person's name associated with a certain mid Used by getUser.jsp
 * 
 * @author laurenhayward
 * 
 */
public class GetUserNameAction {
	private DAOFactory factory;

	/**
	 * Set up defaults
	 * 
	 * @param factory The DAOFactory used for creating the DAOs for this action.
	 */
	public GetUserNameAction(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Returns the person's name that matches the inputMID param
	 * 
	 * @param inputMID The MID to look up.
	 * @return the person's name
	 * @throws DBException
	 * @throws iTrustException
	 */
	public String getUserName(String inputMID) throws iTrustException {
		try {
			long mid = Long.valueOf(inputMID);
			return factory.getAuthDAO().getUserName(mid);
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;MID not in correct form&quot;);
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_GetVisitRemindersAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Calendar;
import edu.ncsu.csc.itrust.beans.forms.VisitReminderReturnForm;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.dao.mysql.VisitRemindersDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.beans.ProcedureBean;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.beans.VisitFlag;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.enums.Gender;

/**
 * Gets the VisitReminders for a given patient Used by visitReminders.jsp
 * 
 * @author laurenhayward
 * 
 */
public class GetVisitRemindersAction {

	/**
	 * Reminder Type enumeration.
	 */
	public static enum ReminderType {
		DIAGNOSED_CARE_NEEDERS(&quot;Diagnosed Care Needers&quot;),
		FLU_SHOT_NEEDERS(&quot;Flu Shot Needers&quot;),
		IMMUNIZATION_NEEDERS(&quot;Immunization Needers&quot;);

		private String typeName;

		private ReminderType(String typeName) {
			this.typeName = typeName;
		}

		private static final HashMap&lt;String, ReminderType&gt; map = new HashMap&lt;String, ReminderType&gt;();
		static {
			for (ReminderType rt : ReminderType.values()) {
				map.put(rt.getTypeName(), rt);
			}
		}

		/**
		 * Gets the ReminderType for the name passed as a param
		 * 
		 * @param name
		 * @return the ReminderType associated with the name
		 */
		public static ReminderType getReminderType(String name) {
			return map.get(name);
		}

		/**
		 * Returns the type name as a string
		 * 
		 * @return
		 */
		public String getTypeName() {
			return typeName;
		}
	}

	/**
	 * 
	 * Begin GetVisitRemindersAction code
	 * 
	 */
	private TransactionDAO transDAO;
	private VisitRemindersDAO visitReminderDAO;
	private PatientDAO patientDAO;
	private long loggedInMID;

	/**
	 * Set up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID MID of the person who is logged in
	 * @throws iTrustException
	 */
	public GetVisitRemindersAction(DAOFactory factory, long loggedInMID) throws iTrustException {
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
		visitReminderDAO = factory.getVisitRemindersDAO();
		patientDAO = factory.getPatientDAO();
	}

	/**
	 * Returns a list of VisitReminderReturnForms for the type passed in as a param
	 * 
	 * @param type
	 *            the ReminderType
	 * @return the list of VisitReminderReturnForms
	 * @throws iTrustException
	 * @throws FormValidationException
	 */
	public List&lt;VisitReminderReturnForm&gt; getVisitReminders(ReminderType type) throws iTrustException, FormValidationException {
		
		if (null == type)
			throw new iTrustException(&quot;Reminder Type DNE&quot;);
		
		transDAO.logTransaction(TransactionType.PATIENT_REMINDERS, loggedInMID, 0l, type.getTypeName());
		switch (type) {
			case DIAGNOSED_CARE_NEEDERS:
				return stripDupes(visitReminderDAO.getDiagnosedVisitNeeders(loggedInMID));

			case FLU_SHOT_NEEDERS:
				return visitReminderDAO.getFluShotDelinquents(loggedInMID);
				
			case IMMUNIZATION_NEEDERS:
				return getImmunizationNeeders(loggedInMID);
				
			default:
				throw new iTrustException(&quot;Reminder Type DNE&quot;);
		}
	}
	
	/**
	 * Gets a list of anyone who need immunizations
	 * 
	 * @param mid the HCP whose patients are being checked
	 * @return a list of all the people who need immunizations--done in a visit reminder
	 * @throws iTrustException
	 */

	private List&lt;VisitReminderReturnForm&gt; getImmunizationNeeders(long mid) throws iTrustException {
		
		List&lt;VisitReminderReturnForm&gt; formList;
		List&lt;VisitReminderReturnForm&gt; needList = new ArrayList&lt;VisitReminderReturnForm&gt;();
		String reason = &quot;&quot;;
		// Get list of patients that designate this HCP
		formList = visitReminderDAO.getPatients(mid);
		
		for (VisitReminderReturnForm r : formList) {
			reason = checkImmunizations(r.getPatientID());
			if (0 &lt; reason.length()) {
				needList.add(r);
				r.addVisitFlag(new VisitFlag(VisitFlag.IMMUNIZATION, reason));
			}
		}	
		
		return needList;
	}
	
	

	/**
	 * Checks a patient to see what immunizations they need
	 * 
	 * @param pid patient to be checked
	 * @return patient list of those lacking immunizations according to the schedule
	 */
	private String checkImmunizations(long pid) throws iTrustException {
		
		String reason = &quot;&quot;;
		List&lt;ProcedureBean&gt; procs = patientDAO.getProcedures(pid);
		PatientBean patient = patientDAO.getPatient(pid);
		long patientAge = patient.getAgeInWeeks();
		Gender gen = patient.getGender();
		
		int hepB = 0;
		long hepBTime = 0;

		int rota = 0;
		long rotaTime = 0;

		int diptet = 0;
		long deptetTime = 0;
		
		int haemoflu = 0;
		long haemofluTime = 0;
		long haemofluTimeFirst = 0;
		
		int pneumo = 0;
		long pneumoTime = 0;
		long pneumofluTimeFirst = 0;
		
		int polio = 0;
		long polioTime = 0;
		
		int measles = 0;
		long measlesTime = 0;
		
		int varicella = 0;
		long varicellaTime = 0;
		
		int hepA = 0;
		long hepATime = 0;
		
		int hpv = 0;
		long hpvTime = 0;
		
		for (ProcedureBean proc: procs) {
		
			String cpt = proc.getCPTCode();
			
			// Hep B (90371)
			if (cpt.equals(&quot;90371&quot;)) {
				hepB++;
				hepBTime = proc.getDate().getTime();
			}
				
			// Rotavirus (90681)
			else if (cpt.equals(&quot;90681&quot;)) {
				rota++;
				rotaTime = proc.getDate().getTime();
			}
			
			// Diptheria, Tetanus, Pertussis (90696)
			else if (cpt.equals(&quot;90696&quot;)) {
				diptet++;
				deptetTime = proc.getDate().getTime();
			}
			
			// Haemophilus influenza (90645)
			else if (cpt.equals(&quot;90645&quot;)) {
				if (0 == haemoflu)
					haemofluTimeFirst = proc.getDate().getTime();
				
				haemoflu++;
				haemofluTime = proc.getDate().getTime();
				
			}
			
			// Pneumococcal (90669)
			else if (cpt.equals(&quot;90669&quot;)) {
				if (0 == pneumo)
					pneumofluTimeFirst = proc.getDate().getTime();
				pneumo++;
				pneumoTime = proc.getDate().getTime();
			}
			
			// Poliovirus (90712)
			else if (cpt.equals(&quot;90712&quot;)) {
				polio++;
				polioTime = proc.getDate().getTime();
			}
			
			// Measles, Mumps, Rubella (90707)
			else if (cpt.equals(&quot;90707&quot;)) {
				measles++;
				measlesTime = proc.getDate().getTime();
			}
			
			// Varicella (90396)
			else if (cpt.equals(&quot;90396&quot;)) {
				varicella++;
				varicellaTime = proc.getDate().getTime();
			}
			
			// Hep A (90633)
			else if (cpt.equals(&quot;90633&quot;)) {
				hepA++;
				hepATime = proc.getDate().getTime();
			}
			
			// Human Papillomaavirus (90649)
			else if (cpt.equals(&quot;90649&quot;)) {
				hpv++;
				hpvTime = proc.getDate().getTime();
			}
		}
		
		if (3 &gt; hepB) {
			reason += testHepB(hepB, patientAge, hepBTime);
		}
		
		if (3 &gt; rota) {
			reason += testRotaVirus(rota, patientAge, rotaTime);
		}
		
		if (6 &gt; diptet) {
			reason += testDipTet(diptet, patientAge, deptetTime);
		}
		
		if (3 &gt; haemoflu) {
			reason += testHaemoFlu(haemoflu, patientAge, haemofluTime, haemofluTimeFirst);
		}
		
		if (4 &gt; pneumo) {
			reason += testPneumo(pneumo, patientAge, pneumoTime, pneumofluTimeFirst);
		}
		
		if (3 &gt; polio) {
			reason += testPolio(polio, patientAge, polioTime);
		}
		
		if (2 &gt; measles) {
			reason += testMeasles(measles, patientAge, measlesTime);
		}
		
		if (2 &gt; varicella) {
			reason += testVaricella(varicella, patientAge, varicellaTime);
		}
		
		if (2 &gt; hepA) {
			reason += testHepA(hepA, patientAge, hepATime);
		}
		
		if (3 &gt; hpv &amp;&amp; gen.getName().equals(&quot;Female&quot;)) {
			reason += testHPV(hpv, patientAge, hpvTime);
		}
	
		return reason;
	}
	
	
	/**
	 * Checks to see if a patient needs the HPV immunization
	 * 
	 * @param count which immunization they are on
	 * @param patientAge how old the patient is
	 * @param time what the date is
	 * @return when the immunization should be given
	 */
	public static String testHPV(int count, long patientAge, long time) {
	
		String reason = &quot;&quot;;
		long weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);
		
		if (0 == count) {
			if (468 &lt;= patientAge)
				reason += &quot;90649 Human Papillomavirus (9 years) &quot;;
		}
		else if (1 == count) {
			if (476 &lt;= patientAge &amp;&amp; 8 &lt;= weeks)
				reason += &quot;90649 Human Papillomavirus (9 years, 2 months) &quot;;
		}
		else if (2 == count) {
			if (494 &lt;= patientAge &amp;&amp; 16 &lt;= weeks)
				reason += &quot;90649 Human Papillomavirus (9 years, 6 months) &quot;;
		}
		
		return reason;
	}
	
	/**
	 * Checks to see if a patient needs the Hepatits A immunization
	 * 
	 * @param count which immunization they are on
	 * @param patientAge how old the patient is
	 * @param time what the current date is
	 * @return when the immunization should be given
	 */
	public static String testHepA(int count, long patientAge, long time) {
		
		String reason = &quot;&quot;;
		long weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);
		
		if (0 == count) {
			if (52 &lt;= patientAge)
				reason += &quot;90633 Hepatits A (12 months) &quot;;
		}
		else if (1 == count) {
			if (78 &lt;= patientAge &amp;&amp; 26 &lt;= weeks)
				reason += &quot;90633 Hepatits A (18 months) &quot;;
		}
		
		return reason;	
	}
	
	/**
	 * Checks to see if a patient needs the Varicella immunization
	 * 
	 * @param count which immunization they are on
	 * @param patientAge how old the patient is
	 * @param time what the current date is
	 * @return when the immunization should be given
	 */
	public static String testVaricella(int count, long patientAge, long time) {
		
		String reason = &quot;&quot;;
		long weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);
		
		if (0 == count) {
			if (52 &lt;= patientAge)
				reason += &quot;90396 Varicella (12 months) &quot;;
		}
		else if (1 == count) {
			if (208 &lt;= patientAge &amp;&amp; 12 &lt;= weeks)
				reason += &quot;90396 Varicella (4 years) &quot;;
		}
		
		return reason;
	}
	
	/**
	 * Checks to see if a patient needs the Measles, Mumps, and Rubekka immunization
	 * 
	 * @param count which immunization they are on
	 * @param patientAge how old the patient is
	 * @param time what the current date is
	 * @return when the immunization should be given
	 */
	public static String testMeasles(int count, long patientAge, long time) {
		
		String reason = &quot;&quot;;
		long weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);
		
		if (0 == count) {
			if (52 &lt;= patientAge)
				reason += &quot;90707 Measles, Mumps, Rubekka (12 months) &quot;;
		}
		else if (1 == count) {
			if (208 &lt;= patientAge &amp;&amp; 12 &lt;= weeks)
				reason += &quot;90707 Measles, Mumps, Rubekka (4 years) &quot;;
		}
		
		return reason;
	}
	
	/**
	 * Checks to see if a patient needs the Polio immunization
	 * 
	 * @param count which immunization they are on
	 * @param patientAge how old the patient is
	 * @param time what the current date is
	 * @return when the immunization should be given
	 */
	public static String testPolio(int count, long patientAge, long time) {
		
		String reason = &quot;&quot;;
		long weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);
		
		if (0 == count) {
			if (6 &lt;= patientAge)
				reason += &quot;90712 Poliovirus (6 weeks) &quot;;
		}
		else if (1 == count) {
			if (16 &lt;= patientAge &amp;&amp; 4 &lt;= weeks)
				reason += &quot;90712 Poliovirus (4 months) &quot;;
		}
		else if (2 == count) {
			if (26 &lt;= patientAge)
				reason += &quot;90712 Poliovirus (6 months) &quot;;				
		}
		
		return reason;	
	}
	
	/**
	 * Checks to see if a patient needs the Pneumococcal immunization
	 * 
	 * @param count which immunization they are on
	 * @param patientAge how old the patient is
	 * @param time what the current date is
	 * @return when the immunization should be given
	 */
	public static String testPneumo(int count, long patientAge, long time, long firstDoseTime) {
		
		String reason = &quot;&quot;;
		long weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);
		long ageFirst = patientAge - (firstDoseTime / (1000 * 60 * 60 * 24 * 7)); 
		
		if (0 == count) {
			if (6 &lt;= patientAge)
				reason += &quot;90669 Pneumococcal (6 weeks) &quot;;
		}
		else if (1 == count) {
			if (16 &lt;= patientAge &amp;&amp; 52 &gt; ageFirst &amp;&amp; 4 &lt;= weeks)
				reason += &quot;90669 Pneumococcal (4 months) &quot;;
			else if (16 &lt;= patientAge &amp;&amp; 52 &lt;= ageFirst &amp;&amp; 60 &gt;= ageFirst &amp;&amp; 8 &lt;= weeks)
				reason += &quot;90669 Pneumococcal (4 months) &quot;;
		}
		else if (2 == count) {
			if (26 &lt;= patientAge &amp;&amp; 4 &lt;= weeks &amp;&amp; 52 &gt;= ageFirst)
				reason += &quot;90669 Pneumococcal (6 months) &quot;;				
		}
		else if (3 == count) {
			if (52 &lt;= patientAge &amp;&amp; 8 &lt;= weeks &amp;&amp; 52 &gt;= ageFirst)
				reason += &quot;90669 Pneumococcal (12 months) &quot;;				
		}
		return reason;
	}
	
	/**
	 * Checks to see if a patient needs the Haemophilus Infulenzae immunization
	 * 
	 * @param count which immunization they are on
	 * @param patientAge how old the patient is
	 * @param time what the current date is
	 * @return when the immunization should be given
	 */
	public static String testHaemoFlu(int count, long patientAge, long time, long firstDoseTime) {
		
		String reason = &quot;&quot;;
		long weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);
		long ageFirst = patientAge - (firstDoseTime / (1000 * 60 * 60 * 24 * 7)); 
			
		if (0 == count) {
			if (6 &lt;= patientAge)
				reason += &quot;90645 Haemophilus influenzae (6 weeks) &quot;;
		}
		else if (1 == count) {
			if (16 &lt;= patientAge &amp;&amp; 52 &gt; ageFirst &amp;&amp; 4 &lt;= weeks)
				reason += &quot;90645 Haemophilus influenzae (4 months) &quot;;
			else if (16 &lt;= patientAge &amp;&amp; 52 &lt;= ageFirst &amp;&amp; 60 &gt;= ageFirst &amp;&amp; 8 &lt;= weeks)
				reason += &quot;90645 Haemophilus influenzae (4 months) &quot;;
		}
		else if (2 == count) {
			if (26 &lt;= patientAge &amp;&amp; 4 &lt;= weeks &amp;&amp; 52 &gt; ageFirst)
				reason += &quot;90645 Haemophilus influenzae (6 months) &quot;;
		}
		
		return reason;
	}
	
	/**
	 * Checks to see if a patient needs the Diphtheria, Tetanus, Pertussis immunization
	 * 
	 * @param count which immunization they are on
	 * @param patientAge how old the patient is
	 * @param time what the current date is
	 * @return when the immunization should be given
	 */
	public static String testDipTet(int count, long patientAge, long time) {
		
		String reason = &quot;&quot;;
		long weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);
		
		if (0 == count) {
			if (6 &lt;= patientAge)
				reason += &quot;90696 Diphtheria, Tetanus, Pertussis (6 weeks) &quot;;
		}
		else if (1 == count) {
			if (16 &lt;= patientAge &amp;&amp; 4 &lt;= weeks )
				reason += &quot;90696 Diphtheria, Tetanus, Pertussis (4 months) &quot;;
		}
		else if (2 == count) {
			if (26 &lt;= patientAge &amp;&amp; 4 &lt;= weeks)
				reason += &quot;90696 Diphtheria, Tetanus, Pertussis (6 months) &quot;;				
		}
		else if (3 == count) {
			if (15 &lt;= patientAge &amp;&amp; 26 &lt;= weeks)
				reason += &quot;90696 Diphtheria, Tetanus, Pertussis (15 weeks) &quot;;
		}
		else if (4 == count) {
			if (208 &lt;= patientAge &amp;&amp; 26 &lt;= weeks)
				reason += &quot;90696 Diphtheria, Tetanus, Pertussis (4 years) &quot;;
		}
		else if (5 == count) {
			if (572 &lt;= patientAge &amp;&amp; 260 &lt;= weeks)
				reason += &quot;90696 Diphtheria, Tetanus, Pertussis (11 years) &quot;;				
		}
		
		return reason;
	}
	
	/**
	 * Checks to see if a patient needs the Rotavirus immunization
	 * 
	 * @param count which immunization they are on
	 * @param patientAge how old the patient is
	 * @param time what the current date is
	 * @return when the immunization should be given
	 */
	
	public static String testRotaVirus(int count, long patientAge, long time) {
	
		String reason = &quot;&quot;;
		long weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);
		
		if (0 == count) {
			if (6 &lt;= patientAge)
				reason += &quot;90681 Rotavirus (6 weeks) &quot;;
		}
		else if (1 == count) {
			if (16 &lt;= patientAge &amp;&amp; 4 &lt;= weeks)
				reason += &quot;90681 Rotavirus (4 months) &quot;;
		}
		else if (2 == count) {
			if (26 &lt;= patientAge &amp;&amp; 4 &lt;= weeks )
				reason += &quot;90681 Rotavirus (6 months) &quot;;				
		}
		
		return reason;
	}

	
	/**
	 * Checks to see if a patient needs the Hepatitis B immunization
	 * 
	 * @param count which immunization they are on
	 * @param patientAge how old the patient is
	 * @param time what the current date is
	 * @return when the immunization should be given
	 */
	public static String testHepB(int count, long patientAge, long time) {
		
		String reason = &quot;&quot;;
		long weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);
		
		if (0 == count) {
			if (0 &lt; patientAge)
				reason += &quot;90371 Hepatitis B (birth) &quot;;
		}
		else if (1 == count) {
			if (4 &lt;= patientAge &amp;&amp; 4 &lt;= weeks)
				reason += &quot;90371 Hepatitis B (1 month) &quot;;
		}
		else if (2 == count) {
			if (26 &lt;= patientAge &amp;&amp; 8 &lt;= weeks)
				reason += &quot;90371 Hepatitis B (6 months) &quot;;				
		}
		
		return reason;
	}
	
	
	/**
	 * Removes duplicates from a list of VisitReminderReturnForms
	 * 
	 * @param patients list of visit remindersto be cleaned up
	 * @return cleaned up list of visit reminders
	 */
	private List&lt;VisitReminderReturnForm&gt; stripDupes(List&lt;VisitReminderReturnForm&gt; patients) {
		if (null == patients)
			return null;
		if (0 == patients.size())
			return patients;
		List&lt;VisitReminderReturnForm&gt; retPatients = new ArrayList&lt;VisitReminderReturnForm&gt;();
		VisitReminderReturnForm temp = patients.get(0);
		retPatients.add(temp);
		for (VisitReminderReturnForm vr : patients) {
			if (vr.getPatientID() != temp.getPatientID())
				retPatients.add(vr);
			temp = vr;
		}
		return retPatients;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_LabProcHCPAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import java.util.ArrayList;
import edu.ncsu.csc.itrust.beans.LabProcedureBean;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.LabProcedureDAO;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.validate.LabProcedureValidator;

/**
 * Action class for LabProcHCP.jsp.
 * 
 * @extends LabProcUAPAction
 */
public class LabProcHCPAction extends LabProcUAPAction {
	private TransactionDAO transDAO;
	private LabProcedureDAO lpDAO;
	private OfficeVisitDAO ovDAO;
	long loggedInMID;
	private LabProcedureValidator validator;

	
	/**
	 * Sets up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID  MID for the logged in HCP
	 */
	
	public LabProcHCPAction(DAOFactory factory, long loggedInMID) {
		super(factory, loggedInMID);
		transDAO = factory.getTransactionDAO();
		lpDAO = factory.getLabProcedureDAO();
		ovDAO = factory.getOfficeVisitDAO();
		this.loggedInMID = loggedInMID;
		validator = new LabProcedureValidator();

	}

	/**
	 * This method sorts by LOINC and returns the list
	 * 
	 * @param id the ID to sort the list by
	 * @return List sorted by LOINC
	 */
	public List&lt;LabProcedureBean&gt; sortByLOINC(long id) throws DBException {
		return lpDAO.getAllLabProceduresLOINC(id);
	}

	/**
	 * Returns a list of all the lab procedures for the next month
	 * 
	 * @return all the lab procedures for the next month
	 */
	public List&lt;LabProcedureBean&gt; getLabProcForNextMonth() throws DBException {
		List&lt;LabProcedureBean&gt; listLabProc = new ArrayList&lt;LabProcedureBean&gt;(0);
		List&lt;OfficeVisitBean&gt; listOV = ovDAO.getAllOfficeVisitsForLHCP(loggedInMID);
		for (OfficeVisitBean ov : listOV) {
			if (listLabProc.isEmpty() == true) {
				listLabProc = lpDAO.getLabProceduresForLHCPForNextMonth(ov.getID());
			}
			else {
				for (LabProcedureBean lb : lpDAO.getLabProceduresForLHCPForNextMonth(ov.getID())) {
					listLabProc.add(lb);
				}
			}
		}
		return listLabProc;
	}

	/**
	 * Changes the privacy settings
	 * 
	 * @param x the ID of the procedure to change 
	 * 
	 */
	public void changePrivacy(long x) throws DBException, FormValidationException {
		LabProcedureBean pb = lpDAO.getLabProcedure(x);
		if (checkAccess(x)) {
			if (pb.getRights().equals(LabProcedureBean.Restrict)) {
				pb.allow();
			} else {
				pb.restrict();
			}
			validator.validate(pb);
			lpDAO.updateRights(pb);
			transDAO.logTransaction(TransactionType.ENTER_EDIT_LAB_PROCEDURE, loggedInMID, pb.getPid(),
					&quot;Privacy Changed procedure id: &quot; + pb.getProcedureID());
		}

	}
	
	/**
	 * Checks to see if the logged in HCP is the one who made the procedure.  Used to generate links for page to edit OfficeVisit
	 * 
	 * @param x the ID of the HCP to check
	 * 
	 */
	public boolean checkAccess(long x) throws DBException, FormValidationException {
		LabProcedureBean pb = lpDAO.getLabProcedure(x);
		OfficeVisitBean ovbean = ovDAO.getOfficeVisit(pb.getOvID());
		return (loggedInMID == ovbean.getHcpID());

	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_LabProcUAPAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.Arrays;
import java.util.List;
import edu.ncsu.csc.itrust.EmailUtil;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.LabProcedureBean;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.LabProcedureDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.validate.LabProcedureValidator;
/**
 * Class for LabProcUAP.jsp.  Handles lab procedures for UAPs
 */
public class LabProcUAPAction {
	private TransactionDAO transDAO;
	private LabProcedureDAO lpDAO;
	long loggedInMID;
	private LabProcedureValidator validator;
	private DAOFactory factory;

/**
 * Setup 
 * @param factory The DAOFactory used to create the DAOs used in this action.
 * @param loggedInMID UAP who is logged in
 */
	public LabProcUAPAction(DAOFactory factory, long loggedInMID) {
		transDAO = factory.getTransactionDAO();
		lpDAO = factory.getLabProcedureDAO();
		this.loggedInMID = loggedInMID;
		validator = new LabProcedureValidator();
		this.factory = factory;
	}
	
	/**
	 * Updates a lab procedure
	 * 
	 * @param b the procedure to update
	 * @throws DBException
	 * @throws FormValidationException
	 */
	public void updateProcedure(LabProcedureBean b) throws DBException, FormValidationException{
		validator.validate(b);
		//need to check if status is what's being changed - if new status!=old status send email
		if(!b.getStatus().equals(lpDAO.getLabProcedure(b.getProcedureID()).getStatus())){
			new EmailUtil(factory).sendEmail(makeEmail(b));
		}
		lpDAO.updateLabProcedure(b);
		transDAO.logTransaction(TransactionType.ENTER_EDIT_LAB_PROCEDURE, loggedInMID, 
				b.getPid(), &quot;UAP updated procedure id: &quot;
				+ b.getProcedureID());
	}
	
	/**
	 * Sends an e-mail informing the patient that their procedure has been updated
	 * 
	 * @param b the procedure that was updated
	 * @return an e-mail to the patient with the notice
	 * @throws DBException
	 */
	private Email makeEmail(LabProcedureBean b) throws DBException{
		
		PatientBean p = new PatientDAO(factory).getPatient(b.getPid());
		
		Email email = new Email();
		email.setFrom(&quot;no-reply@itrust.com&quot;);
		email.setToList(Arrays.asList(p.getEmail()));
		email.setSubject(&quot;A Lab Procedure Was Updated&quot;);
		email.setBody(String.format(&quot;Dear %s, \n Your Lab Procedure (%s) has a new updated status of %s. Log on to iTrust to view.&quot;,  p.getFullName(),b.getLoinc(),b.getStatus()));
		return email;
	}
	
	/**
	 * Returns a list of all the lab procedures
	 * 
	 * @param id MID of the UAP viewing the procedures 
	 * @return a list of all the lab procedures for that UAP
	 * @throws DBException
	 */
	public List&lt;LabProcedureBean&gt; viewProcedures(long id) throws DBException {
		transDAO.logTransaction(TransactionType.VIEW_LAB_PROCEDURE, loggedInMID,
				id, &quot;UAP viewed procedures&quot;);
		return lpDAO.getAllLabProceduresDate(id);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_LoginFailureAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Please note that this is not the best mitigation for Denial of Service attacks. The better way would be to
 * keep track of password failure attempts per user account, NOT with easily spoofable ip addresses. The
 * reason this feature is implemented with ip addresses is a limitation in Tomcat authentication (actually,
 * it's technically JSP's fault for not specifying a form of account lockout). &lt;br /&gt;
 * &lt;br /&gt;
 * All authentication in this application is done by the container (Tomcat), which doesn't support account
 * lockout. So our options would be (a) to implement our own authentication (yuck!), or (2) to extend the
 * JDBCRealm class in the Tomcat source code and add the logic. I've looked into this and it's actually pretty
 * easy. The ONLY reason it's not implemented here is that the code would be buried in a jar in your Tomcat
 * installation - not very educational for those who want to learn about authentication in webapps. Feel free
 * to change this; extending this would be perfectly acceptable.
 * 
 * @author Andy
 * 
 */
public class LoginFailureAction {
	public static final int MAX_LOGIN_ATTEMPTS = 3;
	private AuthDAO authDAO;
	private String ipAddr;
	private TransactionDAO transactionDAO;

	/**
	 * Set up defaults
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param ipAddr The IP address of the user making the login attempt.
	 */
	public LoginFailureAction(DAOFactory factory, String ipAddr) {
		this.authDAO = factory.getAuthDAO();
		this.ipAddr = ipAddr;
		this.transactionDAO = factory.getTransactionDAO();
	}

	/**
	 * Calls authDAO to record the login failure in the database
	 * 
	 * @return How many login failure attempts or a DBException message
	 */
	public String recordLoginFailure() {
		try {
			authDAO.recordLoginFailure(ipAddr);
			int loginFailures = authDAO.getLoginFailures(ipAddr);
			transactionDAO.logTransaction(TransactionType.LOGIN_FAILURE, 0L, 0L, &quot;IP: &quot; + ipAddr);
			return &quot;Login failed, attempt &quot; + loginFailures;
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		}
	}

	/**
	 * Checks to see if the current user can login (#failures&lt;3)
	 * 
	 * @return true if the user is valid to login
	 */
	public boolean isValidForLogin() {
		try {
			return authDAO.getLoginFailures(ipAddr) &lt; 3;
		} catch (DBException e) {
			System.err.println(&quot;Denying access due to DBException&quot;);
			return false;
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ManageHospitalAssignmentsAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.beans.HospitalBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.HospitalsDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Manages the assignment of HCPs to hospitals Used by hospitalAssignments.jsp
 * 
 * @author laurenhayward
 * 
 */
public class ManageHospitalAssignmentsAction {
	private TransactionDAO transDAO;
	private PersonnelDAO personnelDAO;
	private HospitalsDAO hospitalsDAO;
	private long loggedInMID;

	/**
	 * Set up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the user managing hospitals.
	 */
	public ManageHospitalAssignmentsAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.transDAO = factory.getTransactionDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.hospitalsDAO = factory.getHospitalsDAO();
	}

	/**
	 * Returns a list of hospitals to which the given mid is not currently assigned
	 * 
	 * @param midString
	 * @return list of HospitalBeans
	 * @throws iTrustException
	 */
	public List&lt;HospitalBean&gt; getAvailableHospitals(String midString) throws iTrustException {
		try {
			long mid = Long.valueOf(midString);
			List&lt;HospitalBean&gt; allHospitals = hospitalsDAO.getAllHospitals();
			List&lt;HospitalBean&gt; ourHospitals = personnelDAO.getHospitals(mid);
			while (!ourHospitals.isEmpty()) {
				allHospitals.remove(ourHospitals.remove(0));
			}

			return allHospitals;
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;HCP's MID not a number&quot;);
		}
	}

	/**
	 * Returns a list of hospitals to which the given mid is currently assigned
	 * 
	 * @param midString
	 * @return list of HosptialBeans
	 * @throws iTrustException
	 */
	public List&lt;HospitalBean&gt; getAssignedHospitals(String midString) throws iTrustException {
		try {
			long mid = Long.valueOf(midString);
			return personnelDAO.getHospitals(mid);
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;HCP's MID not a number&quot;);
		}
	}

	/**
	 * Assigns the mid to the hospital
	 * 
	 * @param midString The MID of the person assigned to the hospital as a String.
	 * @param hospitalID The ID of the hospital.
	 * @return message indicating the status of the assignment
	 * @throws iTrustException
	 */
	public String assignHCPToHospital(String midString, String hospitalID) throws iTrustException {
		try {
			long hcpID = Long.valueOf(midString);
			boolean confirm = hospitalsDAO.assignHospital(hcpID, hospitalID);
			if (confirm) {/*
							 * only patient is mentioned for transaction type 0, but spec looks like personnel
							 * should be included too...
							 */
				transDAO.logTransaction(TransactionType.ENTER_EDIT_DEMOGRAPHICS, loggedInMID, hcpID,
						&quot;HCP Assigned to Hospital&quot;);
				return &quot;HCP successfully assigned.&quot;;
			} else
				return &quot;Assignment did not occur&quot;;
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;HCP's MID not a number&quot;);
		}
	}

	/**
	 * Removes HCPs assignment to the designated hospital
	 * 
	 * @param midString
	 *            the HCP's mid
	 * @param hospitalID
	 *            the hospital id to be removed
	 * @return Status message
	 * @throws iTrustException
	 */
	public String removeHCPAssignmentToHospital(String midString, String hospitalID) throws iTrustException {
		try {
			long hcpID = Long.valueOf(midString);
			boolean confirm = hospitalsDAO.removeHospitalAssignment(hcpID, hospitalID);
			if (confirm) {
				transDAO.logTransaction(TransactionType.ENTER_EDIT_DEMOGRAPHICS, loggedInMID, hcpID,
						&quot;HCP unassigned from hospital&quot;);
				return &quot;HCP successfully unassigned&quot;;
			} else
				return &quot;HCP not unassigned&quot;;
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;HCP's MID not a number&quot;);
		}
	}

	/**
	 * Removes all hospital assignments for the given hcp mid
	 * 
	 * @param midString
	 *            HCP's mid
	 * @return status message
	 * @throws iTrustException
	 */
	public int removeAllAssignmentsFromHCP(String midString) throws iTrustException {
		try {
			long hcpID = Long.valueOf(midString);
			int numAssignments = hospitalsDAO.removeAllHospitalAssignmentsFrom(hcpID);
			if (0 &lt; numAssignments) {
				transDAO.logTransaction(TransactionType.ENTER_EDIT_DEMOGRAPHICS, loggedInMID, hcpID,
						&quot;HCP unassigned from all hospital&quot;);
			}
			return numAssignments;
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;HCP's MID not a number&quot;);
		}
	}

	/**
	 * Checks if the hcpID param is a HCP
	 * 
	 * @param hcpID
	 *            the String to be checked
	 * @return the mid as a long if the hcpID is a HCP's mid
	 * @throws iTrustException
	 */
	public long checkHCPID(String hcpID) throws iTrustException {
		try {
			long pid = Long.valueOf(hcpID);
			if (personnelDAO.checkPersonnelExists(pid))
				return pid;
			else
				throw new iTrustException(&quot;HCP does not exist&quot;);
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;HCP ID is not a number: &quot; + e.getMessage());
		}
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_MonitorAdverseEventAction</id>
            <content>package edu.ncsu.csc.itrust.action;

/**
 * Used by PHAs to view the reported adverse events
 */
import java.sql.SQLException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.EmailUtil;
import edu.ncsu.csc.itrust.beans.AdverseEventBean;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.MessageBean;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AdverseEventDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;

public class MonitorAdverseEventAction {
	 
	private long loggedInMID;
	private EmailUtil emailer;
	private PatientDAO patientDAO;
	private AdverseEventDAO adverseEventDAO;
	private TransactionDAO transactionDAO;
	private SendMessageAction messenger;
	
	/**
	 * Constructor 
	 * @param factory
	 * @param loggedInMID
	 */
	public MonitorAdverseEventAction(DAOFactory factory, long loggedInMID){
		this.loggedInMID = loggedInMID;
		this.transactionDAO = factory.getTransactionDAO();
		this.patientDAO = factory.getPatientDAO();
		this.emailer = new EmailUtil(factory);
		this.adverseEventDAO = factory.getAdverseEventDAO();
		this.messenger = new SendMessageAction(factory, loggedInMID);
		
	}
	/**
	 * Returns a list of reports between specified dates
	 * @param isPrescription Boolean to return prescriptions or immunizations
	 * @param start The starting date
	 * @param end The ending date
	 * @return the list of events
	 * @throws iTrustException
	 * @throws FormValidationException
	 * @throws SQLException
	 * @throws ParseException
	 */
	public List&lt;AdverseEventBean&gt; getReports(boolean isPrescription, String start, String end)throws iTrustException, FormValidationException, SQLException, ParseException {
		if(isPrescription) {
			transactionDAO.logTransaction(TransactionType.ADVERSE_EVENT, loggedInMID, 0L, &quot;Adverse Prescription Reports Requested.&quot;);
			return adverseEventDAO.getPerscriptions(start, end);
		} else { //is Immunization
			transactionDAO.logTransaction(TransactionType.ADVERSE_EVENT, loggedInMID, 0L, &quot;Adverse Immunization Report Requested.&quot;);
			return adverseEventDAO.getImmunizations(start, end);
		}
		
	}
	
	/**
	 * Returns the patient's name
	 * @param MID the MID of the patient to return the name for.
	 * @return
	 */
	public String getName(long MID) {
		try {
			return patientDAO.getName(MID);
		} catch(DBException e) {
			return &quot;&quot;;
		} catch(iTrustException e) {
			return &quot;Patient no longer exists&quot;;
		}
	}
	
	/**
	 * Sends an e-mail to a patient requesting more information
	 * @param patientMID The patient to receive the message
	 * @param message The message
	 * @return string for testing purposes
	 * @throws DBException
	 */
	public String sendEmail(long patientMID, String message) throws DBException{
		String rValue;
		List&lt;String&gt; toList = new ArrayList&lt;String&gt;();
		PatientBean receiver = patientDAO.getPatient(patientMID);
		toList.add(receiver.getEmail());
		Email mail = new Email();
		mail.setBody(message);
		mail.setFrom(loggedInMID + &quot;&quot;);
		mail.setToList(toList);
		emailer.sendEmail(mail);
		transactionDAO.logTransaction(TransactionType.ADVERSE_EVENT, loggedInMID, 0L, &quot;Requested more information&quot;);
		rValue = &quot;&quot; + mail.getFrom() + &quot; &quot; + mail.getBody();
		return rValue;
	}
	
	/**
	 * Method used to remove an adverse event report
	 * 
	 * @param id the id of the report to be removed
	 * @throws DBException
	 * @throws iTrustException
	 */
	public void remove(int id) throws DBException, iTrustException, FormValidationException{
		long HCPMID;
		try{
		AdverseEventBean aeBean = adverseEventDAO.getReport(id);
		adverseEventDAO.removeReport(id);
		HCPMID = adverseEventDAO.getHCPMID(id);
		MessageBean mBeanTwo = new MessageBean();
		MessageBean mBeanOne = new MessageBean();
		String body = &quot;An adverse event for &quot; + aeBean.getDrug() + &quot; perscribed to &quot; + patientDAO.getName(Long.parseLong(aeBean.getMID())) +&quot; with description: (&quot; + aeBean.getDescription()+ &quot;) was removed.&quot;;
		mBeanOne.setTo(Long.parseLong(aeBean.getMID()));
		mBeanTwo.setTo(HCPMID);
		mBeanOne.setSubject(&quot;Subject&quot;);
		mBeanTwo.setSubject(&quot;Subject&quot;);
		mBeanOne.setBody(body);
		mBeanTwo.setBody(body);
		mBeanOne.setFrom(loggedInMID);
		mBeanTwo.setFrom(loggedInMID);
		messenger.sendMessage(mBeanOne);
		messenger.sendMessage(mBeanTwo);
		transactionDAO.logTransaction(TransactionType.ADVERSE_EVENT, loggedInMID, 0L, &quot;Adverse Event Report Removed&quot;);
		}catch(SQLException e){
			throw new DBException(e);
		} 
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_MyDiagnosisAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.io.Serializable;
import java.util.*;
import edu.ncsu.csc.itrust.beans.DiagnosisBean;
import edu.ncsu.csc.itrust.beans.HCPDiagnosisBean;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.beans.PrescriptionBean;
import edu.ncsu.csc.itrust.beans.MedicationBean;
import edu.ncsu.csc.itrust.beans.SurveyBean;
import edu.ncsu.csc.itrust.beans.LabProcedureBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.dao.mysql.SurveyDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.LabProcedureDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Edits the privacy levels of diagnoses, used by myDiagnoses.jsp
 * 
 * @author laurenhayward
 * 
 */
public class MyDiagnosisAction {
	
	private OfficeVisitDAO officeVisitDAO;
	private PatientDAO patientDAO;
	private PersonnelDAO personnelDAO;
	private SurveyDAO surveyDAO;
	private TransactionDAO transactionDAO;
	private LabProcedureDAO labprocDAO;
	private long loggedInMID;

	/**
	 * Set up for defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the user who is looking at their diagnoses.
	 * @throws iTrustException
	 */
	public MyDiagnosisAction(DAOFactory factory, long loggedInMID) throws iTrustException {
		this.loggedInMID = loggedInMID;
		this.patientDAO = factory.getPatientDAO();
		this.officeVisitDAO = factory.getOfficeVisitDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.surveyDAO = factory.getSurveyDAO();
		this.transactionDAO = factory.getTransactionDAO();
		this.labprocDAO = factory.getLabProcedureDAO();
	}
	
	/**
	 * Returns a list of DiagnosisBeans for the patient
	 * 
	 * @return the list of DiagnosisBeans
	 * @throws DBException
	 */
	public List&lt;DiagnosisBean&gt; getDiagnoses() throws DBException {
		return patientDAO.getDiagnoses(loggedInMID);
	}
	
	/**
	 * Returns a list of all the HCPs who have a particular diagnosis
	 * 
	 * @param icdcode the diagnosis of interest
	 * @return the list of HCPs
	 * @throws DBException
	 */
	public List&lt;HCPDiagnosisBean&gt; getHCPByDiagnosis(String icdcode) throws DBException {
		
		int medMatch = 0;
		HashMap&lt;Long, HCPDiagnosisBean&gt; hcpHash = new HashMap&lt;Long, HCPDiagnosisBean&gt;();
		HashMap&lt;Long, Long&gt; patientHash = new HashMap&lt;Long, Long&gt;();
	
		transactionDAO.logTransaction(TransactionType.FIND_HCPS_WITH_EXP, loggedInMID);
		
		HCPDiagnosisBean diag = null;
		List&lt;OfficeVisitBean&gt; beans = officeVisitDAO.getAllOfficeVisitsForDiagnosis(icdcode);
		
		for (OfficeVisitBean bean: beans) {
			
			// check for HCP-Patient locality based on first 3 digits in ZIP
			if (!patientDAO.getPatient(loggedInMID).getZip1().substring(0, 2).
					equals(personnelDAO.getPersonnel(bean.getHcpID()).getZip1().substring(0, 2)))
				continue;
			
			// Check to see if we already have a bean for the HCP associated with this visit
			if (hcpHash.containsKey(bean.getHcpID())) {
				diag = (HCPDiagnosisBean)hcpHash.get(bean.getHcpID());
				
				for (PrescriptionBean p: bean.getPrescriptions()) {
					List&lt;MedicationBean&gt; mlist = diag.getMedList();
					
					for (MedicationBean b: mlist) {
						if (p.getMedication().getDescription().equals(b.getDescription()))
							medMatch++;
					}
					if (medMatch == 0) {
						mlist.add(p.getMedication());
						diag.setMedList(mlist);
					}
					else {
						medMatch = 0;
					}
				}
				
				// Get Lab Procedures
				List&lt;LabProcedureBean&gt; labprocs = diag.getLabList(); 
				List&lt;LabProcedureBean&gt; lpbeans = labprocDAO.getAllLabProceduresForDocOV(bean.getVisitID());
				for (LabProcedureBean p: lpbeans) {
					labprocs.add(p);
				}
				diag.setLabList(labprocs);
				
				
				if (surveyDAO.isSurveyCompleted(bean.getVisitID())) {
					SurveyBean survey = surveyDAO.getSurveyData(bean.getVisitID());
					diag.setVisitSat(survey.getVisitSatisfaction());
					diag.setTreatmentSat(survey.getTreatmentSatisfaction());
				}
				
				// Check if this patient has been seen multiple times for this diagnosis
				if (!patientHash.containsKey(bean.getPatientID())) {
					patientHash.put(bean.getPatientID(), bean.getHcpID());
					diag.incNumPatients();
				}
			}
			else {
				diag = new HCPDiagnosisBean();
				List&lt;MedicationBean&gt; mlist = new ArrayList&lt;MedicationBean&gt;();
				diag.setHCP(bean.getHcpID());
				try {
					diag.setHCPName(personnelDAO.getName(bean.getHcpID()));
				} catch (iTrustException e) {
					diag.setHCPName(&quot;null&quot;);
				}
				diag.incNumPatients();
				for (PrescriptionBean p: bean.getPrescriptions()) {
					mlist.add(p.getMedication());
				}
				diag.setMedList(mlist);
				diag.setLabList(labprocDAO.getAllLabProceduresForDocOV(bean.getVisitID()));
				
				if (surveyDAO.isSurveyCompleted(bean.getVisitID())) {
					SurveyBean survey = surveyDAO.getSurveyData(bean.getVisitID());
					diag.setVisitSat(survey.getVisitSatisfaction());
					diag.setTreatmentSat(survey.getTreatmentSatisfaction());
				}
				
				patientHash.put(bean.getPatientID(), bean.getHcpID());
				hcpHash.put(bean.getHcpID(), diag);
			}
		}
		List&lt;HCPDiagnosisBean&gt; list = new ArrayList&lt;HCPDiagnosisBean&gt;(hcpHash.values());
		Collections.sort(list, new HCPDiagnosisBeanComparator() );
		return list;
	}
	
	/**
	 * Looks up all the prescriptions given by a certain HCP with the same ICD code.
	 * @param hcpid The MID of the HCP
	 * @param icdcode The ICD code of the prescription we are looking up.
	 * @return A java.util.List of PrescriptionBeans made by this HCP of this ICD code.
	 * @throws DBException
	 */
	public List&lt;PrescriptionBean&gt; getPrescriptionsByHCPAndICD(long hcpid, String icdcode) throws DBException {
		List&lt;PrescriptionBean&gt; list = new ArrayList&lt;PrescriptionBean&gt;();
		
		List&lt;OfficeVisitBean&gt; ovs = officeVisitDAO.getAllOfficeVisitsForDiagnosis(icdcode);
		for (int i = 0; i &lt; ovs.size(); i++) {
			if (ovs.get(i).getHcpID() == hcpid) {
				list.addAll(ovs.get(i).getPrescriptions());
			}
		}
		
		return list;
		
		
	}
	
	
	/**
	 * Checks to see what HCP has had the most experience with a diagnosis
	 *
	 */
	static class HCPDiagnosisBeanComparator implements Comparator&lt;HCPDiagnosisBean&gt;, Serializable {
		
		private static final long serialVersionUID = -6328390386684022934L;

		/**
		 * Compares one HCP with another
		 * 
		 * @param a the first HCP
		 * @param b the second HCP
		 * @return -1 if a has had more patients, 1 if b has had more patients; otherwise 0
		 */
		public int compare(HCPDiagnosisBean a, HCPDiagnosisBean b) {
			int ret = 0;
			
			if (a.getNumPatients() &gt; b.getNumPatients())
				ret = -1;
			else if (a.getNumPatients() &lt; b.getNumPatients())
				ret = 1;
			
			return ret;
		}
	}
	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PrescriptionReportAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import edu.ncsu.csc.itrust.ParameterUtil;
import edu.ncsu.csc.itrust.action.base.PatientBaseAction;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.PrescriptionReportBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.NoHealthRecordsException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Handles Prescription Reports for the given pid Used by hcp-uap/getPrescriptionReport.jsp,
 * hcp-uap/viewPrescriptionRecord.jsp, patient/getMyPrescriptionReport.jsp, &amp;
 * patient/viewMyPrescriptionRecord.jsp
 * 
 * @author laurenhayward
 * 
 */
public class PrescriptionReportAction extends PatientBaseAction {
	private boolean isRepresenting = false;
	private OfficeVisitDAO ovDAO;
	private TransactionDAO transDAO;
	private PatientDAO patientDAO;
	private long loggedInMID;

	/**
	 * Super class validates pidString
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the user who is making a prescription report.
	 * @param pidString The MID of the patient in question.
	 * @throws iTrustException
	 * @throws DBException
	 * @throws NoHealthRecordsException
	 */
	public PrescriptionReportAction(DAOFactory factory, long loggedInMID, String pidString)
			throws iTrustException, DBException, NoHealthRecordsException {
		super(factory, pidString);
		this.transDAO = factory.getTransactionDAO();
		this.ovDAO = factory.getOfficeVisitDAO();
		this.patientDAO = factory.getPatientDAO();
		this.loggedInMID = loggedInMID;
	}

	/**
	 * Takes the patient's representee as a param and returns it as a long if the patient represents the input
	 * param
	 * 
	 * @param input
	 *            the patient's representee mid
	 * @return representee's mid as a long
	 * @throws iTrustException
	 */
	public long representPatient(String input) throws iTrustException {
		try {
			long reppeeMID = Long.valueOf(input);
			if (patientDAO.represents(loggedInMID, reppeeMID)) {
				loggedInMID = reppeeMID;
				pid = reppeeMID;
				isRepresenting = true;
				return reppeeMID;
			} else
				throw new iTrustException(&quot;You do not represent patient &quot; + reppeeMID);
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;MID is not a number&quot;);
		}
	}

	/**
	 * Returns a list of all office visits for the pid
	 * 
	 * @return list of OfficeVisitBeans for the pid
	 * @throws DBException
	 */
	public List&lt;OfficeVisitBean&gt; getAllOfficeVisits() throws DBException {
		return ovDAO.getAllOfficeVisits(pid);
	}

	/**
	 * Used by the JSP, passes a Map from the html form and a list of OfficeVisitBeans Returns a list of
	 * PrescriptionReportBeans
	 * 
	 * @param params A java.util.HashMap containing the parameter map.
	 * @param officeVisits A java.util.List of OfficeVisitBeans for the visits.
	 * @return list of PrescriptionReportBeans
	 * @throws DBException
	 */
	// suppressing warnings because JSP doesn't have a generic for request.getParameterMap()
	@SuppressWarnings(&quot;unchecked&quot;)
	public List&lt;PrescriptionReportBean&gt; getPrescriptionReports(Map params, List&lt;OfficeVisitBean&gt; officeVisits)
			throws DBException {
		HashMap&lt;String, String&gt; myParams = ParameterUtil.convertMap(params);
		List&lt;Long&gt; ovIDs = new ArrayList&lt;Long&gt;();
		for (int i = 0; i &lt; officeVisits.size(); i++) {
			try {
				if (params.get(&quot;ovOff&quot; + i) != null) {
					int offset = Integer.valueOf(myParams.get(&quot;ovOff&quot; + i));
					ovIDs.add(officeVisits.get(offset).getVisitID());
				}
			} catch (NumberFormatException e) {
				// just skip it
			}
		}
		transDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID, pid,
				&quot;Getting reports for office visits &quot; + ovIDs.toString());
		if (ovIDs.size() == 0)
			return new ArrayList&lt;PrescriptionReportBean&gt;();

		return ovDAO.getPrescriptionReports(ovIDs, pid);
	}

	/**
	 * Returns a PatientBean for the pid
	 * 
	 * @return PatientBean
	 * @throws DBException
	 */
	public PatientBean getPatient() throws DBException {
		return patientDAO.getPatient(pid);
	}

	/**
	 * Used by the JSP, which passes the param map from the html form and a list of OfficeVisitBeans Returns a
	 * string that will be used to create a new url. The JSP will pull params from this url to create the
	 * prescription report.
	 * 
	 * @param paramMap A java.util.HashMap of the parameters.
	 * @param officeVisits A java.util.List of OfficeVisitBeans.
	 * @return the string that will be used in the new url
	 * @throws FormValidationException
	 * @throws DBException
	 */
	// suppressing warnings because JSP doesn't have a generic for request.getParameterMap()
	@SuppressWarnings(&quot;unchecked&quot;)
	public String getQueryString(Map paramMap, List&lt;OfficeVisitBean&gt; officeVisits)
			throws FormValidationException, DBException {
		HashMap&lt;String, String&gt; myParams = ParameterUtil.convertMap(paramMap);
		List&lt;Integer&gt; ovOffsets = checkOfficeVisits(myParams, officeVisits);
		String queryString = buildQueryString(ovOffsets);
		if (isRepresenting)
			queryString += &quot;&amp;rep=&quot; + pid;
		return queryString;
	}

	/**
	 * Checks office visits
	 * 
	 * @param myParams list of parameters
	 * @param officeVisits list of office visits
	 * @return Returns a java.util.ArrayList of Integers for the given office visits.
	 */
	private ArrayList&lt;Integer&gt; checkOfficeVisits(HashMap&lt;String, String&gt; myParams,
			List&lt;OfficeVisitBean&gt; officeVisits) {
		ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
		for (int i = 0; i &lt; officeVisits.size(); i++) {
			if (&quot;on&quot;.equals(myParams.get(&quot;ov&quot; + i)))
				list.add(i);
		}
		return list;
	}

	/**
	 * Builds a query string for office visits
	 * 
	 * @param ovOffsets offsets for the office visits
	 * @return A SQL query in a Java String.
	 */
	private String buildQueryString(List&lt;Integer&gt; ovOffsets) {
		int n = ovOffsets.size();
		if (n == 0)
			return &quot;&quot;;
		String str = &quot;&amp;n=&quot; + n;
		for (int i = 0; i &lt; ovOffsets.size(); i++) {
			str += &quot;&amp;ovOff&quot; + i + &quot;=&quot; + ovOffsets.get(i);
		}
		return str;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ReferralManagementAction</id>
            <content>package edu.ncsu.csc.itrust.action;


import edu.ncsu.csc.itrust.beans.ReferralBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.ReferralDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.exception.DBException;
import java.util.List;

/**
 * Used for referring patients to other HCPs.  The call is made in /auth/hcp/hcpConsultation.jsp 
 */
public class ReferralManagementAction {
	private long loggedInMID;
	private TransactionDAO transDAO;
	private ReferralDAO referralDAO;

	/**
	 * Super class validates the patient id
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the user managing this referral.
	 * @param pidString The MID of the patient being referred.
	 * @throws iTrustException
	 */
	public ReferralManagementAction(DAOFactory factory, long loggedInMID) throws iTrustException {
		
		this.referralDAO = factory.getReferralDAO();
		this.loggedInMID = loggedInMID;
		this.transDAO = factory.getTransactionDAO();
	}

	/**
	 * Adds a referral bean to the database.
	 * @param r The referral bean to be added.
	 * @throws DBException
	 */
	public void sendReferral(ReferralBean r) throws DBException {
		referralDAO.addReferral(r);
		transDAO.logTransaction(TransactionType.SEND_REFERRAL, loggedInMID);
	}
	
	/**
	 * Updates an existing referral bean.
	 * @param r The current referral bean.
	 * @throws DBException
	 */
	public void updateReferral(ReferralBean r) throws DBException {
		referralDAO.editReferral(r);
	}
	
	/**
	 * Gets the referrals the currently logged in MID has sent.
	 * @return A java.util.List of ReferralBeans this MID has sent.
	 * @throws DBException
	 */
	public List&lt;ReferralBean&gt; getReferralsSentFromMe() throws DBException {
		return referralDAO.getReferralsSentFrom(loggedInMID);
	}
	
	/**
	 * Gets the referrals this MID has received.
	 * @return A java.util.List of the ReferralBeans this MID has received.
	 * @throws DBException
	 */
	public List&lt;ReferralBean&gt; getReferralsSentToMe() throws DBException {
		return referralDAO.getReferralsSentTo(loggedInMID);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ReportAdverseEventAction</id>
            <content>package edu.ncsu.csc.itrust.action;
/**
 * Used for the patient to report adverse events.
 */
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.EmailUtil;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.AdverseEventBean;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AdverseEventDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.AdverseEventValidator;
import edu.ncsu.csc.itrust.exception.FormValidationException;

public class ReportAdverseEventAction {
	
	private long loggedInMID;
	private EmailUtil emailer;
	private PatientDAO patientDAO;
	private PersonnelDAO personnelDAO;
	private AdverseEventDAO adverseEventDAO;
	private TransactionDAO transactionDAO;
	private long hcpID;
	private AdverseEventValidator validator;
	
	public ReportAdverseEventAction(String hcpID, DAOFactory factory, long loggedInMID){
		this.loggedInMID = loggedInMID;
		this.patientDAO = factory.getPatientDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.emailer = new EmailUtil(factory);
		this.adverseEventDAO = factory.getAdverseEventDAO();
		this.transactionDAO = factory.getTransactionDAO();
		this.hcpID = Long.parseLong(hcpID);
		this.validator = new AdverseEventValidator();
		
		
	}
	
	/**
	 * Constructor used to send e-mails only
	 */
	public ReportAdverseEventAction(DAOFactory factory, long loggedInMID){
		this.loggedInMID = loggedInMID;
		this.patientDAO = factory.getPatientDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.emailer = new EmailUtil(factory);
		this.adverseEventDAO = factory.getAdverseEventDAO();
		this.transactionDAO = factory.getTransactionDAO();
		this.validator = new AdverseEventValidator();
	}
	/**
	 * Method that sends exactly one e-mail to each MID in the list of Adverse Events
	 * @param aeList The list of adverse Event Beans that need to be acted upon
	 * @return EList The list of e-mails sent for testing purposes
	 */
	public Email sendMails(List&lt;AdverseEventBean&gt; aeList) throws iTrustException, FormValidationException, DBException {
		List&lt;String&gt; MIDlist = new ArrayList&lt;String&gt;();
		String patientID = &quot;&quot;;
		
		for(AdverseEventBean beaner : aeList){
			patientID = beaner.getMID();
			String newDesc = &quot; Drug: &quot; + beaner.getDrug() + &quot; (&quot; + beaner.getCode() + &quot;) Description: &quot; + beaner.getDescription();
			beaner.setDescription(newDesc);
		}
		for(AdverseEventBean beano : aeList){
			if(!MIDlist.contains(beano.getPrescriber())){
				MIDlist.add(beano.getPrescriber());
			}
		}
		Email email = new Email();
		
		for(String num : MIDlist){
			String message = &quot; Patient: &quot; + patientDAO.getName(Long.parseLong(patientID)) 
				+ &quot; (MID &quot; + patientID + &quot;) Has Reported the following adverse event(s)&quot;;
			for(AdverseEventBean beano : aeList){
				if(beano.getPrescriber().equals(num)){
					message = message + beano.getDescription();
				}
			}
			
			String fromEmail;
			email.setFrom(&quot;noreply@itrust.com&quot;);
			PatientBean sender = patientDAO.getPatient(loggedInMID);
			PersonnelBean receiver = personnelDAO.getPersonnel(Long.parseLong(num));
			List&lt;String&gt; toList = new ArrayList&lt;String&gt;();
			toList.add(receiver.getEmail());
			fromEmail = sender.getEmail();
			
			email.setToList(toList);
			email.setFrom(fromEmail);
			email.setSubject(String.format(&quot;Adverse Event Report(Prescription)&quot;));
			email.setBody(message);
			emailer.sendEmail(email);
			transactionDAO.logTransaction(TransactionType.SEND_MESSAGE, loggedInMID);
			
		}
		return email;
	}
	/**
	 * A method used to send a single e-mail. Used in immunizations.
	 * @param aeBean
	 * @return Email returns the Email for testing purposes.
	 */
	public Email sendMail (AdverseEventBean aeBean)throws iTrustException, FormValidationException, DBException{
		Email email = new Email();
		String fromEmail;
		email.setFrom(&quot;noreply@itrust.com&quot;);
		List&lt;String&gt; toList = new ArrayList&lt;String&gt;();
		
		PatientBean sender = patientDAO.getPatient(loggedInMID);
		PersonnelBean receiver = personnelDAO.getPersonnel(hcpID);
		
		toList.add(receiver.getEmail());
		fromEmail = sender.getEmail();
		
		email.setToList(toList);
		email.setFrom(fromEmail);
		email.setSubject(String.format(&quot;Adverse Event Report (Immunization)&quot;));
		email.setBody(String.format(
				&quot; Patient: &quot; + patientDAO.getName(Long.parseLong(aeBean.getMID())) 
				+ &quot; (MID &quot; + aeBean.getMID() + &quot;) Has Reported the following adverse event&quot; +
				&quot; Drug: &quot; + aeBean.getDrug() + &quot;(&quot; + aeBean.getCode() + &quot;) Description: &quot; + aeBean.getDescription()
				));
		emailer.sendEmail(email);
		
		transactionDAO.logTransaction(TransactionType.SEND_MESSAGE, loggedInMID);
		
		return email;
	}
	
	/**
	 * Method used to add a report to the data base
	 * @param aeBean The adverse event to add
	 * @return a string for testing purposes only
	 * @throws iTrustException
	 * @throws FormValidationException
	 * @throws DBException
	 */
	public String addReport(AdverseEventBean aeBean)throws iTrustException, FormValidationException, DBException {
		
		try{
			validator.validate(aeBean);
		}catch (FormValidationException e){
			e.printStackTrace();
			return e.getMessage();
			}
		try{
			adverseEventDAO.addReport(aeBean, hcpID);
		}
		catch( DBException e ){
			throw new iTrustException(e.getMessage());
		}
		/**
		 * Old code used to send a single e-mail. Keep for reference
		Email email = new Email();
		String senderName;
		String fromEmail;
		email.setFrom(&quot;noreply@itrust.com&quot;);
		List&lt;String&gt; toList = new ArrayList&lt;String&gt;();
		
		PatientBean sender = patientDAO.getPatient(loggedInMID);
		PersonnelBean receiver = personnelDAO.getPersonnel(hcpID);
		
		toList.add(receiver.getEmail());
		senderName = sender.getFullName();
		fromEmail = sender.getEmail();
		
		email.setToList(toList);
		email.setFrom(fromEmail);
		email.setSubject(String.format(&quot;Adverse Event Report&quot;));
		email.setBody(String.format(
				&quot; Patient: &quot; + patientDAO.getName(Long.parseLong(aeBean.getMID())) 
				+ &quot; (MID &quot; + aeBean.getMID() + &quot;) Has Reported the following adverse event(s)&quot; +
				&quot; Drug: &quot; + aeBean.getDrug() + &quot;(&quot; + aeBean.getCode() + &quot;) Description: &quot; + aeBean.getDescription()
				));
		emailer.sendEmail(email);
		
		transactionDAO.logTransaction(TransactionType.SEND_MESSAGE, loggedInMID);*/
		transactionDAO.logTransaction(TransactionType.ADVERSE_EVENT, loggedInMID);
		return &quot;&quot;;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ResetPasswordAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.Arrays;
import edu.ncsu.csc.itrust.EmailUtil;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.enums.Role;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.ValidationFormat;

/**
 * Manages resetting the password Used by resetPassword.jsp
 * 
 * @author laurenhayward
 * 
 */
public class ResetPasswordAction {
	public static final int MAX_RESET_ATTEMPTS = 3;

	private AuthDAO authDAO;
	private PatientDAO patientDAO;
	private DAOFactory factory;

	/**
	 * Set up defaults
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 */
	public ResetPasswordAction(DAOFactory factory) {
		this.authDAO = factory.getAuthDAO();
		this.patientDAO = factory.getPatientDAO();
		this.factory = factory;
	}

	/**
	 * Checks to see if a user exists with the given mid
	 * 
	 * @param midString The user's MID to check for.
	 * @return 0 if the user does not exist, else the mid of the user as a long
	 */
	public long checkMID(String midString) {
		try {
			long mid = Long.valueOf(midString);
			if (!authDAO.checkUserExists(mid))
				return 0;
			return mid;
		} catch (NumberFormatException e) {
			return 0L;
		} catch (DBException e) {
			return 0L;
		}
	}

	/**
	 * Checks to see if the number of reset password attempts has been exceeded for the given ipAddress
	 * 
	 * @param ipAddress The IPv4 or IPv6 IP address as a String.
	 * @return true if the the number of reset attempts is greater than or equal to MAX_RESET_ATTEMPTS
	 * @throws DBException
	 */
	public boolean isMaxedOut(String ipAddress) throws DBException {
		return authDAO.getResetPasswordFailures(ipAddress) &gt;= MAX_RESET_ATTEMPTS;
	}

	/**
	 * Checks if the given mid matches the given role
	 * 
	 * @param mid
	 *            the mid to be checked
	 * @param role
	 *            the role to be checked
	 * @return true if the mid and role match
	 * @throws iTrustException
	 */
	public String checkRole(long mid, String role) throws iTrustException {
		try {
			if ((&quot;patient&quot;.equals(role) &amp;&amp; patientDAO.getRole(mid, role).equals(&quot;patient&quot;))
					|| (&quot;hcp&quot;.equals(role) &amp;&amp; patientDAO.getRole(mid, role).equals(&quot;hcp&quot;))
					|| (&quot;uap&quot;.equals(role) &amp;&amp; patientDAO.getRole(mid, role).equals(&quot;uap&quot;))
					|| (&quot;pha&quot;.equals(role) &amp;&amp; patientDAO.getRole(mid, role).equals(&quot;pha&quot;))
					|| (&quot;er&quot;.equals(role) &amp;&amp; patientDAO.getRole(mid, role).equals(&quot;er&quot;)))
				return role;
			else
				return null;
		} catch (DBException e) {
			e.printStackTrace();
		} catch (iTrustException e) {
			e.printStackTrace();
			throw e;
		}
		return null;
	}

	/**
	 * Checks if the answer param is null
	 * 
	 * @param answer the user's security answer
	 * @return answer if not null, else return null
	 */
	public String checkAnswerNull(String answer) {
		if (answer == null || &quot;&quot;.equals(answer))
			return null;
		else
			return answer;
	}

	/**
	 * Returns the security question for the mid param
	 * 
	 * @param mid MID of the user
	 * @return the security question or &quot;&quot; if DBException thrown
	 * @throws iTrustException
	 */
	public String getSecurityQuestion(long mid) throws iTrustException {
		try {
			if (null == authDAO.getSecurityQuestion(mid) || authDAO.getSecurityQuestion(mid).equals(&quot;&quot;))
				throw new iTrustException(&quot;No security question or answer for this user has been set.&quot;);
			else
				return authDAO.getSecurityQuestion(mid);
		} catch (DBException e) {
			e.printStackTrace();
			return &quot;&quot;;
		}
	}

	/**
	 * Resets the password for the given mid
	 * 
	 * @param mid of the user to have their password reset
	 * @param role what role the user has in iTrust
	 * @param answer answers to their security question
	 * @param password their password
	 * @param confirmPassword their password again
	 * @param ipAddr the ip address the request is coming from
	 * @return status message
	 * @throws FormValidationException
	 * @throws DBException
	 * @throws iTrustException
	 */
	public String resetPassword(long mid, String role, String answer, String password,
			String confirmPassword, String ipAddr) throws FormValidationException, DBException,
			iTrustException {

		Role r = authDAO.getUserRole(mid);
		try {
			Role.parse(role);
		} catch (IllegalArgumentException e) {
			return &quot;Invalid role&quot;;
		}

		if (r.equals(Role.ADMIN))
			return &quot;This role cannot be changed here&quot;;
		if (!r.equals(Role.parse(role)))
			return &quot;Role mismatch&quot;;

		if (authDAO.getResetPasswordFailures(ipAddr) &gt;= MAX_RESET_ATTEMPTS) {
			return &quot;Too many retries&quot;;
		}

		try {
			validatePassword(password, confirmPassword);

			if (answer.equals(authDAO.getSecurityAnswer(mid))) {
				authDAO.resetPassword(mid, password);
				new EmailUtil(factory).sendEmail(makeEmailApp(mid, role));
				return &quot;Password changed&quot;;
				
			} else {
				authDAO.recordResetPasswordFailure(ipAddr);
				return &quot;Answer did not match&quot;;
			}

		} catch (DBException e) {
			return &quot;Error in validation of security answer&quot;;
		}
	}
	
	/**
	 * Creates and sends an e-mail about the change
	 * 
	 * @param mid the user who's password was changed
	 * @param role what role they have in iTrust
	 * @return the e-mial that is sent
	 * @throws DBException
	 */
	private Email makeEmailApp(long mid, String role) throws DBException{
		
		if(Role.parse(role) == Role.PATIENT){
			PatientBean p = new PatientDAO(factory).getPatient(mid);
			Email email = new Email();
			email.setFrom(&quot;no-reply@itrust.com&quot;);
			email.setToList(Arrays.asList(p.getEmail()));
			email.setSubject(&quot;Your password has been changed in iTrust&quot;);
			email.setBody(String.format(&quot;Dear %s, \n You have chosen to change your iTrust password for user %s&quot;, p.getFullName(), mid));

			return email;
		}
		else{ //UAP or HCP - admin taken out in &quot;resetPassword&quot;
			PersonnelBean p = new PersonnelDAO(factory).getPersonnel(mid);
			Email email = new Email();
			email.setFrom(&quot;no-reply@itrust.com&quot;);
			email.setToList(Arrays.asList(p.getEmail()));
			email.setSubject(&quot;Your password has been changed in iTrust&quot;);
			email.setBody(String.format(&quot;Dear %s, \n You have chosen to change your iTrust password for user %s&quot;, p.getFullName(), mid));

			return email;
		}
	}
	
	/**
	 * Checks to make sure the password is correctly entered twice.
	 * 
	 * @param password the password
	 * @param confirmPassword the password again for confirmation
	 * @throws FormValidationException
	 */

	private void validatePassword(String password, String confirmPassword) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		if (password == null || &quot;&quot;.equals(password)) {
			errorList.addIfNotNull(&quot;Password cannot be empty&quot;);
		} else {
			if (!password.equals(confirmPassword))
				errorList.addIfNotNull(&quot;Passwords don't match&quot;);
			if (!ValidationFormat.PASSWORD.getRegex().matcher(password).matches()) {
				errorList.addIfNotNull(&quot;Password must be in the following format: &quot;
						+ ValidationFormat.PASSWORD.getDescription());
			}
		}
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SearchUsersAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.exception.DBException;


public class SearchUsersAction {
	private PatientDAO patientDAO;
	private PersonnelDAO personnelDAO;


	/**
	 * Set up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the user who is performing the search.
	 */
	public SearchUsersAction(DAOFactory factory, long loggedInMID) {
		this.patientDAO = factory.getPatientDAO();
		this.personnelDAO = factory.getPersonnelDAO();
	}
	

	/**
	 * Searches for all personnel with the first name and last name specified in the parameter list.
	 * @param firstName The first name to be searched.
	 * @param lastName The last name to be searched.
	 * @return A java.util.List of PersonnelBeans for the users who matched.
	 */
	public List&lt;PersonnelBean&gt; searchForPersonnelWithName(String firstName, String lastName) {
		
		try {	
			if(&quot;&quot;.equals(firstName))
				firstName = &quot;%&quot;;
			if(&quot;&quot;.equals(lastName))
				lastName = &quot;%&quot;;
			return personnelDAO.searchForPersonnelWithName(firstName, lastName);
		}
		catch (DBException e) {
			System.out.println(&quot;DB Exception from SearchUsersAction&quot;);
			e.printStackTrace();
			return null;
		}
	}
	
	/**
	 * Search for all patients with first name and last name given in parameters.
	 * @param firstName The first name of the patient being searched.
	 * @param lastName The last name of the patient being searched.
	 * @return A java.util.List of PatientBeans
	 */
	public List&lt;PatientBean&gt; searchForPatientsWithName(String firstName, String lastName) {
	
		try {	
			if(&quot;&quot;.equals(firstName))
				firstName = &quot;%&quot;;
			if(&quot;&quot;.equals(lastName))
				lastName = &quot;%&quot;;
			return patientDAO.searchForPatientsWithName(firstName, lastName);
		}
		catch (DBException e) {
			System.out.println(&quot;DB Exception from SearchUsersAction&quot;);
			e.printStackTrace();
			return null;
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SendMessageAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.EmailUtil;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.MessageBean;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.MessageDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.EMailValidator;
import edu.ncsu.csc.itrust.validate.MessageValidator;


/**
 * Class for SendMessage.jsp.  
 *
 */

public class SendMessageAction {
	private long loggedInMID;
	private EmailUtil emailer;
	private PatientDAO patientDAO;
	private PersonnelDAO personnelDAO;
	private MessageDAO messageDAO;
	private TransactionDAO transactionDAO;
	private EMailValidator emailVal;
	private MessageValidator messVal;


	/**
	 * Sets up defaults
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the user sending the message.
	 */
	public SendMessageAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.patientDAO = factory.getPatientDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.emailer = new EmailUtil(factory);
		this.messageDAO = factory.getMessageDAO();
		this.transactionDAO = factory.getTransactionDAO();
		this.emailVal = new EMailValidator();
		this.messVal = new MessageValidator();
	}
	
	/**
	 * Sends a message
	 * 
	 * @param mBean message to be sent
	 * @throws iTrustException
	 * @throws SQLException
	 */
	public void sendMessage(MessageBean mBean) throws iTrustException, SQLException, FormValidationException {
		messVal.validate(mBean);
		emailVal.validate(mBean);
		messageDAO.addMessage(mBean);
		
		Email email = new Email();
		String senderName;
		String fromEmail;
		email.setFrom(&quot;noreply@itrust.com&quot;);
		List&lt;String&gt; toList = new ArrayList&lt;String&gt;();
		if (8999999999L &lt; mBean.getFrom() &amp;&amp; 8999999999L &lt; mBean.getTo()){
			PersonnelBean sender = personnelDAO.getPersonnel(loggedInMID);
			PersonnelBean receiver = personnelDAO.getPersonnel(mBean.getTo());
			
			toList.add(receiver.getEmail());
			senderName = sender.getFullName();
			fromEmail = sender.getEmail();
		}else{
			if (6999999999L &lt; mBean.getFrom()) {
				PersonnelBean sender = personnelDAO.getPersonnel(loggedInMID);
				
				if (6999999999L &lt; mBean.getTo()) {
					PersonnelBean receiver = personnelDAO.getPersonnel(mBean.getTo());
					toList.add(receiver.getEmail());
				} else {
					PatientBean receiver = patientDAO.getPatient(mBean.getTo());
					toList.add(receiver.getEmail());
				}
				senderName = sender.getFullName();
				fromEmail = sender.getEmail();
				
			} else {
				PatientBean sender = patientDAO.getPatient(loggedInMID);
				
				if (6999999999L &lt; mBean.getTo()) {
					PersonnelBean receiver = personnelDAO.getPersonnel(mBean.getTo());
					toList.add(receiver.getEmail());
				} else {
					PatientBean receiver = patientDAO.getPatient(mBean.getTo());
					toList.add(receiver.getEmail());
				}
				senderName = sender.getFullName();
				fromEmail = sender.getEmail();
			}
		}
		email.setToList(toList);
		email.setFrom(fromEmail);
		email.setSubject(String.format(&quot;A new message from %s&quot;, senderName));
		email.setBody(String.format(&quot;You have received a new message from %s in iTrust. To view it, log in to iTrust and go to \&quot;View My Messages\&quot;&quot;, senderName));
		emailer.sendEmail(email);
		
		transactionDAO.logTransaction(TransactionType.SEND_MESSAGE, loggedInMID);
	}
	
	/**
	 * Returns the patient's name
	 * 
	 * @param mid MId of the patient
	 * @return the name of the patient
	 * @throws iTrustException
	 */
	public String getPatientName(long mid) throws iTrustException {
		return patientDAO.getName(mid);
	}
	
	/**
	 * Returns the personnel's name
	 * 
	 * @param mid MId of the personnel
	 * @return the name of the personnel
	 * @throws iTrustException
	 */
	public String getPersonnelName(long mid) throws iTrustException {
		return personnelDAO.getName(mid);
	}
	
	/**
	 * Returns a list of the patients that the logged in HCP represents
	 * 
	 * @return list of the patients that the logged in HCP represents
	 * @throws iTrustException
	 */
	public List&lt;PatientBean&gt; getMyRepresentees() throws iTrustException {
		List&lt;PatientBean&gt; representees = new ArrayList&lt;PatientBean&gt;();
		try {
			representees = patientDAO.getRepresented(loggedInMID);
		} catch (DBException e) {
			e.printStackTrace();
		}
		return representees;
	}
	
	/**
	 * Returns the designated HCPs for the logged in patient.
	 * 
	 * @return designated HCPs for the logged in patient.
	 * @throws iTrustException
	 */
	public List&lt;PersonnelBean&gt; getMyDLHCPs() throws iTrustException {
		return getDLHCPsFor(loggedInMID);
	}
	
	/**
	 * Returns the designated HCPs for the given patient.
	 * 
	 * @return designated HCPs for the given patient.
	 * @throws iTrustException
	 */
	public List&lt;PersonnelBean&gt; getDLHCPsFor(long pid) throws iTrustException {
		List&lt;PersonnelBean&gt; dlhcps = new ArrayList&lt;PersonnelBean&gt;();
		try {
			dlhcps = patientDAO.getDeclaredHCPs(pid);
		} catch (DBException e) {
			e.printStackTrace();
		}
		return dlhcps;		
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SetSecurityQuestionAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.beans.SecurityQA;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.SecurityQAValidator;

/**
 * Handles setting and retrieving the security questions/answers for users Used by
 * patient/editMyDemographics.jsp, staff/editMyDemographics.jsp, staff/editPersonnell.jsp
 * 
 * @author laurenhayward
 * 
 */
public class SetSecurityQuestionAction {

	private AuthDAO authDAO;
	private long loggedInMID;

	/**
	 * Sets up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param rLoggedInMID The MID of the user who is setting their security question.
	 * @throws iTrustException
	 */
	public SetSecurityQuestionAction(DAOFactory factory, long rLoggedInMID) throws iTrustException {
		this.authDAO = factory.getAuthDAO();
		loggedInMID = checkMID(rLoggedInMID);
	}

	/**
	 * Updates information in the database from the information held in the SecurityQA bean passed as a param
	 * 
	 * @param a
	 *            SecurityQuestionBean that holds new information
	 * @throws Exception
	 */
	public void updateInformation(SecurityQA a) throws Exception {
		SecurityQAValidator sqav = new SecurityQAValidator();
		sqav.validate(a);
		authDAO.setSecurityQuestionAnswer(a.getQuestion(), a.getAnswer(), loggedInMID);
	}

	/**
	 * Returns a SecurityQA bean holding the security info for the currently logged in user
	 * 
	 * @return SecurityQA for loggedInMid
	 * @throws iTrustException
	 */
	public SecurityQA retrieveInformation() throws iTrustException {
		SecurityQA toRet = new SecurityQA();
		toRet.setAnswer(authDAO.getSecurityAnswer(loggedInMID));
		toRet.setQuestion(authDAO.getSecurityQuestion(loggedInMID));
		return toRet;
	}
	/**
	 * Checks to make sure the MID exists in iTrust
	 * 
	 * @param mid MID to check
	 * @return returns the MID if the user is valid, otherwise, throws an exception
	 * @throws iTrustException
	 */

	private long checkMID(long mid) throws iTrustException {
		if (!authDAO.checkUserExists(mid))
			throw new iTrustException(&quot;MID &quot; + mid + &quot; is not a user!&quot;);
		return mid;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SurveyAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.Calendar;
import edu.ncsu.csc.itrust.beans.SurveyBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.SurveyDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * This class is used to add patient survey data to the database.  The office visit ID is linked with the survey ID.  Once the
 * survey is added, the transaction is logged
 *
 */
public class SurveyAction {
	private TransactionDAO transDAO;
	private SurveyDAO surveyDAO;
	long loggedInMID;
	
	/**
	 * Sets up defaults
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the user taking the survey.
	 */
	public SurveyAction(DAOFactory factory, long loggedInMID) {
		transDAO = factory.getTransactionDAO();
		surveyDAO = factory.getSurveyDAO();
		this.loggedInMID = loggedInMID;
	}


	/**
	 * Pass the OfficeVistBean along with SurveyBean
	 * @param surveyBean contains data to be added to database
	 * @param visitID The Office Visit ID corresponding to this Survey.
	 * @throws DBException
	 */
	public void addSurvey(SurveyBean surveyBean, long visitID) throws DBException {
		
		surveyBean.setVisitID(visitID); //now set visit ID in the survey bean
		surveyDAO.addCompletedSurvey(surveyBean, Calendar.getInstance().getTime());
		//add to transaction log
		transDAO.logTransaction(TransactionType.ADD_PATIENT_SURVEY, loggedInMID, 0L, &quot;office visit ID for completed survey is: &quot; + visitID);
		
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_UpdateCPTCodeListAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.beans.ProcedureBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.CPTCodesDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.ProcedureBeanValidator;

/**
 * Updates the CPT Code (Medical Procedures) List Used by editCPTProcedureCodes.jsp
 * 
 * The CPT code set accurately describes medical, surgical, and diagnostic services 
 * and is designed to communicate uniform information about medical services and procedures 
 * among physicians, coders, patients, accreditation organizations, and payers for administrative, 
 * financial, and analytical purposes.
 *
 * @see http://www.ama-assn.org/ama/pub/physician-resources/solutions-managing-your-practice/coding-billing-insurance/cpt/about-cpt.shtml
 * @author laurenhayward
 */
public class UpdateCPTCodeListAction {
	private long loggedInMID;
	private TransactionDAO transDAO;
	private CPTCodesDAO cptDAO;
	private ProcedureBeanValidator validator = new ProcedureBeanValidator();

	/**
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the administrator who is updating the CPTs.
	 */
	public UpdateCPTCodeListAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.transDAO = factory.getTransactionDAO();
		this.cptDAO = factory.getCPTCodesDAO();
	}

	/**
	 * Adds a new cpt code (med procedure)
	 * 
	 * @param proc
	 *            ProcedureBean that holds the new cpt code
	 * @return status message
	 * @throws FormValidationException
	 */
	public String addCPTCode(ProcedureBean proc) throws FormValidationException {
		validator.validate(proc);
		try {
			if (cptDAO.addCPTCode(proc)) {
				transDAO.logTransaction(TransactionType.MANAGE_PROCEDURE_CODE, loggedInMID, 0L,
						&quot;added CPT code &quot; + proc.getCPTCode());
				return &quot;Success: &quot; + proc.getCPTCode() + &quot; - &quot; + proc.getDescription() + &quot; added&quot;;
			} else
				return &quot;The database has become corrupt. Please contact the system administrator for assistance.&quot;;
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		} catch (iTrustException e) {
			return e.getMessage();
		}
	}

	/**
	 * Updates a procedure with new information from the ProcedureBean
	 * 
	 * @param proc
	 *            ProcedureBean with new information (but same CPT code)
	 * @return Status message
	 * @throws FormValidationException
	 */
	public String updateInformation(ProcedureBean proc) throws FormValidationException {
		validator.validate(proc);
		try {
			int rows = updateCode(proc);
			if (0 == rows) {
				return &quot;Error: Code not found. To edit an actual code, &quot;
						+ &quot;change the description and add a new code with the old description&quot;;
			} else {
				transDAO.logTransaction(TransactionType.MANAGE_PROCEDURE_CODE, loggedInMID, 0L,
						&quot;updated CPT code &quot; + proc.getCPTCode());
				return &quot;Success: &quot; + rows + &quot; row(s) updated&quot;;
			}
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		}
	}

	/**
	 * Updates the cpt code
	 * 
	 * @param proc the code to be updated
	 * @return updated code
	 * @throws DBException
	 */
	private int updateCode(ProcedureBean proc) throws DBException {
		return cptDAO.updateCode(proc);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_UpdateHospitalListAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.beans.HospitalBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.HospitalsDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.HospitalBeanValidator;

/**
 * Handles updating the list of hospitals Used by hospitalListing.jsp
 * 
 * @author laurenhayward
 * 
 */
public class UpdateHospitalListAction {
	private long performerID;
	private HospitalsDAO hospDAO;
	private TransactionDAO transDAO;

	/**
	 * Set up
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param performerID The MID of the person updating the hospitals.
	 */
	public UpdateHospitalListAction(DAOFactory factory, long performerID) {
		this.hospDAO = factory.getHospitalsDAO();
		this.transDAO = factory.getTransactionDAO();
		this.performerID = performerID;
	}

	/**
	 * Adds a hosptial using the HospitalBean passed as a param
	 * 
	 * @param hosp
	 *            the new hospital listing
	 * @return Status message
	 * @throws FormValidationException
	 */
	public String addHospital(HospitalBean hosp) throws FormValidationException {
		new HospitalBeanValidator().validate(hosp);
		try {
			if (hospDAO.addHospital(hosp)) {
				transDAO.logTransaction(TransactionType.MAINTAIN_HOSPITALS, performerID, 0L,
						&quot;added hospital &quot; + hosp.getHospitalName());
				return &quot;Success: &quot; + hosp.getHospitalID() + &quot; - &quot; + hosp.getHospitalName() + &quot; added&quot;;
			} else
				return &quot;The database has become corrupt. Please contact the system administrator for assistance.&quot;;
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		} catch (iTrustException e) {
			return e.getMessage();
		}
	}

	/**
	 * Updates a hospital (based on the hospital id) using new information from the HospitalBean passed as a
	 * param
	 * 
	 * @param hosp
	 *            the new hospital information with the same hospital id
	 * @return Status message
	 * @throws FormValidationException
	 */
	public String updateInformation(HospitalBean hosp) throws FormValidationException {
		new HospitalBeanValidator().validate(hosp);
		try {
			int rows = 0;
			return ((0 == (rows = updateHospital(hosp))) ? &quot;Error: Hospital not found.&quot; : &quot;Success: &quot; + rows
					+ &quot; row(s) updated&quot;);
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		}
	}

	/**
	 * Updates hospital
	 * 
	 * @param hosp new information
	 * @return id for the updated hospital
	 * @throws DBException
	 */
	private int updateHospital(HospitalBean hosp) throws DBException {
		return hospDAO.updateHospital(hosp);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_UpdateICDCodeListAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.beans.DiagnosisBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.ICDCodesDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.DiagnosisBeanValidator;

/**
 * Handles updating the ICD Code (Diagnosis) List Used by editICDCodes.jsp
 * 
 * The International Statistical Classification of Diseases and Related Health Problems 
 * (most commonly known by the abbreviation ICD) provides codes to classify diseases and a 
 * wide variety of signs, symptoms, abnormal findings, complaints, social circumstances and 
 * external causes of injury or disease. 
 * 
 * @see http://www.cdc.gov/nchs/icd9.htm
 * @author laurenhayward
 * 
 */
public class UpdateICDCodeListAction {
	private long performerID = 0;
	private ICDCodesDAO icdDAO;
	private TransactionDAO transDAO;
	private DiagnosisBeanValidator validator = new DiagnosisBeanValidator();

	/**
	 * Set up
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param performerID The MID of the person udpating the ICDs.
	 */
	public UpdateICDCodeListAction(DAOFactory factory, long performerID) {
		this.performerID = performerID;
		transDAO = factory.getTransactionDAO();
		icdDAO = factory.getICDCodesDAO();
	}

	/**
	 * Adds a new ICD code (diagnosis) based on the DiagnosisBean passed as a param
	 * 
	 * @param diagn
	 *            The new diagnosis (ICD code)
	 * @return Status message
	 * @throws FormValidationException
	 */
	public String addICDCode(DiagnosisBean diagn) throws FormValidationException {
		validator.validate(diagn);
		try {
			if (icdDAO.addICDCode(diagn)) {
				transDAO.logTransaction(TransactionType.MANAGE_DIAGNOSIS_CODE, performerID, 0L,
						&quot;added ICD code &quot; + diagn.getICDCode());
				return &quot;Success: &quot; + diagn.getICDCode() + &quot; - &quot; + diagn.getDescription() + &quot; added&quot;;
			} else
				return &quot;The database has become corrupt. Please contact the system administrator for assistance.&quot;;
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		} catch (iTrustException e) {
			return e.getMessage();
		}
	}

	/**
	 * Updates a diagnosis with new information from the DiagnosisBean passed as a param
	 * 
	 * @param diagn
	 *            new information to update (but same code)
	 * @return Status message
	 * @throws FormValidationException
	 */
	public String updateInformation(DiagnosisBean diagn) throws FormValidationException {
		validator.validate(diagn);
		try {
			int rows = icdDAO.updateCode(diagn);
			if (0 == rows) {
				return &quot;Error: Code not found.&quot;;
			} else {
				transDAO.logTransaction(TransactionType.MANAGE_DIAGNOSIS_CODE, performerID, 0L,
						&quot;updated ICD code &quot; + diagn.getICDCode());
				return &quot;Success: &quot; + rows + &quot; row(s) updated&quot;;
			}
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		}
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_UpdateLOINCListAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.beans.LOINCbean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.LOINCDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.LOINCBeanValidator;

/**
 * Handles updating the LOINC Used.
 * 
 * Logical Observation Identifiers Names and Codes (LOINC) is a database and universal
 *  standard for identifying medical laboratory observations. 
 *  
 * @see http://loinc.org/
 */
public class UpdateLOINCListAction {
	private long performerID = 0;
	private LOINCDAO lDAO;
	private TransactionDAO transDAO;
	private LOINCBeanValidator validator = new LOINCBeanValidator();

	/**
	 * Sets up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param performerID The MID of the person updating the LOINCs.
	 */
	public UpdateLOINCListAction(DAOFactory factory, long performerID) {
		this.performerID = performerID;
		transDAO = factory.getTransactionDAO();
		lDAO = factory.getLOINCDAO();
	}

	/**
	 * Adds a new LOINC
	 * 
	 * @param diagn
	 *            New LOINC
	 * @return Status message
	 * @throws FormValidationException
	 */
	public String add(LOINCbean diagn) throws FormValidationException, iTrustException {
		validator.validate(diagn);

		List&lt;LOINCbean&gt; lblist = lDAO.getAllLOINC();

		boolean correctID = false;
		for (int i = 0; i &lt; lblist.size(); i++) {
			if (lblist.get(i).getLabProcedureCode().equals(diagn.getLabProcedureCode())) {
				correctID = true;
				i = lblist.size();
			}
		}
		if (correctID) {
			throw new FormValidationException(&quot;Error: Code already exists.&quot;);
		}
		lDAO.addLOINC(diagn);
		transDAO.logTransaction(TransactionType.MANAGE_LOINC, performerID, 0L, &quot;added LOINC code &quot;
				+ diagn.getLabProcedureCode());
		return &quot;Success: &quot; + diagn.getLabProcedureCode() + &quot; added&quot;;
	}

	/**
	 * Updates a LOINC
	 * 
	 * @param diagn
	 *            new information to update (but same code)
	 * @return Status message
	 * @throws FormValidationException
	 */
	public String updateInformation(LOINCbean diagn) throws FormValidationException {
		validator.validate(diagn);
		try {
			int rows = lDAO.update(diagn);
			if (0 == rows) {
				return &quot;Error: Code not found.&quot;;
			} else {
				transDAO.logTransaction(TransactionType.MANAGE_LOINC, performerID, 0L, &quot;updated LOINC code &quot;
						+ diagn.getLabProcedureCode());
				return &quot;Success: &quot; + diagn.getLabProcedureCode() + &quot; updated&quot;;
			}
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		}
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_UpdateNDCodeListAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import edu.ncsu.csc.itrust.beans.MedicationBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.NDCodesDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.MedicationBeanValidator;

/**
 * Handles updating the ND Code (Prescription) List Used by editNDCodes.jsp
 * 
 * The National Drug Code (NDC) is a universal product identifier used in the
 * United States for drugs intended for human use.
 * 
 * @see http://www.fda.gov/Drugs/InformationOnDrugs/ucm142438.htm
 * @author laurenhayward
 */
public class UpdateNDCodeListAction {
	private long performerID = 0;
	private TransactionDAO transDAO;
	private NDCodesDAO ndDAO;
	private MedicationBeanValidator validator = new MedicationBeanValidator();

	/**
	 * Set up defaults.
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param performerID The MID of the user updating the ND lists.
	 */
	public UpdateNDCodeListAction(DAOFactory factory, long performerID) {
		this.performerID = performerID;
		ndDAO = factory.getNDCodesDAO();
		transDAO = factory.getTransactionDAO();
	}

	/**
	 * Adds a new ND Code (prescription) to the list
	 * 
	 * @param med
	 *            The new ND Code to be added
	 * @return Status message
	 * @throws FormValidationException
	 */
	public String addNDCode(MedicationBean med) throws FormValidationException {
		validator.validate(med);
		try {
			if (ndDAO.addNDCode(med)) {
				transDAO.logTransaction(TransactionType.MANAGE_DRUG_CODE, performerID, 0L, &quot;added ND code &quot;
						+ med.getNDCode());
				return &quot;Success: &quot; + med.getNDCode() + &quot; - &quot; + med.getDescription() + &quot; added&quot;;
			} else
				return &quot;The database has become corrupt. Please contact the system administrator for assistance.&quot;;
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		} catch (iTrustException e) {
			return e.getMessage();
		}
	}

	/**
	 * Updates the ND Code with new information from the MedicationBean
	 * 
	 * @param med
	 *            the MedicationBean that holds new information but the same code
	 * @return status message
	 * @throws FormValidationException
	 */
	public String updateInformation(MedicationBean med) throws FormValidationException {
		validator.validate(med);
		try {
			int rows = updateCode(med);
			if (0 == rows) {
				return &quot;Error: Code not found.&quot;;
			} else {
				transDAO.logTransaction(TransactionType.MANAGE_DRUG_CODE, performerID, 0L, &quot;updated ND code &quot;
						+ med.getNDCode());
				return &quot;Success: &quot; + rows + &quot; row(s) updated&quot;;
			}
		} catch (DBException e) {
			e.printStackTrace();
			return e.getMessage();
		}
	}

	/**
	 * Medication information should already be validated
	 * 
	 * @param med
	 * @return
	 * @throws DBException
	 */
	private int updateCode(MedicationBean med) throws DBException {
		return ndDAO.updateCode(med);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewAdverseEventAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.beans.AdverseEventBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AdverseEventDAO;
import edu.ncsu.csc.itrust.exception.DBException;

public class ViewAdverseEventAction {
	private AdverseEventDAO adEventDAO;

	public ViewAdverseEventAction(DAOFactory factory)
	{
		this.adEventDAO = factory.getAdverseEventDAO();
	}
	
	public AdverseEventBean getAdverseEvent(int id) throws DBException
	{
		return adEventDAO.getReport(id);
	}
	
	public List&lt;AdverseEventBean&gt; getUnremovedAdverseEventsByCode(String code) throws DBException
	{
		return adEventDAO.getUnremovedAdverseEventsByCode(code);
	}
	
	public String getNameForCode(String code) throws DBException
	{
		return adEventDAO.getNameForCode(code);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewExpiredPrescriptionsAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.EmailUtil;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.beans.PrescriptionBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Handles retrieving beans for viewPrescriptionRecords.jsp
 * 
 * @author laurenhayward
 * 
 */
public class ViewExpiredPrescriptionsAction {
	private PatientDAO patientDAO;
	private PersonnelDAO personnelDAO;
	private TransactionDAO transDAO;
	private EmailUtil emailer;
	private long loggedInMID;

	/**
	 * Set up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person viewing the expired prescriptions.
	 */
	public ViewExpiredPrescriptionsAction(DAOFactory factory, long loggedInMID) {
		this.emailer = new EmailUtil(factory);
		this.patientDAO = factory.getPatientDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
	}
	
	/**
	 * Gets a PatientBean from an MID
	 * 
	 * @param patientID MID of the patient
	 * @return PatientBean for the MID given
	 * @throws iTrustException
	 */
	public PatientBean getPatient(long patientID) throws iTrustException {
		return patientDAO.getPatient(patientID);
	}
	
	/**
	 * Gets the logged in person's representees
	 * 
	 * @return list of PatientBeans holding the representees
	 * @throws iTrustException
	 */
	public List&lt;PatientBean&gt; getRepresentees() throws iTrustException {
		return patientDAO.getRepresented(loggedInMID);
	}
	
	/**
	 * Returns the prescribing HCP for a prescription
	 * 
	 * @param prescription item in question
	 * @return HCP who prescribed the prescription
	 * @throws iTrustException
	 */
	public PersonnelBean getPrescribingDoctor(PrescriptionBean prescription) throws iTrustException {
		return personnelDAO.getPrescribingDoctor(prescription);
	}
	
	/**
	 * Returns all the prescriptions for a given patient
	 * 
	 * @param patientID patient in question
	 * @return list of all the prescriptions for that patient
	 * @throws iTrustException
	 */
	public List&lt;PrescriptionBean&gt; getPrescriptionsForPatient(long patientID) throws iTrustException {
		PatientBean patient = patientDAO.getPatient(patientID);
		if (loggedInMID == patientID) {
			transDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID);
			return patientDAO.getExpiredPrescriptions(patientID);
		}
		
		List&lt;String&gt; toList = new ArrayList&lt;String&gt;();
		toList.add(patient.getEmail());
		
		List&lt;PatientBean&gt; representatives = patientDAO.getRepresenting(patientID);
		for(PatientBean representative : representatives) {
			if (loggedInMID == representative.getMID()) {
				transDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID);
				return patientDAO.getExpiredPrescriptions(patientID);
			}
			toList.add(representative.getEmail());
		}
		
		List&lt;PersonnelBean&gt; dlhcps = patientDAO.getDeclaredHCPs(patientID);
		for(PersonnelBean dlhcp : dlhcps) {
			if (loggedInMID == dlhcp.getMID()) {
				transDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID);
				return patientDAO.getExpiredPrescriptions(patientID);
			}
			List&lt;PersonnelBean&gt; uaps = personnelDAO.getUAPsForHCP(dlhcp.getMID());
			for(PersonnelBean uap : uaps) {
				if (loggedInMID == uap.getMID()) {
					transDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID);
					return patientDAO.getPrescriptions(patientID);
				}
			}
		}
		
		Email email = new Email();
		email.setToList(toList);
		email.setFrom(&quot;noreply@itrust.com&quot;);
		email.setSubject(&quot;Undesignated Personnel Have Accessed Your Prescription Records&quot;);
		email.setBody(&quot;An undesignated HCP or UAP has accessed your prescription records. For more information, please log in to iTrust.&quot;);
		emailer.sendEmail(email);
		transDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID);
		return patientDAO.getPrescriptions(patientID);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewMyAccessLogAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import edu.ncsu.csc.itrust.beans.TransactionBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Handles retrieving the log of record accesses for a given user Used by viewAccessLog.jsp
 * 
 * @author laurenhayward
 * 
 */
public class ViewMyAccessLogAction {
	private TransactionDAO transDAO;
	private long loggedInMID;

	/**
	 * Set up
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person retrieving the logs.
	 */
	public ViewMyAccessLogAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.transDAO = factory.getTransactionDAO();
	}

	/**
	 * Returns a list of TransactionBeans between the two dates passed as params
	 * 
	 * @param lowerDate
	 *            the first date
	 * @param upperDate
	 *            the second date
	 * @return list of TransactionBeans
	 * @throws DBException
	 * @throws FormValidationException
	 */
	public List&lt;TransactionBean&gt; getAccesses(String lowerDate, String upperDate, boolean getByRole) throws DBException,
			FormValidationException {
		List&lt;TransactionBean&gt; accesses;
		if (lowerDate == null || upperDate == null)
			return transDAO.getAllRecordAccesses(loggedInMID, getByRole);
		String message = &quot;&quot;;
		try {
			Date lower = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(lowerDate);
			Date upper = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(upperDate);
			if (lower.after(upper))
				throw new FormValidationException(&quot;Start date must be before end date!&quot;);
			message = &quot;for dates between &quot; + lowerDate + &quot; and &quot; + upperDate;
			transDAO.logTransaction(TransactionType.VIEW_ACCESS_LOG, loggedInMID, 0L, message);
			accesses = transDAO.getRecordAccesses(loggedInMID, lower, upper, getByRole);
		} catch (ParseException e) {
			throw new FormValidationException(&quot;Enter dates in MM/dd/yyyy&quot;);
		}
		return accesses;
	}

	/**
	 * Returns the date of the first Transaction in the list passed as a param if the list is not empty
	 * otherwise, returns today's date
	 * 
	 * @param accesses A java.util.List of TransactionBeans for the accesses.
	 * @return A String representing the date of the first transaction.
	 */
	public String getDefaultStart(List&lt;TransactionBean&gt; accesses) {
		String startDate = &quot;&quot;;
		if (accesses.size() &gt; 0) {
			startDate = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).format(new Date(accesses.get(accesses.size() - 1)
					.getTimeLogged().getTime()));
		} else {
			startDate = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).format(new Date());
		}
		return startDate;
	}

	/**
	 * Returns the date of the last Transaction in the list passed as a param if the list is not empty
	 * otherwise, returns today's date
	 * 
	 * @param accesses A java.util.List of TransactionBeans storing the access. 
	 * @return A String representation of the date of the last transaction.
	 */
	public String getDefaultEnd(List&lt;TransactionBean&gt; accesses) {
		String endDate = &quot;&quot;;
		if (accesses.size() &gt; 0) {
			endDate = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).format(new Date(accesses.get(0).getTimeLogged()
					.getTime()));
		} else {
			endDate = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).format(new Date());
		}
		return endDate;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewMyApptsAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.beans.ApptBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.ApptDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.exception.iTrustException;

public class ViewMyApptsAction {
	private long loggedInMID;
	private ApptDAO apptDAO;
	private PatientDAO patientDAO;
	private PersonnelDAO personnelDAO;
	
	public ViewMyApptsAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.apptDAO = factory.getApptDAO();
		this.patientDAO = factory.getPatientDAO();
		this.personnelDAO = factory.getPersonnelDAO();
	}
	
	public List&lt;ApptBean&gt; getMyAppointments() throws SQLException {
		return apptDAO.getApptsFor(loggedInMID);
	}
	
	/**
	 * Gets a users's name from their MID
	 * 
	 * @param mid the MID of the user
	 * @return the user's name
	 * @throws iTrustException
	 */
	public String getName(long mid) throws iTrustException {
		if(mid &lt; 7000000000L)
			return patientDAO.getName(mid);
		else
			return personnelDAO.getName(mid);
	}
	
	/**
	 * Get All Appointments for the admins use... may need to change!
	 * @return
	 * @throws SQLException
	 */
	public List&lt;ApptBean&gt; getAllAppts()  throws SQLException {
		return apptDAO.getAllAppts();
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewMyMessagesAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.sql.SQLException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import edu.ncsu.csc.itrust.beans.MessageBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.MessageDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Action class for ViewMyMessages.jsp
 *
 */
public class ViewMyMessagesAction {
	private long loggedInMID;
	private PatientDAO patientDAO;
	private PersonnelDAO personnelDAO;
	private MessageDAO messageDAO;

	/**
	 * Set up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the user who is viewing their messages.
	 */
	public ViewMyMessagesAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.patientDAO = factory.getPatientDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.messageDAO = factory.getMessageDAO();
	}
	
	/**
	 * Gets all the messages for the logged in user
	 * 
	 * @return a list of all the user's messages
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getAllMyMessages() throws SQLException {
		
		return messageDAO.getMessagesFor(loggedInMID);
	}
	
	/**
	 * Gets all the messages for the logged in user and sorts by ascending time
	 * 
	 * @return a list of all the user's messages
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getAllMyMessagesTimeAscending() throws SQLException {
		
		return messageDAO.getMessagesTimeAscending(loggedInMID);
	}
	
	/**
	 * Gets all the messages for the logged in user and sorts names in ascending order
	 * 
	 * @return a list of all the user's messages
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getAllMyMessagesNameAscending() throws SQLException {
		
		return messageDAO.getMessagesNameAscending(loggedInMID);
	}
	
	/**
	 * Gets all the messages for the logged in user and sorts name in descending order
	 * 
	 * @return a list of all the user's messages
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getAllMyMessagesNameDescending() throws SQLException {
		
		return messageDAO.getMessagesNameDescending(loggedInMID);
	}
	
	/**
	 * Gets all the sent messages for the logged in user
	 * 
	 * @return a list of all the user's sent messages
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getAllMySentMessages() throws SQLException {
		
		return messageDAO.getMessagesFrom(loggedInMID);
	}
	
	/**
	 * Gets all the messages for the logged in user and sorts by ascending time
	 * 
	 * @return a list of all the user's messages
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getAllMySentMessagesTimeAscending() throws SQLException {
		
		return messageDAO.getMessagesFromTimeAscending(loggedInMID);
	}
	
	/**
	 * Gets all the messages for the logged in user and sorts names in ascending order
	 * 
	 * @return a list of all the user's messages
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getAllMySentMessagesNameAscending() throws SQLException {
		
		return messageDAO.getMessagesFromNameAscending(loggedInMID);
	}
	
	/**
	 * Gets all the messages for the logged in user and sorts name in descending order
	 * 
	 * @return a list of all the user's messages
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getAllMySentMessagesNameDescending() throws SQLException {
		
		return messageDAO.getMessagesFromNameDescending(loggedInMID);
	}
	
	public String validateAndCreateFilter(String filter) {
		String[] f = filter.split(&quot;,&quot;, -1);
		
		DateFormat format = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;);
		Date s = null;
		Date en = null;
		try {	
			if(!f[4].equals(&quot;&quot;))
				s = format.parse(f[4]);
			if(!f[5].equals(&quot;&quot;))
				en = format.parse(f[5]);
			if(s!=null &amp;&amp; en!=null &amp;&amp; en.before(s)) {
				return &quot;Error: The end date cannot be before the start date.&quot;;
			}
		} catch(Exception e) {
			return &quot;Error: A date was not formatted correctly, please enter dates as MM/DD/YYYY&quot;;
		}
		
		for(int i=0; i&lt;f.length; i++) {
			f[i]=f[i].replace(&quot;\&quot;&quot;, &quot;&quot;);
			f[i]=f[i].replace(&quot;&lt;&quot;,&quot;&quot;);
			f[i]=f[i].replace(&quot;&gt;&quot;,&quot;&quot;);
		}
		
		String nf = f[0]+&quot;,&quot;+f[1]+&quot;,&quot;+f[2]+&quot;,&quot;+f[3]+&quot;,&quot;+f[4]+&quot;,&quot;+f[5];
		
		return nf;
	}
	
	/**
	 * Gets a list of messages for a user based on their filter criteria.
	 * 
	 * @param messages List of all of a user's MessageBeans
	 * @param filter String containing a user's filter criteria.
	 * @return a List of MessageBeans that meet the criteria of the filter.
	 * @throws iTrustException
	 * @throws ParseException
	 */
	public List&lt;MessageBean&gt; filterMessages(List&lt;MessageBean&gt; messages, String filter) throws iTrustException, ParseException {
		List&lt;MessageBean&gt; filtered = new ArrayList&lt;MessageBean&gt;();
		String[] f = filter.split(&quot;,&quot;, -1);
		for(MessageBean m : messages) {
			/**
			 * Check the sender filter field.
			 * Exclude if this MessageBean does not match the 
			 * requested sender, if one is specified.
			 */
			if(!f[0].equals(&quot;&quot;)) {
				if(!this.getName(m.getFrom()).equalsIgnoreCase(f[0]))
					continue;
			}
			/**
			 * Check the subject filter field.
			 * Exclude if this MessageBean does not match the 
			 * requested subject, if one is specified.
			 */
			if(!f[1].equals(&quot;&quot;)) {
				if(!m.getSubject().equalsIgnoreCase(f[1]))
					continue;
			}
			/**
			 * Check the body of the message for certain words.
			 * Exclude if this MessageBean if it does not contain 
			 * those words in the message body.
			 */
			if(!f[2].equals(&quot;&quot;)) {
				if(!m.getSubject().toLowerCase().contains(f[2].toLowerCase()) &amp;&amp; !m.getBody().toLowerCase().contains(f[2].toLowerCase()))
					continue;
			}
			/**
			 * Check the body of the message for certain words.
			 * Exclude if this MessageBean if it does contain 
			 * those words in the message body.
			 */
			if(!f[3].equals(&quot;&quot;)) {
				if(m.getSubject().toLowerCase().contains(f[3].toLowerCase()) || m.getBody().toLowerCase().contains(f[3].toLowerCase()))
					continue;
			}
			/**
			 * Check the start date filter field.
			 * Exclude if this MessageBean was not sent after
			 * this date.
			 */
			if(!f[4].equals(&quot;&quot;)) {
				DateFormat format = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;);
				Date s = format.parse(f[4]);
				if(s.after(m.getSentDate()))
						continue;
				
			}
			/**
			 * Check the end date filter field.
			 * Exclude if this MessageBean was not sent before
			 * this date.
			 */
			if(!f[5].equals(&quot;&quot;)) {
				DateFormat format = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;);
				Date s = format.parse(f[5]);
				Calendar c = Calendar.getInstance();
				c.setTime(s);
				c.add(Calendar.DAY_OF_MONTH, 1);
				s = c.getTime();
				if(s.before(m.getSentDate()))
						continue;
				
			}
			/**
			 * If the message has not been eliminated by any 
			 * of the filter fields, add it to the new list 
			 * of messages.
			 */
			filtered.add(m);
		}
		
		return filtered;
	}
	
	/**
	 * Gets a patient's name from their MID
	 * 
	 * @param mid the MID of the patient
	 * @return the patient's name
	 * @throws iTrustException
	 */
	public String getName(long mid) throws iTrustException {
		if(mid &lt; 7000000000L)
			return patientDAO.getName(mid);
		else
			return personnelDAO.getName(mid);
	}
	
	/**
	 * Gets a personnel's name from their MID
	 * 
	 * @param mid the MID of the personnel
	 * @return the personnel's name
	 * @throws iTrustException
	 */
	public String getPersonnelName(long mid) throws iTrustException {
		return personnelDAO.getName(mid);
	}
	
	/**
	 * Set the state of the MessageBean to read, after 
	 * it is read by a user.
	 * @param mBean MessageBean to be read
	 */
	public void setRead(MessageBean mBean) {
		try {
			messageDAO.updateRead(mBean);
		} catch (DBException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewMyRecordsAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.AllergyBean;
import edu.ncsu.csc.itrust.beans.DiagnosisBean;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.FamilyMemberBean;
import edu.ncsu.csc.itrust.beans.HealthRecord;
import edu.ncsu.csc.itrust.beans.LabProcedureBean;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.beans.ReportRequestBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AllergyDAO;
import edu.ncsu.csc.itrust.dao.mysql.FakeEmailDAO;
import edu.ncsu.csc.itrust.dao.mysql.FamilyDAO;
import edu.ncsu.csc.itrust.dao.mysql.HealthRecordsDAO;
import edu.ncsu.csc.itrust.dao.mysql.LabProcedureDAO;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.ReportRequestDAO;
import edu.ncsu.csc.itrust.dao.mysql.SurveyDAO;
import edu.ncsu.csc.itrust.dao.mysql.ICDCodesDAO;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Handles patients viewing their own records Used by viewMyRecords.jsp
 * 
 * @author laurenhayward
 * 
 */
public class ViewMyRecordsAction {
	private PatientDAO patientDAO;
	private PersonnelDAO personnelDAO;
	private AllergyDAO allergyDAO;
	private FamilyDAO familyDAO;
	private HealthRecordsDAO hrDAO;
	private OfficeVisitDAO ovDAO;
	private SurveyDAO surveyDAO;
	private LabProcedureDAO labDAO;
	private FakeEmailDAO emailDAO;
	private ICDCodesDAO icdDAO;
	private ReportRequestDAO reportRequestDAO;
	private long loggedInMID;

	/**
	 * Set up
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person viewing the records.
	 */
	public ViewMyRecordsAction(DAOFactory factory, long loggedInMID) {
		this.patientDAO = factory.getPatientDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.allergyDAO = factory.getAllergyDAO();
		this.familyDAO = factory.getFamilyDAO();
		this.hrDAO = factory.getHealthRecordsDAO();
		this.ovDAO = factory.getOfficeVisitDAO();
		this.surveyDAO = factory.getSurveyDAO();
		this.labDAO = factory.getLabProcedureDAO();
		this.emailDAO = factory.getFakeEmailDAO();
		this.reportRequestDAO = factory.getReportRequestDAO();
		this.icdDAO = factory.getICDCodesDAO();
		this.loggedInMID = loggedInMID;
	}

	/**
	 * Takes the patient's representee as a param and returns it as a long if the patient represents the input
	 * param
	 * 
	 * @param input
	 *            the patient's representee mid
	 * @return representee's mid as a long
	 * @throws iTrustException
	 */
	public long representPatient(String input) throws iTrustException {

		try {
			long reppeeMID = Long.valueOf(input);
			if (patientDAO.represents(loggedInMID, reppeeMID)) {
				loggedInMID = reppeeMID;
				return reppeeMID;
			} else
				throw new iTrustException(&quot;You do not represent patient &quot; + reppeeMID);
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;MID is not a number&quot;);
		}
	}

	/**
	 * Returns a PatientBean for the currently logged in patient
	 * 
	 * @return PatientBean for the currently logged in patient
	 * @throws iTrustException
	 */
	public PatientBean getPatient() throws iTrustException {
		return patientDAO.getPatient(loggedInMID);
	}
	
	/**
	 * Returns a PatientBean for the specified MID
	 * @param mid id of the requested bean
	 * @return PatientBean for the specified MID
	 * @throws iTrustException
	 */
	public PatientBean getPatient(long mid) throws iTrustException {
		return patientDAO.getPatient(mid);
	}

	/**
	 * Returns a PersonnelBean for the requested MID
	 * @param mid id of the requested bean
	 * @return a PersonnelBean for the requested MID
	 * @throws iTrustException
	 */
	public PersonnelBean getPersonnel(long mid) throws iTrustException {
		return personnelDAO.getPersonnel(mid);
	}

	/**
	 * Returns a PatientBean for the currently logged in patient
	 * 
	 * @return PatientBean for the currently logged in patient
	 * @throws iTrustException
	 */
	public List&lt;Email&gt; getEmailHistory() throws iTrustException {
		return emailDAO.getEmailsByPerson(getPatient().getEmail());
	}

	/**
	 * Returns a list of AllergyBeans for the currently logged in patient
	 * 
	 * @return a list of AllergyBeans for the currently logged in patient
	 * @throws iTrustException
	 */
	public List&lt;AllergyBean&gt; getAllergies() throws iTrustException {
		return allergyDAO.getAllergies(loggedInMID);
	}

	/**
	 * Returns a list of Parents, Siblings, and Children of the currently logged in patient
	 * 
	 * @return list of FamilyMemberBeans
	 */
	public List&lt;FamilyMemberBean&gt; getFamily() throws iTrustException {
		List&lt;FamilyMemberBean&gt; fam = new ArrayList&lt;FamilyMemberBean&gt;();
		List&lt;FamilyMemberBean&gt; parents = null;
		try {
			parents = familyDAO.getParents(loggedInMID);
			fam.addAll(parents);
			fam.addAll(familyDAO.getSiblings(loggedInMID));
			fam.addAll(familyDAO.getChildren(loggedInMID));
		} catch (DBException e) {
			throw new iTrustException(e.getMessage());
		}
		
		if(parents != null) {
			List&lt;FamilyMemberBean&gt; grandparents = new ArrayList&lt;FamilyMemberBean&gt;();
			for(FamilyMemberBean parent : parents) {
				try {
					grandparents.addAll(familyDAO.getParents(parent.getMid()));
				} catch (DBException e) {
					throw new iTrustException(e.getMessage());
				}
			}
			
			fam.addAll(grandparents);
			
			for(FamilyMemberBean gp : grandparents) {
				gp.setRelation(&quot;Grandparent&quot;);
			}
		}
		return fam;
	}
	
	/**
	 * Returns a list of Parents, Siblings, and Grand Parents of the currently logged in patient
	 * 
	 * @return list of FamilyMemberBeans
	 */
	public List&lt;FamilyMemberBean&gt; getFamilyHistory() throws iTrustException {
		List&lt;FamilyMemberBean&gt; fam = new ArrayList&lt;FamilyMemberBean&gt;();
		List&lt;FamilyMemberBean&gt; parents = null;
		try {
			parents = familyDAO.getParents(loggedInMID);
			fam.addAll(parents);
			fam.addAll(familyDAO.getSiblings(loggedInMID));
		} catch (DBException e) {
			throw new iTrustException(e.getMessage());
		}
		
		if(parents != null) {
			List&lt;FamilyMemberBean&gt; grandparents = new ArrayList&lt;FamilyMemberBean&gt;();
			for(FamilyMemberBean parent : parents) {
				try {
					grandparents.addAll(familyDAO.getParents(parent.getMid()));
				} catch (DBException e) {
					throw new iTrustException(e.getMessage());
				}
			}
			
			fam.addAll(grandparents);
			
			for(FamilyMemberBean gp : grandparents) {
				gp.setRelation(&quot;Grandparent&quot;);
			}
		}
		return fam;
	}

	/**
	 * Returns a list of HealthRecords for the currently logged in patient
	 * 
	 * @return a list of HealthRecords for the currently logged in patient
	 * @throws iTrustException
	 */
	public List&lt;HealthRecord&gt; getAllHealthRecords() throws iTrustException {
		return hrDAO.getAllHealthRecords(loggedInMID);
	}
	
	/**
	 * Returns a list of HealthRecords for the specified family member
	 * 
	 * @return a list of HealthRecords for the specified family member
	 * @throws iTrustException
	 */
	public List&lt;HealthRecord&gt; getFamilyHealthRecords(long mid) throws iTrustException {
		return hrDAO.getAllHealthRecords(mid);
	}

	/**
	 * Returns a list of OfficeVisitBeans for all office visits for the currently logged in patient
	 * 
	 * @return  a list of OfficeVisitBeans for all office visits for the currently logged in patient
	 * @throws iTrustException
	 */
	public List&lt;OfficeVisitBean&gt; getAllOfficeVisits() throws iTrustException {
		return ovDAO.getAllOfficeVisits(loggedInMID);
	}

	/**
	 * Returns a complete OfficeVisitBean given a visitID
	 * 
	 * @return a complete OfficeVisitBean given a visitID
	 * @throws iTrustException
	 */
	public OfficeVisitBean getCompleteOfficeVisit(long visitID) throws iTrustException {
		return ovDAO.getOfficeVisit(visitID);
	}
	
	/**
	 * Returns a list of PatientBeans of all patients the currently logged in patient represents
	 * 
	 * @return a list of PatientBeans of all patients the currently logged in patient represents
	 * @throws iTrustException
	 */
	public List&lt;PatientBean&gt; getRepresented() throws iTrustException {
		return patientDAO.getRepresented(loggedInMID);
	}

	/**
	 * Returns a list of PatientBeans of all patients the currently logged in patient represents
	 * 
	 * @return a list of PatientBeans of all patients the currently logged in patient represents
	 * @throws iTrustException
	 */
	public List&lt;PatientBean&gt; getRepresenting() throws iTrustException {
		return patientDAO.getRepresenting(loggedInMID);
	}

	/**
	 * Has a survey been created for this office visit
	 * 
	 * @param visitID ID of the office visit in question
	 * @return true if the survey has been completed, otherwise false
	 * @throws iTrustException
	 */
	public boolean isSurveyCompleted(long visitID) throws iTrustException {
		return surveyDAO.isSurveyCompleted(visitID);
	}

	/**
	 * Returns a list of lab procedures
	 * 
	 * @return a list of lab procedures for the logged in patient
	 * @throws DBException
	 */
	public List&lt;LabProcedureBean&gt; getLabs() throws iTrustException {
		return labDAO.getLabProceduresForPatient(loggedInMID);

	}

	/**
	 * Returns all the report requests for the logged in patient
	 * @return the report requests for the logged in patient
	 * @throws iTrustException
	 */
	public List&lt;ReportRequestBean&gt; getReportRequests() throws iTrustException {
		return reportRequestDAO.getAllReportRequestsForPatient(loggedInMID);
	}
	
	/**
	 * Checks to see if family members have high blood pressure
	 * 
	 * @param member the family member in question
	 * @return true if the family member has the risk factor, otherwise false.
	 * @throws iTrustException
	 */
	public boolean doesFamilyMemberHaveHighBP(FamilyMemberBean member) throws iTrustException {
		List&lt;HealthRecord&gt; records = hrDAO.getAllHealthRecords(member.getMid());
		if(records.size() == 0)
			return false;
		for(HealthRecord record : records) {
			if(record.getBloodPressureSystolic() &gt; 240 || record.getBloodPressureDiastolic() &gt; 120 )
				return true;
		}
		return false;
	}
	
	/**
	 * Checks to see if family members have high cholesterol
	 * 
	 * @param member the family member in question
	 * @return true if the family member has the risk factor, otherwise false.
	 * @throws iTrustException
	 */
	public boolean doesFamilyMemberHaveHighCholesterol(FamilyMemberBean member) throws iTrustException {
		List&lt;HealthRecord&gt; records = hrDAO.getAllHealthRecords(member.getMid());
		if(records.size() == 0)
			return false;
		for(HealthRecord record : records) {
			if(record.getCholesterolHDL() &lt; 35 || record.getCholesterolLDL() &gt; 250 )
				return true;
		}
		return false;
	}
	
	/**
	 * Checks to see if family members have diabetes
	 * 
	 * @param member the family member in question
	 * @return true if the family member has the risk factor, otherwise false.
	 * @throws iTrustException
	 */
	public boolean doesFamilyMemberHaveDiabetes(FamilyMemberBean member) throws iTrustException {
		List&lt;DiagnosisBean&gt; diagnoses = patientDAO.getDiagnoses(member.getMid());
		if(diagnoses.size() == 0)
			return false;
		for(DiagnosisBean diag : diagnoses) {
			if(diag.getICDCode().startsWith(&quot;250&quot;))
				return true;
		}
		return false;
	}
	
	/**
	 * Checks to see if family members have cancer
	 * 
	 * @param member the family member in question
	 * @return true if the family member has the risk factor, otherwise false.
	 * @throws iTrustException
	 */
	public boolean doesFamilyMemberHaveCancer(FamilyMemberBean member) throws iTrustException {
		List&lt;DiagnosisBean&gt; diagnoses = patientDAO.getDiagnoses(member.getMid());
		if(diagnoses.size() == 0)
			return false;
		for(DiagnosisBean diag : diagnoses) {
			if(diag.getICDCode().startsWith(&quot;199&quot;))
				return true;
		}
		return false;
	}
	
	/**
	 * Checks to see if family members have heart disease
	 * 
	 * @param member the family member in question
	 * @return true if the family member has the risk factor, otherwise false.
	 * @throws iTrustException
	 */
	public boolean doesFamilyMemberHaveHeartDisease(FamilyMemberBean member) throws iTrustException {
		List&lt;DiagnosisBean&gt; diagnoses = patientDAO.getDiagnoses(member.getMid());
		if(diagnoses.size() == 0)
			return false;
		for(DiagnosisBean diag : diagnoses) {
			if(diag.getICDCode().startsWith(&quot;402&quot;))
				return true;
		}
		return false;
	}
	
	/**
	 * Checks to see if family members smoke
	 * 
	 * @param member the family member in question
	 * @return true if the family member has the risk factor, otherwise false.
	 * @throws iTrustException
	 */
	public boolean isFamilyMemberSmoker(FamilyMemberBean member) throws iTrustException {
		List&lt;HealthRecord&gt; records = hrDAO.getAllHealthRecords(member.getMid());
		if(records.size() == 0)
			return false;
		for(HealthRecord record : records) {
			if(record.isSmoker())
				return true;
		}
		return false;
	}
	
	/**
	 * Checks to see if family member is dead, and if so, what their cause of death was
	 * 
	 * @param member the family member in question
	 * @return the cause of death for the family member
	 * @throws iTrustException
	 */
	public String getFamilyMemberCOD(FamilyMemberBean member) throws iTrustException {
		PatientBean patient = patientDAO.getPatient(member.getMid());
		if(patient.getCauseOfDeath() == null)
			return &quot;&quot;;
		DiagnosisBean diag = icdDAO.getICDCode(patient.getCauseOfDeath());
		if(diag == null)
			return &quot;&quot;;
		return diag.getDescription();
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewMyRemoteMonitoringListAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import edu.ncsu.csc.itrust.beans.RemoteMonitoringDataBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.RemoteMonitoringDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Handles retrieving the patient data for a certain HCP as used by viewTelemedicineData.jsp
 * 
 */
public class ViewMyRemoteMonitoringListAction {
	private RemoteMonitoringDAO rmDAO;
	private TransactionDAO transDAO;
	private AuthDAO authDAO;
	private long loggedInMID;

	/**
	 * Constructor
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the HCP retrieving the patient data.
	 */
	public ViewMyRemoteMonitoringListAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.rmDAO = factory.getRemoteMonitoringDAO();
		this.transDAO = factory.getTransactionDAO();
		this.authDAO = factory.getAuthDAO();
	}

	/**
	 * Returns a list of RemoteMonitoringDataBeans for the logged in HCP
	 * 
	 * @return list of TransactionBeans
	 * @throws DBException
	 * @throws FormValidationException
	 */
	public List&lt;RemoteMonitoringDataBean&gt; getPatientsData() throws DBException {
		
		transDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID);
		return rmDAO.getPatientsData(loggedInMID);
		
	}
	
	/**
	 * Returns a list of RemoteMonitoringDataBeans for the logged in HCP
	 * 
	 * @return list of TransactionBeans
	 * @throws DBException
	 * @throws FormValidationException
	 */
	public List&lt;RemoteMonitoringDataBean&gt; getPatientDataByDate(long patientMID, String startDate, String endDate) throws DBException,FormValidationException {
		Date lower;
		Date upper;
		try {
			lower = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(startDate);
			upper = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(endDate);
			if (lower.after(upper))
				throw new FormValidationException(&quot;Start date must be before end date!&quot;);
		} catch (ParseException e) {
			throw new FormValidationException(&quot;Enter dates in MM/dd/yyyy&quot;);
		}		
		
		transDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID);
		return rmDAO.getPatientDataByDate(patientMID, lower, upper);
		
	}
	
	public List&lt;RemoteMonitoringDataBean&gt; getPatientDataWithoutLogging() throws DBException {
		return rmDAO.getPatientsData(loggedInMID);
	}
	
	/**
	 * returns the patient name
	 * 
	 * @return patient name
	 * @throws DBException
	 * @throws iTrustException
	 */
	public String getPatientName(long pid) throws DBException, iTrustException {
		return authDAO.getUserName(pid);
	}
	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewMyReportRequestsAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.Calendar;
import java.util.List;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.beans.ReportRequestBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.ReportRequestDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Action class for ViewMyReports.jsp.  Allows the user to see all their reports
 */
public class ViewMyReportRequestsAction {
	private long loggedInMID;
	private ReportRequestDAO reportRequestDAO;
	private PersonnelDAO personnelDAO;
	private TransactionDAO transDAO;
	//private DAOFactory factory;

	/**
	 * Set up
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person viewing their report requests.
	 */
	public ViewMyReportRequestsAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.reportRequestDAO = factory.getReportRequestDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.transDAO = factory.getTransactionDAO();
		//this.factory = factory;
	}

	/**
	 * Returns all the reports for the currently logged in HCP
	 * 
	 * @return list of all reports for the logged in HCP
	 * @throws iTrustException
	 */
	public List&lt;ReportRequestBean&gt; getAllReportRequestsForRequester() throws iTrustException {
		return reportRequestDAO.getAllReportRequestsForRequester(loggedInMID);
	}

//	/**
//	 * Returns a list of *all* reports
//	 * 
//	 * @return list of all reports
//	 * @throws iTrustException
//	 */
//	public List&lt;ReportRequestBean&gt; getAllReportRequests() throws iTrustException {
//		return reportRequestDAO.getAllReportRequests();
//	}

	/**
	 * Adds a report request to the list
	 * 
	 * @param patientMID ID of the patient that the report request is for
	 * @return
	 * @throws iTrustException
	 */
	public long addReportRequest(long patientMID) throws iTrustException {
		long id = reportRequestDAO
				.addReportRequest(loggedInMID, patientMID, Calendar.getInstance().getTime());
		transDAO.logTransaction(TransactionType.COMPREHENSIVE_REPORT_REQUEST, loggedInMID, patientMID,
				&quot;Added comprehensive report request&quot;);
		return id;

	}

//	/**
//	 * Approves a report request from the list.  E-mail is sent when the request is approved.
//	 * 
//	 * @param ID id of the request
//	 * @throws iTrustException
//	 */
//	public void approveReportRequest(long ID) throws iTrustException {
//		ReportRequestBean rr = reportRequestDAO.getReportRequest(ID);
//		reportRequestDAO.approveReportRequest(ID, loggedInMID, Calendar.getInstance().getTime());
//		transDAO.logTransaction(TransactionType.COMPREHENSIVE_REPORT_REQUEST, loggedInMID,
//				rr.getPatientMID(), &quot;Approved comprehensive report request&quot;);
//		new EmailUtil(factory).sendEmail(makeEmailApp(loggedInMID, rr.getRequesterMID(), rr.getPatientMID()));
//
//	}

//	/**
//	 * 
//	 * Sends e-mail regarding the approved request.
//	 * 
//	 * @param adminID admin who approved the request
//	 * @param hcpID HCP the request is for
//	 * @param pid ID of the patient the report is about
//	 * @return the sent e-mail
//	 * @throws DBException
//	 */
//	private Email makeEmailApp(long adminID, long hcpID, long pid) throws DBException {
//
//		PatientBean p = new PatientDAO(factory).getPatient(pid);
//
//		Email email = new Email();
//		email.setFrom(&quot;no-reply@itrust.com&quot;);
//		email.setToList(Arrays.asList(p.getEmail()));
//		email.setSubject(&quot;A Report has been generated in iTrust&quot;);
//		email
//				.setBody(String
//						.format(
//								&quot;Dear %s, \n The iTrust Health Care Provider (%s) submitted a request to view your full medical records.  The iTrust administrator (%s) approved a one-time viewing of this report.  You will be notified when the HCP chooses to view it.&quot;,
//								p.getFullName(), hcpID, adminID));
//		return email;
//	}

//	/**
//	 * Rejects a request from the list.
//	 * 
//	 * @param ID id of the rejected request
//	 * @param comment why the request was rejected
//	 * @throws iTrustException
//	 */
//	public void rejectReportRequest(long ID, String comment) throws iTrustException {
//		reportRequestDAO.rejectReportRequest(ID, loggedInMID, Calendar.getInstance().getTime(), comment);
//		transDAO.logTransaction(TransactionType.COMPREHENSIVE_REPORT_REQUEST, loggedInMID, 0L,
//				&quot;Rejected comprehensive report request&quot;);
//	}

	/**
	 * Returns the requested report
	 * 
	 * @param ID id of the requested report
	 * @return the requested report
	 * @throws iTrustException
	 */
	public ReportRequestBean getReportRequest(int ID) throws iTrustException {
		return reportRequestDAO.getReportRequest(ID);
	}
	
/**
 * Sets the viewed status of the report.  If the report is &quot;viewed&quot; the HCP must request a new one to see it again.
 * 
 * @param ID id of the report
 * @throws iTrustException
 */
	public void setViewed(int ID) throws iTrustException {
//		ReportRequestBean rr = reportRequestDAO.getReportRequest(ID);
		reportRequestDAO.setViewed(ID, Calendar.getInstance().getTime());
		transDAO.logTransaction(TransactionType.COMPREHENSIVE_REPORT_REQUEST, loggedInMID, 0L,
				&quot;Viewed comprehensive report&quot;);
		//new EmailUtil(factory).sendEmail(makeEmailView(rr.getApproverMID(), rr.getRequesterMID(), rr
			//	.getPatientMID()));

	}

//	/**
//	 * 
//	 * Sends e-mail regarding the request to the patient.
//	 * 
//	 * @param adminID admin who approved the request
//	 * @param hcpID HCP the request is for
//	 * @param pid ID of the patient the report is about
//	 * @return the sent e-mail
//	 * @throws DBException
//	 */
//	private Email makeEmailView(long adminID, long hcpID, long pid) throws DBException {
//
//		PatientBean p = new PatientDAO(factory).getPatient(pid);
//
//		Email email = new Email();
//		email.setFrom(&quot;no-reply@itrust.com&quot;);
//		email.setToList(Arrays.asList(p.getEmail()));
//		email.setSubject(&quot;A Report has been generated in iTrust&quot;);
//		email
//				.setBody(String
//						.format(
//								&quot;Dear %s, \n The iTrust Health Care Provider (%s) has chosen to view your full medical report, which was approved by an iTrust administrator (%s).  This report was only viewable one time and is no longer available.&quot;,
//								p.getFullName(), hcpID, adminID));
//		return email;
//	}

	/**
	 * Gets the status of the request
	 * 
	 * @param id id of the request
	 * @return the request's status
	 * @throws iTrustException
	 */
	public String getLongStatus(long id) throws iTrustException {
		StringBuilder s = new StringBuilder();
		ReportRequestBean r = reportRequestDAO.getReportRequest(id);
		if (r.getStatus().equals(ReportRequestBean.Requested)) {
			PersonnelBean p = personnelDAO.getPersonnel(r.getRequesterMID());
			s.append(String.format(&quot;Request was requested on %s by %s&quot;, r.getRequestedDateString(), p
					.getFullName()));
		}
//		if (r.getStatus().equals(ReportRequestBean.Approved)) {
//			PersonnelBean p = personnelDAO.getPersonnel(r.getRequesterMID());
//			PersonnelBean p2 = personnelDAO.getPersonnel(r.getApproverMID());
//			s.append(String.format(&quot;Request was requested on %s by %s &quot;, r.getRequestedDateString(), p
//					.getFullName()));
//			s.append(String.format(&quot;and approved on %s by %s&quot;, r.getApprovedDateString(), p2.getFullName()));
//		}
//		if (r.getStatus().equals(ReportRequestBean.Rejected)) {
//			PersonnelBean p = personnelDAO.getPersonnel(r.getRequesterMID());
//			PersonnelBean p2 = personnelDAO.getPersonnel(r.getApproverMID());
//			s.append(String.format(&quot;Request was requested on %s by %s &quot;, r.getRequestedDateString(), p
//					.getFullName()));
//			s.append(String.format(&quot;and rejected on %s by %s&quot;, r.getApprovedDateString(), p2.getFullName()));
//		}
		if (r.getStatus().equals(ReportRequestBean.Viewed)) {
			PersonnelBean p = personnelDAO.getPersonnel(r.getRequesterMID());
//			PersonnelBean p2 = personnelDAO.getPersonnel(r.getApproverMID());
			String fullName = &quot;Unknown&quot;;
			if(p != null){
				fullName = p.getFullName();
				s.append(String.format(&quot;Request was requested on %s by %s, &quot;, r.getRequestedDateString(), p
					.getFullName()));
			}
//			s.append(String.format(&quot;approved on %s by %s, &quot;, r.getApprovedDateString(), fullName));
			s.append(&quot;&quot;);// removed &quot;&lt;br /&gt;&quot; because it caused unit test to fail and seems to have no
			// purpose
			s.append(String.format(&quot;and viewed on %s by %s&quot;, r.getViewedDateString(), fullName));
		}

		return s.toString();
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewOfficeVisitAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.action.base.OfficeVisitBaseAction;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.beans.PrescriptionBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.Messages;

/**
 * Handles viewing the office visits, prescriptions, and HCP name for the given ovID Used by
 * viewOfficeVisit.jsp
 * 
 * @author laurenhayward
 * 
 */
public class ViewOfficeVisitAction extends OfficeVisitBaseAction {
	private OfficeVisitDAO ovDAO;
	private PersonnelDAO personnelDAO;
	private PatientDAO patientDAO;

	/**
	 * Super class handles validating the loggedInMid and ovIDString
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person viewing their office visits. 
	 * @param ovIDString
	 *            The unique identifier of the office visit as a String.
	 * @throws iTrustException
	 */
	public ViewOfficeVisitAction(DAOFactory factory, long loggedInMID, String ovIDString)
			throws iTrustException {
		super(factory, String.valueOf(loggedInMID), ovIDString);
		this.personnelDAO = factory.getPersonnelDAO();
		this.ovDAO = factory.getOfficeVisitDAO();
	}

	/**
	 * Super class handles validating the pidString and ovIDString. Usually used for representing a patient.
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param repPIDString The MID of the representative viewing the records.
	 * @param ovIDString
	 *            The unique identifier of the office visit as a String.
	 * @throws iTrustException
	 */
	public ViewOfficeVisitAction(DAOFactory factory, long loggedInMID, String repPIDString, String ovIDString)
			throws iTrustException {
		super(factory, repPIDString, ovIDString);
		this.personnelDAO = factory.getPersonnelDAO();
		this.patientDAO = factory.getPatientDAO();
		this.ovDAO = factory.getOfficeVisitDAO();
		checkRepresented(loggedInMID, repPIDString);
	}

	private void checkRepresented(long loggedInMID, String repPIDString) throws iTrustException {
		try {
			long repee = Long.valueOf(repPIDString);
			if (!patientDAO.represents(loggedInMID, repee))
				throw new iTrustException(
						Messages.getString(&quot;ViewOfficeVisitAction.0&quot;)); //$NON-NLS-1$
		} catch (NumberFormatException e) {
			throw new iTrustException(Messages.getString(&quot;ViewOfficeVisitAction.1&quot;)); //$NON-NLS-1$
		}
	}

	/**
	 * Returns the office visit as an OfficeVisitBean for the ovID that was initially passed to the
	 * constructor
	 * 
	 * @return the OfficeVisitBean for the ovID
	 * @throws iTrustException
	 */
	public OfficeVisitBean getOfficeVisit() throws iTrustException {
		return ovDAO.getOfficeVisit(ovID);
	}

	/**
	 * Returns the prescriptions associated with the ovID initially passed to the constructor
	 * 
	 * @return list of PrescriptionBeans for the ovID
	 * @throws DBException
	 */
	public List&lt;PrescriptionBean&gt; getPrescriptions() throws DBException {
		return ovDAO.getPrescriptions(ovID);
	}

	/**
	 * Returns the name of the HCP for the hcpID passed as a param
	 * 
	 * @param hcpID
	 * @return the name of the HCP
	 * @throws iTrustException
	 */
	public String getHCPName(long hcpID) throws iTrustException {
		String name = null;
		try {
			name = personnelDAO.getName(hcpID);
		} catch (iTrustException e) {
			e.printStackTrace();
			name = e.getMessage();
		}
		return name;
			
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewPatientOfficeVisitHistoryAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.PatientVisitBean;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * 
 * Action class for ViewPatientOfficeVisitHistory.jsp
 *
 */
public class ViewPatientOfficeVisitHistoryAction {
	private long loggedInMID;
	private PatientDAO patientDAO;
	private TransactionDAO transDAO;
	private PersonnelDAO personnelDAO;
	private OfficeVisitDAO officevisitDAO;
	private ArrayList&lt;PatientVisitBean&gt; visits;

	/**
	 * Set up defaults
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person viewing the office visits.
	 */
	public ViewPatientOfficeVisitHistoryAction(DAOFactory factory, long loggedInMID) {
		this.loggedInMID = loggedInMID;
		this.personnelDAO = factory.getPersonnelDAO();
		this.transDAO = factory.getTransactionDAO();
		officevisitDAO = factory.getOfficeVisitDAO();
		this.patientDAO = factory.getPatientDAO();
		
		visits = new ArrayList&lt;PatientVisitBean&gt;();
		
	}
	
	/**
	 * Adds all the office visits for the logged in HCP to a list.
	 * 
	 * @throws iTrustException
	 */
	private void processOfficeVisits() throws iTrustException {
		try {
			List&lt;OfficeVisitBean&gt; ovlist = officevisitDAO.getAllOfficeVisitsForLHCP(loggedInMID);
			Iterator&lt;OfficeVisitBean&gt; it = ovlist.iterator();
			OfficeVisitBean ov;
			PatientVisitBean visitBean;
			
			while (it.hasNext()) {
				visitBean = new PatientVisitBean();
				ov = it.next();
				PatientBean pb;
				pb = patientDAO.getPatient(ov.getPatientID());
				visitBean.setPatient(pb);
				visitBean.setPatientName(pb.getFullName());
				String date = ov.getVisitDateStr();
				Scanner sc = new Scanner(date);
				sc.useDelimiter(&quot;/&quot;);
				String month = sc.next();
				String day = sc.next();
				String year = sc.next();
				visitBean.setLastOVDateM(month);
				visitBean.setLastOVDateD(day);
				visitBean.setLastOVDateY(year);
				visitBean.setLastOVDate(year +&quot;-&quot; + month +&quot;-&quot; + date);
				visitBean.setAddress1(pb.getStreetAddress1() +&quot; &quot; + pb.getStreetAddress2());
				visitBean.setAddress2(pb.getCity() + &quot; &quot; +pb.getState() +&quot; &quot; +pb.getZip());
				boolean b = PatientInList(pb,date);
				if(b == false)
					visits.add(visitBean);
				
			}
		}
		catch (DBException dbe) {
			throw new iTrustException(dbe.getMessage());
		}
	}
	
	/**
	 * Checks to see if a patient is in the list of  visits
	 * @param pb patient to check
	 * @param date date of the visit
	 * @return True if the patient is in the list of visits.
	 */
	private boolean PatientInList(PatientBean pb, String date) {
		Iterator&lt;PatientVisitBean&gt; it = visits.iterator();
		PatientVisitBean visitBean;
		while (it.hasNext()){
			visitBean = it.next();
		if(visitBean.getPatientName().equals(pb.getFullName())){
				
				if(visitBean.getLastOVDateY().compareTo(date) &lt; 0){
					visitBean.setLastOVDate(date);
				}
					return true;
				}
		}		
		
		return false;
	}
/**
 * Get the list of patients an HCP has had office visits with
 * 
 * @return the list of patients an HCP has had office visits with
 * @throws DBException
 */
	public List&lt;PatientVisitBean&gt; getPatients() throws DBException {
		
		try {
			processOfficeVisits();
		}
		catch (iTrustException ie) {
			
		}
		//log transaction
		transDAO.logTransaction(TransactionType.VIEW_PATIENT_LIST,loggedInMID);
		
		return visits;
	}
	/**
	 * Returns a PersonnelBean for the logged in HCP
	 * @return PersonnelBean for the logged in HCP
	 * @throws iTrustException
	 */
	public PersonnelBean getPersonnel() throws iTrustException {
		return personnelDAO.getPersonnel(loggedInMID);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewPersonnelAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.FakeEmailDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.Messages;

/**
 * Handles retrieving personnel beans for a given personnel Used by viewPersonnel.jsp
 * 
 * @author laurenhayward
 * 
 */
public class ViewPersonnelAction {
	private PersonnelDAO personnelDAO;
	private TransactionDAO transDAO;
	private FakeEmailDAO emailDAO;
	private long loggedInMID;

	/**
	 * Set up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person retrieving personnel beans.
	 */
	public ViewPersonnelAction(DAOFactory factory, long loggedInMID) {
		this.emailDAO = factory.getFakeEmailDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
	}

	/**
	 * Retrieves a PersonnelBean for the mid passed as a param
	 * 
	 * @param input
	 *            the mid for which the PersonnelBean will be returned
	 * @return PersonnelBean
	 * @throws iTrustException
	 */
	public PersonnelBean getPersonnel(String input) throws iTrustException {
		try {
			long mid = Long.valueOf(input);
			PersonnelBean personnel = personnelDAO.getPersonnel(mid);
			if (personnel != null) {
				transDAO.logTransaction(TransactionType.ENTER_EDIT_DEMOGRAPHICS, loggedInMID, mid,
						Messages.getString(&quot;ViewPersonnelAction.0&quot;) + mid); //$NON-NLS-1$
				return personnel;
			} else
				throw new iTrustException(Messages.getString(&quot;ViewPersonnelAction.1&quot;)); //$NON-NLS-1$
		} catch (NumberFormatException e) {
			e.printStackTrace();
			throw new iTrustException(Messages.getString(&quot;ViewPersonnelAction.2&quot;)); //$NON-NLS-1$
		}
	}
	
	/**
	 * Returns a PatientBean for the currently logged in personnel
	 * 
	 * @return The PatientBean
	 * @throws iTrustException
	 */
	public List&lt;Email&gt; getEmailHistory() throws iTrustException {
		return emailDAO.getEmailsByPerson(personnelDAO.getPersonnel(loggedInMID).getEmail());
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewPrescriptionRecordsAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.EmailUtil;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.beans.PrescriptionBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.Messages;


/**
 * Handles retrieving beans for viewPrescriptionRecords.jsp
 * 
 * @author laurenhayward
 * 
 */
public class ViewPrescriptionRecordsAction {
	private PatientDAO patientDAO;
	private PersonnelDAO personnelDAO;
	private TransactionDAO transDAO;
	private EmailUtil emailer;
	private long loggedInMID;

	/**
	 * Set up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person viewing prescription records.
	 */
	public ViewPrescriptionRecordsAction(DAOFactory factory, long loggedInMID) {
		this.emailer = new EmailUtil(factory);
		this.patientDAO = factory.getPatientDAO();
		this.personnelDAO = factory.getPersonnelDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
	}
	
	/**
	 * Gets a PatientBean from an MID
	 * 
	 * @param patientID MID of the patient
	 * @return PatientBean for the MID given
	 * @throws iTrustException
	 */
	public PatientBean getPatient(long patientID) throws iTrustException {
		return patientDAO.getPatient(patientID);
	}
	
	/**
	 * Gets the logged in person's representees
	 * 
	 * @return list of PatientBeans holding the representees
	 * @throws iTrustException
	 */
	public List&lt;PatientBean&gt; getRepresentees() throws iTrustException {
		return patientDAO.getRepresented(loggedInMID);
	}
	
	/**
	 * Returns the prescribing HCP for a prescription
	 * 
	 * @param prescription item in question
	 * @return HCP who prescribed the prescription
	 * @throws iTrustException
	 */
	public PersonnelBean getPrescribingDoctor(PrescriptionBean prescription) throws iTrustException {
		return personnelDAO.getPrescribingDoctor(prescription);
	}
	
	/**
	 * Returns all the prescriptions for a given patient
	 * 
	 * @param patientID patient in question
	 * @return list of all the prescriptions for that patient
	 * @throws iTrustException
	 */
	public List&lt;PrescriptionBean&gt; getPrescriptionsForPatient(long patientID) throws iTrustException {
		PatientBean patient = patientDAO.getPatient(patientID);
		if (loggedInMID == patientID) {
			transDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID);
			return patientDAO.getPrescriptions(patientID);
		}
		
		List&lt;String&gt; toList = new ArrayList&lt;String&gt;();
		toList.add(patient.getEmail());
		
		List&lt;PatientBean&gt; representatives = patientDAO.getRepresenting(patientID);
		for(PatientBean representative : representatives) {
			if (loggedInMID == representative.getMID()) {
				transDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID);
				return patientDAO.getPrescriptions(patientID);
			}
			toList.add(representative.getEmail());
		}
		
		List&lt;PersonnelBean&gt; dlhcps = patientDAO.getDeclaredHCPs(patientID);
		for(PersonnelBean dlhcp : dlhcps) {
			if (loggedInMID == dlhcp.getMID()) {
				transDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID);
				return patientDAO.getPrescriptions(patientID);
			}
			List&lt;PersonnelBean&gt; uaps = personnelDAO.getUAPsForHCP(dlhcp.getMID());
			for(PersonnelBean uap : uaps) {
				if (loggedInMID == uap.getMID()) {
					transDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID);
					return patientDAO.getPrescriptions(patientID);
				}
			}
		}
		
		Email email = new Email();
		email.setToList(toList);
		email.setFrom(&quot;noreply@itrust.com&quot;); //$NON-NLS-1$
		email.setSubject(Messages.getString(&quot;ViewPrescriptionRecordsAction.1&quot;)); //$NON-NLS-1$
		email.setBody(Messages.getString(&quot;ViewPrescriptionRecordsAction.2&quot;)); //$NON-NLS-1$
		emailer.sendEmail(email);
		transDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID);
		return patientDAO.getPrescriptions(patientID);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewPrescriptionRenewalNeedsAction</id>
            <content>package edu.ncsu.csc.itrust.action;


import java.util.List;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.Messages;

/*
 * This action returns a list of patients with a special-diagnosis-history who
 * have the logged in HCP as a DHCP and whose medications are going to
 * expire within seven days. 
 */
public class ViewPrescriptionRenewalNeedsAction {
	private PatientDAO patientDAO;
	private TransactionDAO transDAO;
	private long loggedInMID;

	/**
	 * Set up defaults
	 * 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person viewing the prescription renewals.
	 */
	public ViewPrescriptionRenewalNeedsAction(DAOFactory factory, long loggedInMID) {
		this.patientDAO = factory.getPatientDAO();
		this.transDAO = factory.getTransactionDAO();
		this.loggedInMID = loggedInMID;
	}
	
	/**
	 * Uses PatientDAO as a helper class to return a list of patients with a special-diagnosis-history who
	 * have the logged in HCP as a DHCP and whose medications are going to
	 * expire within seven days.
	 * 
	 * @return A list of PatientBean's
	 */
	public List&lt;PatientBean&gt; getRenewalNeedsPatients() {
	
		try {	
			transDAO.logTransaction(TransactionType.VIEW_RENEWAL_NEEDS_PATIENTS, loggedInMID, 
					0L, loggedInMID + Messages.getString(&quot;ViewPrescriptionRenewalNeedsAction.0&quot;)); //$NON-NLS-1$
			return patientDAO.getRenewalNeedsPatients(loggedInMID);
		}
		catch (DBException e) {
			System.out.println(Messages.getString(&quot;ViewPrescriptionRenewalNeedsAction.1&quot;)); //$NON-NLS-1$
			System.out.println(e);
			return null;
		}
	}
	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewReportAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.beans.DiagnosisBean;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.beans.PrescriptionBean;
import edu.ncsu.csc.itrust.beans.ProcedureBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * 
 * Action class for ViewReport.jsp
 *
 */
public class ViewReportAction {
	private PatientDAO patientDAO;
	private PersonnelDAO personnelDAO;

	/**
	 * Set up defaults
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person viewing the report.
	 */
	public ViewReportAction(DAOFactory factory, long loggedInMID) {
		patientDAO = factory.getPatientDAO();
		personnelDAO = factory.getPersonnelDAO();
	}

	/**
	 *  Get diagnosis list for the given patient
	 * @param pid the patient of interest
	 * @return list of diagnoses
	 * @throws iTrustException
	 */
	public List&lt;DiagnosisBean&gt; getDiagnoses(long pid) throws iTrustException {
		return patientDAO.getDiagnoses(pid);
	}

	/**
	 *  Get procedure list for the given patient
	 * @param pid the patient of interest
	 * @return list of procedures
	 * @throws iTrustException
	 */
	public List&lt;ProcedureBean&gt; getProcedures(long pid) throws iTrustException {
		return patientDAO.getProcedures(pid);
	}

	/**
	 *  Get prescription list for the given patient
	 * @param pid the patient of interest
	 * @return list of prescriptions
	 * @throws iTrustException
	 */
	public List&lt;PrescriptionBean&gt; getPrescriptions(long pid) throws iTrustException {
		return patientDAO.getCurrentPrescriptions(pid);
	}

	/**
	 *  Get declared HCPs list for the given patient
	 * @param pid the patient of interest
	 * @return list of declared HCPs
	 * @throws iTrustException
	 */
	public List&lt;PersonnelBean&gt; getDeclaredHCPs(long pid) throws iTrustException {
		return patientDAO.getDeclaredHCPs(pid);
	}
	
	/**
	 * Returns a PersonnelBean when given an MID
	 * @param mid HCP of interest
	 * @return PersonnelBean of the given HCP
	 * @throws iTrustException
	 */
	public PersonnelBean getPersonnel(long mid) throws iTrustException {
		return personnelDAO.getPersonnel(mid);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewSurveyResultAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import edu.ncsu.csc.itrust.beans.SurveyResultBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.SurveyResultDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.validate.SurveySearchValidator;

/**
 * This class is used to handle retrieving survey results from the database.  It also logs the transaction.
 */
public class ViewSurveyResultAction {
	
	private SurveyResultDAO surveyResultDAO;
	private TransactionDAO transDAO;
	private SurveySearchValidator validator;
	long loggedInMID;
	
	/**
	 * Set up defaults.
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person retrieving survey results.
	 */
	public ViewSurveyResultAction(DAOFactory factory, long loggedInMID) {
		transDAO = factory.getTransactionDAO();
		surveyResultDAO = factory.getSurveyResultDAO();
		this.loggedInMID = loggedInMID;
		validator = new SurveySearchValidator();
	}
	
	/**
	 * Retrieves survey results for a whole hospital.
	 * @param bean The SurveyResultBean containing the survey result specs.
	 * @return A java.util.List of Survey Results.
	 * @throws iTrustException
	 * @throws FormValidationException
	 */
	public List&lt;SurveyResultBean&gt; getSurveyResultsForHospital(SurveyResultBean bean) throws iTrustException, FormValidationException {
		
		transDAO.logTransaction(TransactionType.View_HCP_SURVEY_RESULTS, loggedInMID, 0, &quot;searched results by HCP hospital ID&quot;);	
		
		return surveyResultDAO.getSurveyResultsForHospital(bean.getHCPhospital(), bean.getHCPspecialty());

		
	}
	
	/**
	 * Retrieves survey results for a given zip code.
	 * @param bean The SurveyResultBean containing the survey result specs.
	 * @return A java.util.List of Survey Results.
	 * @throws iTrustException
	 * @throws FormValidationException
	 */
	public List&lt;SurveyResultBean&gt; getSurveyResultsForZip(SurveyResultBean bean) throws iTrustException, FormValidationException {
		
		validator.validate(bean);
		transDAO.logTransaction(TransactionType.View_HCP_SURVEY_RESULTS, loggedInMID, 0, &quot;searched results by HCP zip code&quot;);
		
		return surveyResultDAO.getSurveyResultsForZip(bean.getHCPzip(), bean.getHCPspecialty());

	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ViewVisitedHCPsAction</id>
            <content>package edu.ncsu.csc.itrust.action;

import java.util.List;
import java.util.ArrayList;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.beans.HCPVisitBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Action class for ViewVisitedHCPs.jsp
 *
 */
public class ViewVisitedHCPsAction {

	private long patientMID;
	private PersonnelDAO docDAO;
	private OfficeVisitDAO visitDAO;
	private PatientDAO patientDAO;
	private ArrayList&lt;HCPVisitBean&gt; visits;
	private DeclareHCPAction declareAction; 
	private ArrayList&lt;PersonnelBean&gt; filterList;
	
	/**
	 * Set up defaults 
	 * @param factory The DAOFactory used to create the DAOs used in this action.
	 * @param loggedInMID The MID of the person viewing the visited HCPs.
	 */
	public ViewVisitedHCPsAction(DAOFactory factory, long loggedInMID) {
		patientMID = loggedInMID;
		docDAO = factory.getPersonnelDAO();
		visitDAO = factory.getOfficeVisitDAO();
		patientDAO = factory.getPatientDAO();
		
		visits = new ArrayList&lt;HCPVisitBean&gt;();
		declareAction = new DeclareHCPAction(factory, loggedInMID);
		filterList = new ArrayList&lt;PersonnelBean&gt;();
	}
	
	/**
	 * Adds all the office visits to a global array
	 * 
	 * @throws iTrustException
	 */
	private void processOfficeVisits() throws iTrustException {
		
		try {
			List&lt;OfficeVisitBean&gt; ovlist = visitDAO.getAllOfficeVisits(patientMID);
			HCPVisitBean visitBean;
			List&lt;PersonnelBean&gt; dhcps = patientDAO.getDeclaredHCPs(patientMID);
			boolean tmp;
			PersonnelBean pb;
			ArrayList&lt;PersonnelBean&gt; removeIDs = new ArrayList&lt;PersonnelBean&gt;();
			
			for (OfficeVisitBean ov: ovlist) {
				visitBean = new HCPVisitBean();
				pb = docDAO.getPersonnel(ov.getHcpID());
				
				visitBean.setHCPMID(ov.getHcpID());
				visitBean.setHCPName(pb.getFullName());
				visitBean.setOVDate(ov.getVisitDateStr());
				visitBean.setHCPSpecialty(pb.getSpecialty());
				visitBean.setHCPAddr(pb.getStreetAddress1() +&quot; &quot;+ pb.getStreetAddress2() +&quot; &quot;+ pb.getCity() +&quot;, &quot;+ pb.getState() +&quot; &quot;+ pb.getZip());
								
				if (true == (tmp = patientDAO.checkDeclaredHCP(patientMID, ov.getHcpID()))) {
					visitBean.setDesignated(tmp);
					if (!dhcps.isEmpty()) {
						for (PersonnelBean hcp : dhcps) {
							if (hcp.getMID() == ov.getHcpID()) {
								removeIDs.add(hcp);
							}
						}
						if (!removeIDs.isEmpty()) {
							for (PersonnelBean pbean: removeIDs) {
								dhcps.remove(pbean);
							}
						}
					}
				}
				
				visits.add(visitBean);
				
			}
			
			for (PersonnelBean hcp : dhcps) {
				visitBean = new HCPVisitBean();
				visitBean.setHCPMID(hcp.getMID());
				visitBean.setHCPName(hcp.getFullName());
				visitBean.setOVDate(&quot;&quot;);
				visitBean.setHCPSpecialty(hcp.getSpecialty());
				visitBean.setHCPAddr(hcp.getStreetAddress1() +&quot; &quot;+ hcp.getStreetAddress2() +&quot; &quot;+ hcp.getCity() +&quot;, &quot;+ hcp.getState() +&quot; &quot;+ hcp.getZip());
				visitBean.setDesignated(true);
				visits.add(visitBean);
			}
			
			
		}
		catch (DBException dbe) {
			throw new iTrustException(dbe.getMessage());
		}
	}
	
	/**
	 * Returns a list of all the visited HCPs
	 * @return list of all the visited HCPs
	 */
	
	public List&lt;HCPVisitBean&gt; getVisitedHCPs() {
		
		try {
			processOfficeVisits();
		
			for(int i = 0; i&lt;visits.size(); i++){
				for(int j = i+1; j&lt;visits.size(); j++){
					if(visits.get(i).getHCPMID()==visits.get(j).getHCPMID()){
						visits.remove(visits.get(j));
						j--;
					}
				}
			}
		}
		catch (iTrustException ie) {
			
		}
			
		return visits;
	}
	
	/**
	 * Set a given HCP as undeclared
	 * 
	 * @param name HCP to undeclare
	 * @return An empty string.
	 * @throws iTrustException
	 */
	public String undeclareHCP(String name) throws iTrustException {

		HCPVisitBean remove = null;
		
		for (HCPVisitBean visit: visits) {
			if (0 == visit.getHCPName().toLowerCase().compareTo(name.toLowerCase())) {
				Long mid = Long.valueOf(visit.getHCPMID());

				//if (patientDAO.checkDeclaredHCP(patientMID, visit.getHCPMID())) {
					declareAction.undeclareHCP(mid.toString());
				//}
				visit.setDesignated(false);
				
				if (0 == visit.getOVDate().compareTo(&quot;&quot;)) {
					remove = visit;
				}
			}
		}
		
		if (null != remove) {
			visits.remove(remove);
		}
				
		return &quot;&quot;;
	}
	
	/**
	 * Set a given HCP as declared
	 * 
	 * @param name HCP to declare
	 * @return An empty string.
	 * @throws iTrustException
	 */
	public String declareHCP(String name) throws iTrustException {
		boolean match = false;
		for (HCPVisitBean visit: visits) {
			if (0 == visit.getHCPName().toLowerCase().compareTo(name.toLowerCase())) {
				match = true;
				Long mid = Long.valueOf(visit.getHCPMID());
				if (!patientDAO.checkDeclaredHCP(patientMID, visit.getHCPMID())) {
					declareAction.declareHCP(mid.toString());
				}
				visit.setDesignated(true);
			}
		}
		
		if (!match) {
				List&lt;PersonnelBean&gt; doclist = docDAO.getAllPersonnel();
				for (PersonnelBean ele: doclist) {
					if (0 == name.compareTo(ele.getFullName())) {
						HCPVisitBean visitBean;
						visitBean = new HCPVisitBean();
						visitBean.setHCPMID(ele.getMID());
						visitBean.setHCPName(ele.getFullName());
						visitBean.setOVDate(&quot;&quot;);
						visitBean.setHCPSpecialty(ele.getSpecialty());
						visitBean.setHCPAddr(ele.getStreetAddress1() +&quot; &quot;+ ele.getStreetAddress2() +&quot; &quot;+ ele.getCity() +&quot;, &quot;+ ele.getState() +&quot; &quot;+ ele.getZip());
						
						visitBean.setDesignated(true);
				
						Long mid = Long.valueOf(ele.getMID());
						if (!patientDAO.checkDeclaredHCP(patientMID, mid)) {
							declareAction.declareHCP(mid.toString());
							visits.add(visitBean);
						}
					}
				}
			
		}
		return &quot;&quot;;
	}
	
	/**
	 * Check to see if a given HCP is declared
	 * @param mid HCP to check
	 * @return true if the HCP is declared, otherwise false
	 */
	public boolean checkDeclared(long mid) {
		
		try {
			return patientDAO.checkDeclaredHCP(patientMID, mid);
		} catch (DBException dbe) {
			return false;
		}
	}
	
	/**
	 * Filter the list of HCPs by last name, specialty, or zip code. 
	 * @param doc sort by last name
	 * @param specialty sort by specialty
	 * @param zip sort by zip
	 * @return sorted list of HCPs
	 */
	public List&lt;PersonnelBean&gt; filterHCPList(String doc, String specialty, String zip) {
		List&lt;PersonnelBean&gt; doclist;
			
		try {
			doclist = docDAO.getAllPersonnel();
			for (PersonnelBean ele: doclist) {
				if (ele.getLastName().toLowerCase().contains(doc.toLowerCase())) {
					if (null != specialty &amp;&amp; !specialty.equals(&quot;&quot;)) {
						if (0 == specialty.toLowerCase().compareTo(ele.getSpecialty().toLowerCase())) {
							if (null != zip &amp;&amp; !zip.equals(&quot;&quot;)) {
								if (ele.getZip().contains(zip.substring(0, 2))) {
									filterList.add(ele);
								}
							}
							else {	
								filterList.add(ele);
							}
						}
					}
					else if (null != zip &amp;&amp; !zip.equals(&quot;&quot;)) {
						if (ele.getZip().contains(zip.substring(0, 2))) {
							filterList.add(ele);
						}
					}
					else {
						filterList.add(ele);
					}
				}
			}
		}
		catch (DBException dbe) {
			
		}
		return filterList;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_OfficeVisitBaseAction</id>
            <content>package edu.ncsu.csc.itrust.action.base;

import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * An abstract class which contains functionalities common among all actions relating to inserting and editing
 * office visits. Because all office visits are with a certain patient, OfficeVisitBaseAction extends
 * PatientBaseAction.
 * 
 * Use this class whenever you have a page which not only requires a patient MID, but an office visit ID. Pass
 * those IDs to the constructor, and an exception will be thrown if they are not valid IDs (which should kick
 * the user out to the home page).
 * 
 * The concrete methods created by this class allow for its association with the unique identifier of a given
 * office visit. These identifiers can also be verified for their correctness and existence.
 * 
 * Very similar to {@link PatientBaseAction} and {@link PersonnelBaseAction}
 */
abstract public class OfficeVisitBaseAction extends PatientBaseAction {

	/**
	 * A database access object for dealing with office visits.
	 */
	private OfficeVisitDAO ovDAO;

	/**
	 * The unique identifier of the office visit this action is associated with.
	 */
	protected long ovID;

	/**
	 * The default constructor.
	 * 
	 * @param factory
	 *            A database access object factory for supplying a runtime context.
	 * @param pidString
	 *            The patient's MID as a String, to be passed to the super constructor (for PatientBaseAction)
	 * @param ovIDString
	 *            The unique identifier of the office visit as a String.
	 * @throws iTrustException
	 *             If any of the supplied parameters is incorrect or there is a DB problem.
	 */
	public OfficeVisitBaseAction(DAOFactory factory, String pidString, String ovIDString)
			throws iTrustException {
		super(factory, pidString);
		this.ovDAO = factory.getOfficeVisitDAO();
		this.ovID = checkOfficeVisitID(ovIDString);
	}

	/**
	 * Asserts whether this unique office visit identifier both exists and is associated with the patient in
	 * the database.
	 * 
	 * @param input
	 *            The presumed identifier as a String.
	 * @return The same identifier as a long of the existing office visit.
	 * @throws iTrustException
	 *             If the visit does not exist or if there is a DB problem.
	 */
	private long checkOfficeVisitID(String input) throws iTrustException {
		try {
			encode(input);
			long ovID = Long.valueOf(input);

			if (ovDAO.checkOfficeVisitExists(ovID, pid))
				return ovID;
			else
				throw new iTrustException(&quot;Office Visit &quot; + ovID + &quot; with Patient MID &quot; + pid
						+ &quot; does not exist&quot;);
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;Office Visit ID is not a number: &quot; + e.getMessage());
		}
	}

	/**
	 * For obtaining the unique identifier of the office visit this action is associated with.
	 * 
	 * @return A long of the identifier.
	 */
	public long getOvID() {
		return ovID;
	}

	/**
	 * Converts all characters of the input string to their HTML special characters equivalent representation.
	 * Explicitly, the less than symbol becomes lt, the greater than symbol becomes gt and a newline feed
	 * becomes br.
	 * 
	 * @param input
	 *            The string to encode.
	 * @return The encoded string.
	 */
	public String encode(String input) {
		String str = input.replaceAll(&quot;&lt;&quot;, &quot;&amp;lt;&quot;);
		str = str.replaceAll(&quot;&gt;&quot;, &quot;&amp;gt;&quot;);
		str = str.replaceAll(&quot;\n&quot;, &quot;&lt;br /&gt;&quot;);
		return str;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PatientBaseAction</id>
            <content>package edu.ncsu.csc.itrust.action.base;

import edu.ncsu.csc.itrust.HtmlEncoder;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * An abstract class for dealing with actions that require an associated patient. The concrete functionality
 * provided by this class allows for asserting the correctness and existence of patients' MIDs.
 * 
 * Use this class whenever your JSP requires a patient ID when it loads (e.g. editPatient.jsp). The patient
 * string is passed to the constructor of this class and is checked for both format and existence. If the
 * patient ID is wrong in any way, an exception is thrown, resulting in the user getting kicked out to the
 * home page.
 * 
 * Very similar to {@link PersonnelBaseAction} and {@link OfficeVisitBaseAction}
 * 
 * Subclasses need not rewrite this functionality, and they are not held to any strict contract to extend this
 * class.
 */
public class PatientBaseAction {

	/**
	 * The database access object factory to associate this with a runtime context.
	 */
	private DAOFactory factory;

	/**
	 * Stores the MID of the patient associated with this action.
	 */
	protected long pid;

	/**
	 * The default constructor.
	 * 
	 * @param factory
	 *            A factory to create a database access object.
	 * @param pidString
	 *            The patient's ID to associate with this action.
	 * @throws iTrustException
	 *             If the patient's ID is incorrect or there is a DB problem.
	 */
	public PatientBaseAction(DAOFactory factory, String pidString) throws iTrustException {
		this.factory = factory;
		this.pid = checkPatientID(pidString);
	}

	/**
	 * Asserts whether the input is a valid, existing patient's MID.
	 * 
	 * @param input
	 *            The presumed MID
	 * @return The existing patient's ID as a long.
	 * @throws iTrustException
	 *             If the patient does not exist or there is a DB Problem.
	 */
	private long checkPatientID(String input) throws iTrustException {
		try {
			long pid = Long.valueOf(input);
			if (factory.getPatientDAO().checkPatientExists(pid))
				return pid;
			else
				throw new iTrustException(&quot;Patient does not exist&quot;);
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;Patient ID is not a number: &quot; + HtmlEncoder.encode(input));
		}
	}

	/**
	 * Retrieves the identifier of the patient as a long.
	 * 
	 * @return The patient's MID.
	 */
	public long getPid() {
		return pid;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PersonnelBaseAction</id>
            <content>package edu.ncsu.csc.itrust.action.base;

import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * An abstract class for dealing with actions that require an associated personnel. The concrete functionality
 * provided by this class allows for asserting the correctness and existence of personnel' MIDs.
 * 
 * Use this class whenever your JSP requires a personnel ID when it loads (e.g. editPatient.jsp). The patient
 * string is passed to the constructor of this class and is checked for both format and existence. If the
 * patient ID is wrong in any way, an exception is thrown, resulting in the user getting kicked out to the
 * home page.
 * 
 * Subclasses need not rewrite this functionality, and they are not held to any strict contract to extend this
 * class.
 * 
 * Very similar to {@link PatientBaseAction}
 */
public class PersonnelBaseAction {

	/**
	 * The database access object factory to associate this with a runtime context.
	 */
	private DAOFactory factory;

	/**
	 * Stores the MID of the personnel associated with this action.
	 */
	protected long pid;

	/**
	 * The default constructor.
	 * 
	 * @param factory
	 *            A factory to create a database access object.
	 * @param pidString
	 *            The personnel's ID to associate with this action.
	 * @throws iTrustException
	 *             If the personnel's ID is incorrect or there is a DB problem.
	 */
	public PersonnelBaseAction(DAOFactory factory, String pidString) throws iTrustException {
		this.factory = factory;
		this.pid = checkPersonnelID(pidString);
	}

	/**
	 * Asserts whether the input is a valid, existing personnel's MID.
	 * 
	 * @param input
	 *            The presumed MID
	 * @return The existing personnel's ID as a long.
	 * @throws iTrustException
	 *             If the personnel does not exist or there is a DB Problem.
	 */
	private long checkPersonnelID(String input) throws iTrustException {
		try {
			long pid = Long.valueOf(input);
			if (factory.getPersonnelDAO().checkPersonnelExists(pid))
				return pid;
			else
				throw new iTrustException(&quot;Personnel does not exist&quot;);
		} catch (NumberFormatException e) {
			throw new iTrustException(&quot;Personnel ID is not a number: &quot; + e.getMessage());
		}
	}

	/**
	 * Retrieves the identifier of the patient as a long.
	 * 
	 * @return The patient's MID.
	 */
	public long getPid() {
		return pid;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AdverseEventsData</id>
            <content>package edu.ncsu.csc.itrust.charts;

import java.io.Serializable;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.jfree.data.category.CategoryDataset;
import org.jfree.data.category.DefaultCategoryDataset;

import de.laures.cewolf.DatasetProduceException;
import de.laures.cewolf.DatasetProducer;
import de.laures.cewolf.links.CategoryItemLinkGenerator;
import de.laures.cewolf.tooltips.CategoryToolTipGenerator;
import edu.ncsu.csc.itrust.beans.AdverseEventBean;

/**
 * This class handles the data for charting in CeWolf/JFreeChart. This class implements DatasetProducer,
 * CategoryToolTipGenerator, CategoryItemLinkGenerator, and Serializable.
 * 
 * @author Jason
 *
 */
public class AdverseEventsData implements DatasetProducer, CategoryToolTipGenerator, CategoryItemLinkGenerator, Serializable {
	
	/**
	 * The generated serializable ID.
	 */
	private static final long serialVersionUID = 6145689621506271656L;

	// Hardcoded months array to make implementation simpler for Adverse Event charts
    private final String[] months = {&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;Aug&quot;,&quot;Sept&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;};
   
    // Initialize the values for each month to 0
    private int[] values = {0,0,0,0,0,0,0,0,0,0,0,0};
    
    // This will be the list of adverse events
    private List&lt;AdverseEventBean&gt; adverseEvents = new LinkedList&lt;AdverseEventBean&gt;();
    
    // This will be the name of the prescription or immunization under analysis
    private String codeName;
    
    /**
     * Called from the JSP page to initialize the list of Adverse Events needed to
     * produce the desired chart.
     * 
     * @param adEvents
     * @param name
     */
    public void setAdverseEventsList(List&lt;AdverseEventBean&gt; adEvents, String name)
    {
    	adverseEvents = adEvents;
    	this.codeName = name;
    }
    
    /**
     * This method parses the list of Adverse Event Beans to initialize the chart dataset.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
	public Object produceDataset(Map params) throws DatasetProduceException {
    	// The DefaultCategoryDataset is used for bar charts.
    	// This dataset class may change based on the type of chart you wish to produce.
        DefaultCategoryDataset dataset = new DefaultCategoryDataset(){
			/**
			 * The generated serializable ID.
			 */
			private static final long serialVersionUID = -8238489914590553747L;

			/**
			 * @see java.lang.Object#finalize()
			 */
			protected void finalize() throws Throwable {
				super.finalize();
			}
        };
        
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);
        // For each Adverse Event in the list,
        // parse the string repreentation of the report date
        // to a Java Date object. Then, get the month of the
        // Date object and increment the value count for that month.
        for(AdverseEventBean event : adverseEvents)
        {
        	Calendar cal = Calendar.getInstance();
        	try {
				cal.setTime(sdf.parse(event.getDate()));
			} catch (ParseException e) {
				e.printStackTrace();
				throw new DatasetProduceException(e.getMessage());
			}
        	int monthOfReport = cal.get(Calendar.MONTH);
        	values[monthOfReport]++;
        }
        
        // For each month, add the monthly values to the dataset for
        // producing the chart.
        for(int i = 0; i &lt; 12; i++)
        {
        	// values[i] represents the number of adverse events for month i
        	// codeName represents the given prescription/immunization being analyzed
        	// month[i] is the static array of month names, to be used as labels on the chart
        	dataset.addValue(values[i],codeName,months[i]);
        }
          
        return dataset;
    }

    /**
     * This producer's data is invalidated after 5 seconds. By this method the
     * producer can influence Cewolf's caching behaviour the way it wants to.
     */
	@SuppressWarnings(&quot;unchecked&quot;)
	public boolean hasExpired(Map params, Date since) {		
		return (System.currentTimeMillis() - since.getTime())  &gt; 5000;
	}

	/**
	 * Returns a unique ID for this DatasetProducer
	 */
	public String getProducerId() {
		return &quot;AdverseEventsData DatasetProducer&quot;;
	}

    /**
     * Returns a link target for a special data item.
     */
    public String generateLink(Object data, int series, Object category) {
        return months[series];
    }
    
	/**
	 * @see java.lang.Object#finalize()
	 */
	protected void finalize() throws Throwable {
		super.finalize();
	}

	/**
	 * @see org.jfree.chart.tooltips.CategoryToolTipGenerator#generateToolTip(CategoryDataset, int, int)
	 */
	public String generateToolTip(CategoryDataset arg0, int series, int arg2) {
		return months[series];
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_DBException</id>
            <content>package edu.ncsu.csc.itrust.exception;

import java.sql.SQLException;

/**
 * The reasoning behind this wrapper exception is security. When an SQL Exception gets thrown all the way back
 * to the JSP, we begin to reveal details about our database (even knowing that it's MySQL is bad!) So, we
 * make a wrapper exception with a vague description, but we also keep track of the SQL Exception for
 * debugging and testing purposes.
 * 
 * @author Andy
 * 
 */
public class DBException extends iTrustException {
	private static final long serialVersionUID = -6554118510590118376L;
	private SQLException sqlException = null;

	public DBException(SQLException e) {
		super(&quot;A database exception has occurred. Please see the log in the console for stacktrace&quot;);
		this.sqlException = e;
	}

	/**
	 * @return The SQL Exception that was responsible for this error.
	 */
	public SQLException getSQLException() {
		return sqlException;
	}

	@Override
	public String getExtendedMessage() {
		if (sqlException != null)
			return sqlException.getMessage();
		else
			return super.getExtendedMessage();
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ErrorList</id>
            <content>package edu.ncsu.csc.itrust.exception;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Used by the validators to create a list of error messages.
 * 
 * @author Andy
 * 
 */
public class ErrorList implements Iterable&lt;String&gt; {
	private List&lt;String&gt; errorList;

	public ErrorList() {
		errorList = new ArrayList&lt;String&gt;();
	}

	/**
	 * Adds a message to the list if it's not a Java null or empty string.
	 * 
	 * @param errorMessage
	 */
	public void addIfNotNull(String errorMessage) {
		if (errorMessage != null &amp;&amp; !&quot;&quot;.equals(errorMessage))
			errorList.add(errorMessage);
	}

	/**
	 * Returns the list of error messages
	 * 
	 * @return
	 */
	public List&lt;String&gt; getMessageList() {
		return errorList;
	}

	/**
	 * Returns true if the list has any errors
	 * 
	 * @return
	 */
	public boolean hasErrors() {
		return errorList.size() != 0;
	}

	@Override
	public String toString() {
		return errorList.toString();
	}

	public Iterator&lt;String&gt; iterator() {
		return errorList.iterator();
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_FormValidationException</id>
            <content>package edu.ncsu.csc.itrust.exception;

import java.io.IOException;
import java.util.List;
import javax.servlet.jsp.JspWriter;

/**
 * This exception is used specifically for when an action involves the correct
 * and proper submission of a web form.  Form Validation is handled by a series of
 * other classes, but when form validation is incorrect or incomplete, this exception
 * is thrown. 
 */
public class FormValidationException extends Exception {
	private static final long serialVersionUID = 1L;
	private ErrorList errorList;

	/**
	 * Constructor with error messages passed as a list of parameters to the method.
	 * @param errorMessages The list of error messages to be returned in the special form validation box.
	 */
	public FormValidationException(String... errorMessages) {
		errorList = new ErrorList();
		for (String msg : errorMessages) {
			errorList.addIfNotNull(msg);
		}
	}

	/**
	 * Constructor with error messages as a special ErrorList data type.
	 * @param errorList An ErrorList object which contains the list of error messages.
	 */
	public FormValidationException(ErrorList errorList) {
		this.errorList = errorList;
	}

	/**
	 * Returns the error list as a java.util.List of Strings.
	 * @return The error list
	 */
	public List&lt;String&gt; getErrorList() {
		return errorList.getMessageList();
	}

	/**
	 * The error message will be displayed at the top of the iTrust page as in other iTrust Exceptions.
	 */
	@Override
	public String getMessage() {
		return &quot;This form has not been validated correctly. The following field are not properly filled in: &quot;
				+ errorList.toString();
	}

	/**
	 * The special formatting for error messages is then kept in one place.
	 * @param out The output writer (in this case a JSPWriter) where the formatted list will go.
	 * @throws IOException If the writer is incorrect.
	 */
	public void printHTML(JspWriter out) throws IOException {
		out.print(&quot;&lt;h2&gt;Information not valid&lt;/h2&gt;&lt;div class=\&quot;errorList\&quot;&gt;&quot;);
		for (String errorMessage : errorList) {
			out.print(errorMessage + &quot;&lt;br /&gt;&quot;);
		}
		out.print(&quot;&lt;/div&gt;&quot;);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_NoHealthRecordsException</id>
            <content>package edu.ncsu.csc.itrust.exception;

/**
 * This error message is thrown when checking for health risk indicators and the
 * patient has had no health records entered.  It is a separate case than an iTrustException
 * because the error handling is slightly different. 
 */
public class NoHealthRecordsException extends iTrustException {

	public static final String MESSAGE = &quot;The patient did not have any health records recorded. &quot;
			+ &quot;No risks can be calculated if no records exist&quot;;

	private static final long serialVersionUID = 7082694071460355325L;

	/**
	 * The default constructor, which just passes a pre-specified message to an iTrustException.
	 */
	public NoHealthRecordsException() {
		super(MESSAGE);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_iTrustException</id>
            <content>package edu.ncsu.csc.itrust.exception;

/**
 * A specialized exception class for displaying iTrust error messages.
 * This exception is handled by the default iTrust exception handler.
 */
public class iTrustException extends Exception {
	private static final long serialVersionUID = 1L;
	String message = null;

	/**
	 * The typical constructor.
	 * @param message A message to be displayed to the screen.
	 */
	public iTrustException(String message) {
		this.message = message;
	}

	/**
	 * For messages which are displayed to the user. Usually, this is a very general message for security
	 * reasons.
	 */
	@Override
	public String getMessage() {
		if (message == null)
			return &quot;An error has occurred. Please see log for details.&quot;;
		return message;
	}

	/**
	 * For exceptions which show a lot of technical detail, usually delegated to a subclass
	 * 
	 * @return
	 */
	public String getExtendedMessage() {
		return &quot;No extended information.&quot;;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_DAOFactory</id>
            <content>package edu.ncsu.csc.itrust.dao;

import java.sql.Connection;
import java.sql.SQLException;
import edu.ncsu.csc.itrust.dao.mysql.AccessDAO;
import edu.ncsu.csc.itrust.dao.mysql.AdverseEventDAO;
import edu.ncsu.csc.itrust.dao.mysql.AllergyDAO;
import edu.ncsu.csc.itrust.dao.mysql.ApptDAO;
import edu.ncsu.csc.itrust.dao.mysql.ApptTypeDAO;
import edu.ncsu.csc.itrust.dao.mysql.AuthDAO;
import edu.ncsu.csc.itrust.dao.mysql.CPTCodesDAO;
import edu.ncsu.csc.itrust.dao.mysql.DrugInteractionDAO;
import edu.ncsu.csc.itrust.dao.mysql.FakeEmailDAO;
import edu.ncsu.csc.itrust.dao.mysql.FamilyDAO;
import edu.ncsu.csc.itrust.dao.mysql.HealthRecordsDAO;
import edu.ncsu.csc.itrust.dao.mysql.HospitalsDAO;
import edu.ncsu.csc.itrust.dao.mysql.ICDCodesDAO;
import edu.ncsu.csc.itrust.dao.mysql.LOINCDAO;
import edu.ncsu.csc.itrust.dao.mysql.LabProcedureDAO;
import edu.ncsu.csc.itrust.dao.mysql.MessageDAO;
import edu.ncsu.csc.itrust.dao.mysql.NDCodesDAO;
import edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;
import edu.ncsu.csc.itrust.dao.mysql.PatientDAO;
import edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;
import edu.ncsu.csc.itrust.dao.mysql.ReferralDAO;
import edu.ncsu.csc.itrust.dao.mysql.RemoteMonitoringDAO;
import edu.ncsu.csc.itrust.dao.mysql.ReportRequestDAO;
import edu.ncsu.csc.itrust.dao.mysql.RiskDAO;
import edu.ncsu.csc.itrust.dao.mysql.SurveyDAO;
import edu.ncsu.csc.itrust.dao.mysql.SurveyResultDAO;
import edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;
import edu.ncsu.csc.itrust.dao.mysql.VisitRemindersDAO;
import edu.ncsu.csc.itrust.testutils.EvilDAOFactory;
import edu.ncsu.csc.itrust.testutils.TestDAOFactory;

/**
 * The central mediator for all Database Access Objects. The production instance uses the database connection pool
 * provided by Tomcat (so use the production instance when doing stuff from JSPs in the &quot;real code&quot;). Both the
 * production and the test instance parses the context.xml file to get the JDBC connection.
 * 
 * Also, @see {@link EvilDAOFactory} and @see {@link TestDAOFactory}.
 * 
 * Any DAO that is added to the system should be added in this class, in the same way that all other DAOs are.
 * 
 * @author Andy
 * 
 */
public class DAOFactory {
	private static DAOFactory productionInstance = null;
	private IConnectionDriver driver;

	/**
	 * 
	 * @return A production instance of the DAOFactory, to be used in deployment (by Tomcat).
	 */
	public static DAOFactory getProductionInstance() {
		if (productionInstance == null)
			productionInstance = new DAOFactory();
		return productionInstance;
	}

	protected DAOFactory() {
		this.driver = new ProductionConnectionDriver();
	}

	public Connection getConnection() throws SQLException {
		return driver.getConnection();
	}

	public AccessDAO getAccessDAO() {
		return new AccessDAO(this);
	}

	public AllergyDAO getAllergyDAO() {
		return new AllergyDAO(this);
	}
	
	public ApptDAO getApptDAO() {
		return new ApptDAO(this);
	}
	
	public ApptTypeDAO getApptTypeDAO() {
		return new ApptTypeDAO(this);
	}

	public AuthDAO getAuthDAO() {
		return new AuthDAO(this);
	}

	public CPTCodesDAO getCPTCodesDAO() {
		return new CPTCodesDAO(this);
	}
	
	public DrugInteractionDAO getDrugInteractionDAO() {
		return new DrugInteractionDAO(this);
	}

	public FamilyDAO getFamilyDAO() {
		return new FamilyDAO(this);
	}

	public HealthRecordsDAO getHealthRecordsDAO() {
		return new HealthRecordsDAO(this);
	}

	public HospitalsDAO getHospitalsDAO() {
		return new HospitalsDAO(this);
	}

	public ICDCodesDAO getICDCodesDAO() {
		return new ICDCodesDAO(this);
	}

	public NDCodesDAO getNDCodesDAO() {
		return new NDCodesDAO(this);
	}

	public OfficeVisitDAO getOfficeVisitDAO() {
		return new OfficeVisitDAO(this);
	}

	public PatientDAO getPatientDAO() {
		return new PatientDAO(this);
	}

	public PersonnelDAO getPersonnelDAO() {
		return new PersonnelDAO(this);
	}

	public ReferralDAO getReferralDAO() {
		return new ReferralDAO(this);
	}
	
	public RiskDAO getRiskDAO() {
		return new RiskDAO(this);
	}

	public TransactionDAO getTransactionDAO() {
		return new TransactionDAO(this);
	}

	public VisitRemindersDAO getVisitRemindersDAO() {
		return new VisitRemindersDAO(this);
	}

	public FakeEmailDAO getFakeEmailDAO() {
		return new FakeEmailDAO(this);
	}

	public ReportRequestDAO getReportRequestDAO() {
		return new ReportRequestDAO(this);
	}

	public SurveyDAO getSurveyDAO() {
		return new SurveyDAO(this);
	}

	public LabProcedureDAO getLabProcedureDAO() {
		return new LabProcedureDAO(this);
	}

	public LOINCDAO getLOINCDAO() {
		return new LOINCDAO(this);
	}

	public SurveyResultDAO getSurveyResultDAO() {
		return new SurveyResultDAO(this);
	}
	
	public MessageDAO getMessageDAO() {
		return new MessageDAO(this);
	}
	
	public AdverseEventDAO getAdverseEventDAO() {
		return new AdverseEventDAO(this);
	}
	
	public RemoteMonitoringDAO getRemoteMonitoringDAO() {
		return new RemoteMonitoringDAO(this);
	}
	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_IConnectionDriver</id>
            <content>package edu.ncsu.csc.itrust.dao;

import java.sql.Connection;
import java.sql.SQLException;

/**
 * Used by DAOFactory to abstract away different ways of getting our JDBC connection
 * 
 * @author Andy
 * 
 */
public interface IConnectionDriver {
	public Connection getConnection() throws SQLException;
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ProductionConnectionDriver</id>
            <content>package edu.ncsu.csc.itrust.dao;

import java.sql.Connection;
import java.sql.SQLException;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;

/**
 * Produces the JDBC connection from Tomcat's JDBC connection pool (defined in context.xml). Produces and
 * exception when running the unit tests because they're not being run through Tomcat.
 * 
 * @author Andy
 * 
 */
public class ProductionConnectionDriver implements IConnectionDriver {
	public Connection getConnection() throws SQLException {
		try {
			return ((DataSource) (((Context) new InitialContext().lookup(&quot;java:comp/env&quot;)))
					.lookup(&quot;jdbc/itrust&quot;)).getConnection();
		} catch (NamingException e) {
			throw new SQLException((&quot;Context Lookup Naming Exception: &quot; + e.getMessage()));
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AccessDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * AccessDAO is for all queries related to authorization.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * 
 * @author Andy
 * 
 */
public class AccessDAO {
	private DAOFactory factory;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public AccessDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Returns the number of minutes it would take for a session to time out. This is done by effectively
	 * using the database table as a hash table. If a row in GlobalVariables does not exist, one is inserted
	 * with the default value '20'.
	 * 
	 * @return An int for the number of minutes.
	 * @throws DBException
	 */
	public int getSessionTimeoutMins() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT Value FROM GlobalVariables WHERE Name='Timeout'&quot;);
			ResultSet rs = ps.executeQuery();
			if (rs.next())
				return rs.getInt(&quot;Value&quot;);
			else {
				insertDefaultTimeout(conn, 20);
				return 20;
			}
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Sets the number of minutes it would take for a session to timeout.
	 * 
	 * @param mins An int specifying the number of minutes
	 * @throws DBException
	 */
	public void setSessionTimeoutMins(int mins) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE GlobalVariables SET Value=? WHERE Name='Timeout'&quot;);
			ps.setInt(1, mins);
			int numUpdated = ps.executeUpdate();
			if (numUpdated == 0) // no value in the table
				insertDefaultTimeout(conn, mins);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	private void insertDefaultTimeout(Connection conn, int mins) throws SQLException {
		PreparedStatement ps = null;
		ps = conn.prepareStatement(&quot;INSERT INTO GlobalVariables(Name,Value) VALUES ('Timeout', ?)&quot;);
		ps.setInt(1, mins);
		ps.executeUpdate();
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AdverseEventDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.AdverseEventBean;
import edu.ncsu.csc.itrust.beans.loaders.AdverseEventBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import java.sql.Timestamp;

/**
 * Used for the logging mechanism.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class AdverseEventDAO {
	private DAOFactory factory;
	private AdverseEventBeanLoader aeLoader;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public AdverseEventDAO(DAOFactory factory) {
		this.factory = factory;
		this.aeLoader = new AdverseEventBeanLoader();
	}

	/**
	 * Gets all the adverse event reports for a certain user MID.
	 * @param mid The MID of the user to be looked up.
	 * @return A java.util.List of AdverseEventBeans.
	 * @throws SQLException
	 * @throws DBException 
	 */
public List&lt;AdverseEventBean&gt; getReportsFor(long mid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;	
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM AdverseEvents WHERE PatientMID = ?&quot;);
			ps.setLong(1, mid);
			ResultSet rs = ps.executeQuery();

			List&lt;AdverseEventBean&gt; aeList = this.aeLoader.loadList(rs);
			return aeList;
		} catch(SQLException e){
			e.printStackTrace();
			throw new DBException(e);
		} finally{
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Adds a message to the database.
	 * @param mBean A bean representing the message to be added.
	 * @throws SQLException
	 * @throws DBException 
	 */
	public void addReport(AdverseEventBean aeBean, long hcpmid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try{
			conn = factory.getConnection();
			ps = conn.prepareStatement(
					&quot;INSERT INTO AdverseEvents (PatientMID, PresImmu, Code, Comment, Prescriber, Status) &quot;
					  + &quot;VALUES (?, ?, ?, ?, ?, ?)&quot;);
			ps.setString(1, aeBean.getMID());
			ps.setString(2, aeBean.getDrug());
			ps.setString(3, aeBean.getCode());
			ps.setString(4, aeBean.getDescription());
			ps.setLong(5, hcpmid);
			ps.setString(6,&quot;Active&quot;);
			ps.executeUpdate();
		} catch(SQLException e){
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	public long getHCPMID(int id) throws DBException{
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM AdverseEvents WHERE id=?&quot;);
			ps.setInt(1, id);
			ResultSet rs = ps.executeQuery();
	
			long hcpMID = 0;
			if(rs.next()) {
				
				 hcpMID = rs.getLong(&quot;Prescriber&quot;);
			}
			return hcpMID;
		} catch(SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	public AdverseEventBean getReport(int id) throws DBException{
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM AdverseEvents WHERE id=?&quot;);
			ps.setInt(1, id);
			ResultSet rs = ps.executeQuery();
	
			List&lt;AdverseEventBean&gt; aeList = aeLoader.loadList(rs);
			return aeList.get(0);
		} catch(SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);			
		}
	}
	
	public long removeReport(int id) throws DBException{
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE AdverseEvents SET Status = ? WHERE id = ?&quot;);
			String removed = &quot;removed&quot;;
			ps.setString(1, removed);
			ps.setInt(2,id);
			ps.executeUpdate();
			long a = DBUtil.getLastInsert(conn);
			return a;
		} catch(SQLException e){
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);	
		}
	}
	
	public List&lt;AdverseEventBean&gt; getUnremovedAdverseEventsByCode(String code) throws DBException
	{
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM adverseevents WHERE code=? AND status=?&quot;);
			ps.setString(1, code);
			ps.setString(2, &quot;Active&quot;);
			ResultSet rs;
			rs = ps.executeQuery();
			return aeLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	public String getNameForCode(String code) throws DBException
	{
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT PresImmu FROM adverseevents WHERE code=?&quot;);
			ps.setString(1, code);
			ResultSet rs;
			rs = ps.executeQuery();
			if(rs.next()) {
				 return rs.getString(&quot;PresImmu&quot;);
			}
			return &quot;Name not Found&quot;;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	public List&lt;AdverseEventBean&gt; getPerscriptions(String start, String end) throws ParseException, DBException{
		Connection conn = null;
		PreparedStatement ps = null;
		
		try{
			SimpleDateFormat fmt = new SimpleDateFormat(&quot;MM/dd/yyy&quot;);
			Date beginning = fmt.parse(start);
			Date ending = fmt.parse(end);
	 
			conn = factory.getConnection();
			//AND NDCodes.Code=AdverseEvents.Code 
			ps = conn.prepareStatement(&quot;SELECT * FROM AdverseEvents,NDCodes WHERE AdverseEvents.TimeLogged &gt;= ? AND AdverseEvents.TimeLogged &lt;= ? AND NDCodes.Code=AdverseEvents.Code ORDER BY AdverseEvents.Code, AdverseEvents.TimeLogged DESC&quot;);
			 
			ps.setTimestamp(1, new Timestamp(beginning.getTime()));
			ps.setTimestamp(2, new Timestamp(ending.getTime() + 1000L * 60L * 60 * 24L));
			ResultSet rs = ps.executeQuery();
	
			List&lt;AdverseEventBean&gt; aeList = aeLoader.loadList(rs);
			return aeList;
		} catch(SQLException e){
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);	
		}
	}
	
	public List&lt;AdverseEventBean&gt; getImmunizations(String start, String end) throws ParseException, DBException{
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			SimpleDateFormat fmt = new SimpleDateFormat(&quot;MM/dd/yyy&quot;);
			Date beginning = fmt.parse(start);
			Date ending = fmt.parse(end);
	 
			conn = factory.getConnection();
			//AND NDCodes.Code=AdverseEvents.Code 
			ps = conn.prepareStatement(&quot;SELECT * FROM AdverseEvents,CPTCodes WHERE AdverseEvents.TimeLogged &gt;= ? AND AdverseEvents.TimeLogged &lt;= ? AND CPTCodes.Code=AdverseEvents.Code ORDER BY AdverseEvents.Code, AdverseEvents.TimeLogged DESC&quot;);
			 
			ps.setTimestamp(1, new Timestamp(beginning.getTime()));
			ps.setTimestamp(2, new Timestamp(ending.getTime() + 1000L * 60L * 60 * 24L));
			ResultSet rs = ps.executeQuery();
	
			List&lt;AdverseEventBean&gt; aeList = aeLoader.loadList(rs);
			return aeList;
		} catch(SQLException e){
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);			
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AllergyDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.AllergyBean;
import edu.ncsu.csc.itrust.beans.loaders.AllergyBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class AllergyDAO {
	private DAOFactory factory;
	private AllergyBeanLoader allergyBeanLoader = new AllergyBeanLoader();

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public AllergyDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Returns a list of patient's allergies.
	 * @param pid A long for the MID of the patient we are looking up.
	 * @return A java.util.List of AllergyBeans associated with this patient.
	 * @throws DBException
	 */
	public List&lt;AllergyBean&gt; getAllergies(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM Allergies WHERE PatientID=? ORDER BY FirstFound DESC&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return allergyBeanLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Adds an allergy to this patient's list.
	 * @param pid The MID of the patient whose allergy we are adding.
	 * @param description The name of the allergen.
	 * @throws DBException
	 */
	public void addAllergy(long pid, String description) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO Allergies(PatientID, Description) VALUES (?,?)&quot;);
			ps.setLong(1, pid);
			ps.setString(2, description);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ApptDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.ApptBean;
import edu.ncsu.csc.itrust.beans.loaders.ApptBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;

public class ApptDAO {
	private DAOFactory factory;
	private ApptBeanLoader abloader;
	
	public ApptDAO(DAOFactory factory) {
		this.factory = factory;
		this.abloader = new ApptBeanLoader();
	}
	
	public List&lt;ApptBean&gt; getApptsFor(long mid) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;
		conn = factory.getConnection();
		
		if(mid &gt;= (long) 999999999){
			ps = conn.prepareStatement(&quot;SELECT * FROM appointment WHERE doctor_id=? ORDER BY sched_date;&quot;);
		}
		else {
			ps = conn.prepareStatement(&quot;SELECT * FROM appointment WHERE patient_id=? ORDER BY sched_date;&quot;);
		}
		
		ps.setLong(1, mid);
		
		ResultSet rs = ps.executeQuery();
		List&lt;ApptBean&gt; abList = this.abloader.loadList(rs);
		DBUtil.closeConnection(conn, ps);
		return abList;
	}
	
	public List&lt;ApptBean&gt; getAllAppts() throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;
		conn = factory.getConnection();
		
		ps = conn.prepareStatement(&quot;SELECT * FROM appointment;&quot;);
		
		ResultSet rs = ps.executeQuery();
		List&lt;ApptBean&gt; abList = this.abloader.loadList(rs);
		DBUtil.closeConnection(conn, ps);
		return abList;
	}
	
	public void scheduleAppt(ApptBean appt) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;
		conn = factory.getConnection();
		
		ps = conn.prepareStatement(
				&quot;INSERT INTO appointment (appt_type, patient_id, doctor_id, sched_date, comment) &quot;
			  + &quot;VALUES (?, ?, ?, ?, ?)&quot;);
		ps = this.abloader.loadParameters(ps, appt);
		
		ps.executeUpdate();
		
		DBUtil.closeConnection(conn, ps);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ApptTypeDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.ApptTypeBean;
import edu.ncsu.csc.itrust.beans.loaders.ApptTypeBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

public class ApptTypeDAO {
	private DAOFactory factory;
	private ApptTypeBeanLoader atLoader;
	
	public ApptTypeDAO(DAOFactory factory) {
		this.factory = factory;
		this.atLoader = new ApptTypeBeanLoader();
	}
	
	public List&lt;ApptTypeBean&gt; getApptTypes() throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;

		conn = factory.getConnection();
		ps = conn.prepareStatement(&quot;SELECT * FROM appointmenttype&quot;);
		ResultSet rs = ps.executeQuery();
		
		List&lt;ApptTypeBean&gt; atList = this.atLoader.loadList(rs);
		DBUtil.closeConnection(conn, ps);

		return atList;
	}
	
	public boolean addApptType(ApptTypeBean apptType) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;

		conn = factory.getConnection();
		ps = conn.prepareStatement(
				&quot;INSERT INTO appointmenttype (appt_type, duration) &quot;
			  + &quot;VALUES (?, ?)&quot;);
		this.atLoader.loadParameters(ps, apptType);
		int x = ps.executeUpdate();

		DBUtil.closeConnection(conn, ps);
		
		if(x &gt; 0)
			return true;
		else
			return false;
	}
	
	public boolean editApptType(ApptTypeBean apptType) throws SQLException, DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		conn = factory.getConnection();
		ps = conn.prepareStatement(&quot;UPDATE appointmenttype SET duration=? WHERE appt_type=?&quot;);
		ps.setInt(1, apptType.getDuration());
		ps.setString(2, apptType.getName());
		int x = ps.executeUpdate();

		DBUtil.closeConnection(conn, ps);
		
		if(x &gt; 0)
			return true;
		else
			return false;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AuthDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.RandomPassword;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.enums.Role;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * AuthDAO is for anything that has to do with authentication. Most methods access the users table.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class AuthDAO {
	public static final long LOGIN_TIMEOUT = 15 * 60 * 1000;// 15 min
	private DAOFactory factory;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public AuthDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Add a particular user to the system. Does not add user-specific information (e.g. Patient or HCP).
	 * Initially sets security question to a random set of characters, so that nobody should be able to guess
	 * its value.
	 * 
	 * @param mid The user's MID as a Long.
	 * @param role The role of the user as a Role enum {@link Role}
	 * @param password The password for the new user.
	 * @return A string representing the newly added randomly-generated password. 
	 * @throws DBException
	 */
	public String addUser(Long mid, Role role, String password) throws DBException {
		Connection conn = null;
		PreparedStatement pstmt = null;
		try {
			conn = factory.getConnection();
			pstmt = conn
					.prepareStatement(&quot;INSERT INTO Users (MID, PASSWORD, ROLE, sQuestion, sAnswer) VALUES (?,?,?,?,?)&quot;);
			pstmt.setLong(1, mid);
			pstmt.setString(2, password);
			pstmt.setString(3, role.toString());
			pstmt.setString(4, &quot;Enter the random password given in your account email&quot;);
			String pwd = RandomPassword.getRandomPassword();
			pstmt.setString(5, pwd);
			pstmt.executeUpdate();
			return pwd;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, pstmt);
		}
	}

	/**
	 * Reset the security question and answer for a particular user
	 * 
	 * @param question The security question as a string.
	 * @param answer The security answer as a string.
	 * @param mid The MID of the user as a long.
	 * @throws DBException
	 */
	public void setSecurityQuestionAnswer(String question, String answer, long mid) throws DBException {
		Connection conn = null;
		PreparedStatement pstmt = null;
		try {
			conn = factory.getConnection();
			pstmt = conn.prepareStatement(&quot;UPDATE Users SET sQuestion = ?, sAnswer = ? WHERE MID = ?&quot;);
			pstmt.setString(1, question);
			pstmt.setString(2, answer);
			pstmt.setLong(3, mid);
			pstmt.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, pstmt);
		}
	}

	/**
	 * Returns the user name of a user from just the MID
	 * 
	 * @param mid The MID of the user to get the name of.
	 * @return The user's name as a String.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public String getUserName(long mid) throws DBException, iTrustException {
		Role role = getUserRole(mid);
		switch (role) {
			case HCP:
			case PHA:
			case ADMIN:
			case UAP:
			case ER:
				return factory.getPersonnelDAO().getName(mid);
			case PATIENT:
				return factory.getPatientDAO().getName(mid);
			case TESTER:
				return String.valueOf(mid);
			default:
				throw new iTrustException(&quot;Role &quot; + role + &quot; not supported&quot;);
		}
	}

	/**
	 * Returns the role of a particular MID
	 * 
	 * @param mid The MID of the user to look up.
	 * @return The {@link Role} of the user as an enum.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public Role getUserRole(long mid) throws DBException, iTrustException {
		Connection conn = null;
		PreparedStatement pstmt = null;
		try {
			conn = factory.getConnection();
			pstmt = conn.prepareStatement(&quot;SELECT role FROM Users WHERE MID=?&quot;);
			pstmt.setLong(1, mid);
			ResultSet rs;
			rs = pstmt.executeQuery();
			if (rs.next()) {
				return Role.parse(rs.getString(&quot;role&quot;));
			} else {
				throw new iTrustException(&quot;User does not exist&quot;);
			}
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, pstmt);
		}
	}

	/**
	 * Change the password of a particular user
	 * 
	 * @param mid The MID of the user whose password we are changing.
	 * @param password The new password.
	 * @throws DBException
	 */
	public void resetPassword(long mid, String password) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE Users SET password=? WHERE MID=?&quot;);
			ps.setString(1, password);
			ps.setLong(2, mid);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Return the security question for a particular user.
	 * 
	 * @param mid The MID of the user we are looking up.
	 * @return The security question of the user we are looking up.
	 * @throws iTrustException
	 */
	public String getSecurityQuestion(long mid) throws iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT sQuestion FROM Users WHERE MID=?&quot;);
			ps.setLong(1, mid);
			ResultSet r = ps.executeQuery();
			if (r.next())
				return r.getString(&quot;sQuestion&quot;);
			else
				throw new iTrustException(&quot;No security question set for MID: &quot; + mid);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Return the security answer of a particular user
	 * 
	 * @param mid The MID of the user we are looking up.
	 * @return The security answer as a String.
	 * @throws iTrustException
	 */
	public String getSecurityAnswer(long mid) throws iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT sAnswer FROM Users WHERE MID=?&quot;);
			ps.setLong(1, mid);
			ResultSet r = ps.executeQuery();
			if (r.next())
				return r.getString(&quot;sAnswer&quot;);
			else
				throw new iTrustException(&quot;No security answer set for MID &quot; + mid);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Record a login failure, which blacklists the ipAddress. Uses the database table like a hash table where
	 * the key is the user's IP address. If the user's IP address is not in the table, a row with &quot;1&quot; is
	 * added.
	 * 
	 * @param ipAddr The IP address of the user as a String.
	 * @throws DBException
	 */
	public void recordLoginFailure(String ipAddr) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;UPDATE LoginFailures SET FailureCount=FailureCount+1, lastFailure=CURRENT_TIMESTAMP WHERE IPAddress=?&quot;);
					//.prepareStatement(&quot;INSERT INTO LoginFailures VALUES(?,?,?)&quot;);
			ps.setString(1, ipAddr);
			//ps.setInt(2, failures);
			//ps.setDate(3, Calendar.getInstance().getTime());
			int numUpdated = ps.executeUpdate();
			if (numUpdated == 0) // if there wasn't an empty row to begin with
				insertLoginFailureRow(ipAddr, 1, conn);// now they have a row AND a strike against
			// 'em
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Record a reset password failure, which blacklists the ipAddress. Uses the database table like a hash
	 * table where the key is the user's IP address. If the user's IP address is not in the table, a row with
	 * &quot;1&quot; is added.
	 * 
	 * @param ipAddr The IP address of the user as a String.
	 * @throws DBException
	 */
	public void recordResetPasswordFailure(String ipAddr) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;UPDATE ResetPasswordFailures SET failurecount=failurecount+1 WHERE ipaddress=?&quot;);
			ps.setString(1, ipAddr);
			int numUpdated = ps.executeUpdate();
			if (numUpdated == 0) // if there wasn't an empty row to begin with
				insertResetPasswordRow(ipAddr, 1, conn);// now they have a row AND a strike against
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Return the number of failures from resetting a password, given an IP address.
	 * 
	 * @param ipAddr An IP address for the associated attempt as a String.
	 * @return An int representing the number of failures.
	 * @throws DBException
	 */
	public int getResetPasswordFailures(String ipAddr) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM ResetPasswordFailures WHERE IPADDRESS=?&quot;);
			ps.setString(1, ipAddr);
			ResultSet rs = ps.executeQuery();
			if (rs.next()) {
				// if we're more than X minutes out, clear the failure count
				if (System.currentTimeMillis() - rs.getTimestamp(&quot;lastFailure&quot;).getTime() &gt; LOGIN_TIMEOUT) {
					updateResetFailuresToZero(ipAddr, conn);
					return 0;
				} else {
					return rs.getInt(&quot;failureCount&quot;);
				}
			} else {
				insertResetPasswordRow(ipAddr, 0, conn);
				return 0;
			}
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Return the number of failures from login failures a password, given an IP address.
	 * 
	 * @param ipAddr The IP address for this attempt as a String.
	 * @return An int representing the number of failures which have occured.
	 * @throws DBException
	 */
	public int getLoginFailures(String ipAddr) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM LoginFailures WHERE IPADDRESS=?&quot;);
			ps.setString(1, ipAddr);
			ResultSet rs = ps.executeQuery();
			if (rs.next()) {
				// if we're more than X minutes out, clear the failure count
				if (System.currentTimeMillis() - rs.getTimestamp(&quot;lastFailure&quot;).getTime() &gt; LOGIN_TIMEOUT) {
					updateFailuresToZero(ipAddr, conn);
					return 0;
				} else {
					return rs.getInt(&quot;failureCount&quot;);
				}
			} else {
				insertLoginFailureRow(ipAddr, 0, conn);
				return 0;
			}
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	private void insertLoginFailureRow(String ipAddr, int failureCount, Connection conn) throws DBException,
			SQLException {
		PreparedStatement ps = conn
				.prepareStatement(&quot;INSERT INTO LoginFailures(IPAddress, failureCount) VALUES(?,?)&quot;);
		ps.setString(1, ipAddr);
		ps.setInt(2, failureCount);
		ps.executeUpdate();
	}

	private void insertResetPasswordRow(String ipAddr, int failureCount, Connection conn) throws DBException,
			SQLException {
		PreparedStatement ps = conn
				.prepareStatement(&quot;INSERT INTO ResetPasswordFailures(IPAddress, failureCount) VALUES(?,?)&quot;);
		ps.setString(1, ipAddr);
		ps.setInt(2, failureCount);
		ps.executeUpdate();
	}

	private void updateFailuresToZero(String ipAddr, Connection conn) throws DBException, SQLException {
		PreparedStatement ps = conn
				.prepareStatement(&quot;UPDATE LoginFailures SET failureCount=0 WHERE IPAddress=?&quot;);
		ps.setString(1, ipAddr);
		ps.executeUpdate();
	}
	
	public void resetLoginFailuresToZero(String ipAddr) throws DBException, SQLException {
		Connection conn = null;
		PreparedStatement ps = null;
		try{
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;UPDATE LoginFailures SET failureCount=0 WHERE IPAddress=?&quot;);
			ps.setString(1, ipAddr);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	private void updateResetFailuresToZero(String ipAddr, Connection conn) throws DBException, SQLException {
		PreparedStatement ps = conn
				.prepareStatement(&quot;UPDATE ResetPasswordFailures SET failureCount=0 WHERE IPAddress=?&quot;);
		ps.setString(1, ipAddr);
		ps.executeUpdate();
	}

	/**
	 * Check that a user actually exists.
	 * 
	 * @param mid
	 * @return
	 * @throws DBException
	 */
	public boolean checkUserExists(long mid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM Users WHERE MID=?&quot;);
			ps.setLong(1, mid);
			ResultSet rs = ps.executeQuery();
			return rs.next();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_CPTCodesDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.ProcedureBean;
import edu.ncsu.csc.itrust.beans.loaders.ProcedureBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Used for managing CPT codes.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * The CPT code set accurately describes medical, surgical, and diagnostic services 
 * and is designed to communicate uniform information about medical services and procedures 
 * among physicians, coders, patients, accreditation organizations, and payers for administrative, 
 * financial, and analytical purposes.
 *
 * @see http://www.ama-assn.org/ama/pub/physician-resources/solutions-managing-your-practice/coding-billing-insurance/cpt/about-cpt.shtml
 * @author Andy
 * 
 */
public class CPTCodesDAO {
	private DAOFactory factory;
	private ProcedureBeanLoader procedureBeanLoader = new ProcedureBeanLoader();

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public CPTCodesDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Returns a list of all CPT codes.
	 * 
	 * @return A java.util.List of ProcedureBeans for the CPT codes.
	 * @throws DBException
	 */
	public List&lt;ProcedureBean&gt; getAllCPTCodes() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM CPTCodes ORDER BY CODE&quot;);
			ResultSet rs = ps.executeQuery();
			return procedureBeanLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Returns a list of all CPT codes.
	 * 
	 * @return A java.util.List of all Immunization-related CPT codes.
	 * @throws DBException
	 */
	public List&lt;ProcedureBean&gt; getImmunizationCPTCodes() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;select * from cptcodes where attribute='immunization' order by code&quot;);
			ResultSet rs = ps.executeQuery();
			return procedureBeanLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a particular procedure description for a code.
	 * 
	 * @param code The string representation of the code.
	 * @return The textual description of the code.
	 * @throws DBException
	 */
	public ProcedureBean getCPTCode(String code) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM CPTCodes WHERE Code = ?&quot;);
			ps.setString(1, code);
			ResultSet rs = ps.executeQuery();
			if (rs.next())
				return procedureBeanLoader.loadSingle(rs);
			return null;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Adds a new CPT code, returns that it was added successfully
	 * 
	 * @param proc A ProcedureBean representing the new code information.
	 * @return A boolean for whether the operation was successful.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public boolean addCPTCode(ProcedureBean proc) throws DBException, iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO CPTCodes (Code, Description, Attribute) &quot; + &quot;VALUES (?,?,?)&quot;);
			ps.setString(1, proc.getCPTCode());
			ps.setString(2, proc.getDescription());
			ps.setString(3, proc.getAttribute());
			return (1 == ps.executeUpdate());
		} catch (SQLException e) {
			e.printStackTrace();
			if (1062 == e.getErrorCode())
				throw new iTrustException(&quot;Error: Code already exists.&quot;);
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Change the procedure description for a particular CPT code
	 * 
	 * @param proc A ProcedureBean representing the new code information.
	 * @return A boolean for whether the operation was successful.
	 * @throws DBException
	 */
	public int updateCode(ProcedureBean proc) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE CPTCodes SET Description = ?, Attribute = ? WHERE Code = ?&quot;);
			ps.setString(1, proc.getDescription());
			ps.setString(2, proc.getAttribute());
			ps.setString(3, proc.getCPTCode());
			return ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_DrugInteractionDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.DrugInteractionBean;
import edu.ncsu.csc.itrust.beans.loaders.DrugInteractionBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Used for managing drug interactions.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @see http://www.fda.gov/Drugs/InformationOnDrugs/ucm142438.htm
 * @author Andy
 * 
 */
public class DrugInteractionDAO {
	private DAOFactory factory;
	private DrugInteractionBeanLoader interactionLoader;
	
	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public DrugInteractionDAO(DAOFactory factory) {
		this.factory = factory;
		interactionLoader = new DrugInteractionBeanLoader();
	}
	
	/**
	 * Returns a list of all drug interactions for the input drug name
	 * 
	 * @return A java.util.List of DrugInteractionBeans.
	 * @throws DBException
	 */
	public List&lt;DrugInteractionBean&gt; getInteractions(String drugCode) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM druginteractions WHERE FirstDrug = ? OR SecondDrug = ?&quot;);
			ps.setString(1, drugCode);
			ps.setString(2, drugCode);
			ResultSet rs = ps.executeQuery();
			return interactionLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Adds a new drug interaction, returns whether or not the addition was successful. If the code already exists, an
	 * iTrustException is thrown.
	 * 
	 * @param firstDrug  The name of the first drug in an interaction.
	 * @param secondDrug  The name of the second drug in an interaction.
	 * @param description  Explanation of the drug interaction.
	 * @return A boolean indicating success or failure.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public boolean reportInteraction(String firstDrug, String secondDrug, String description) throws DBException, iTrustException {
		if(firstDrug.equals(secondDrug)) throw new iTrustException(&quot;Drug cannot interact with itself.&quot;);
		
		List&lt;DrugInteractionBean&gt; currentIntsDrug2 = getInteractions(secondDrug);
		for(DrugInteractionBean dib : currentIntsDrug2){
			if(dib.getSecondDrug().equals(firstDrug)){
				throw new iTrustException(&quot;Error: Interaction between these drugs already exists.&quot;);
			}
		}
		
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO druginteractions (FirstDrug, SecondDrug, Description) &quot; + &quot;VALUES (?,?,?)&quot;);
			ps.setString(1, firstDrug);
			ps.setString(2, secondDrug);
			ps.setString(3, description);
			return (1 == ps.executeUpdate());
		} catch (SQLException e) {
			e.printStackTrace();
			if (1062 == e.getErrorCode())
				throw new iTrustException(&quot;Error: Interaction between these drugs already exists.&quot;);
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Remove an interaction from the database
	 * 
	 * @param firstDrug  The name of the first patient
	 * @param secondDrug  The name of the second patient
	 * @return true if removed successfully, false if not in list
	 */
	public boolean deleteInteraction(String firstDrug,String secondDrug) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;DELETE FROM druginteractions WHERE (FirstDrug = ? OR SecondDrug = ?) AND (FirstDrug = ? OR SecondDrug = ?)&quot;);
			ps.setString(1, firstDrug);
			ps.setString(2, firstDrug);
			ps.setString(3, secondDrug);
			ps.setString(4, secondDrug);
			if(ps.executeUpdate() == 0)
				return false;
			return true;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_FakeEmailDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.Email;
import edu.ncsu.csc.itrust.beans.loaders.EmailBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class FakeEmailDAO {
	private DAOFactory factory;
	private EmailBeanLoader emailBeanLoader = new EmailBeanLoader();

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public FakeEmailDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Return all emails that have been &quot;sent&quot; (inserted into the database)
	 * 
	 * @return A java.util.List of Email objects representing fake e-mails.
	 * @throws DBException
	 */
	public List&lt;Email&gt; getAllEmails() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM FakeEmail ORDER BY AddedDate DESC&quot;);
			ResultSet rs = ps.executeQuery();
			return emailBeanLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Return all emails that a person has sent
	 * 
	 * @param email The &quot;From&quot; email address as a string.
	 * @return A java.util.List of fake emails.
	 * @throws DBException
	 */
	public List&lt;Email&gt; getEmailsByPerson(String email) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM FakeEmail WHERE ToAddr LIKE ? ORDER BY AddedDate DESC&quot;);
			ps.setString(1, &quot;%&quot; + email + &quot;%&quot;);
			ResultSet rs = ps.executeQuery();
			return emailBeanLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * &quot;Send&quot; an email, which just inserts it into the database.
	 * 
	 * @param email The Email object to insert.
	 * @throws DBException
	 */
	public void sendEmailRecord(Email email) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO FakeEmail (ToAddr, FromAddr, Subject, Body) &quot;
					+ &quot;VALUES (?,?,?,?)&quot;);
			emailBeanLoader.loadParameters(ps, email);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a list of emails that have the given string as a substring of the body
	 * @param string The string to search within the body.
	 * @return A java.util.List of fake emails.
	 * @throws DBException 
	 */
	public List&lt;Email&gt; getEmailWithBody(String bodySubstring) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM FakeEmail WHERE Instr(Body,?)&gt;0 ORDER BY AddedDate DESC&quot;);
			ps.setString(1, bodySubstring);
			ResultSet rs = ps.executeQuery();
			return emailBeanLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_FamilyDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.FamilyMemberBean;
import edu.ncsu.csc.itrust.beans.loaders.FamilyBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Used for queries related to families.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class FamilyDAO {
	private DAOFactory factory;
	private FamilyBeanLoader familyBeanLoader;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public FamilyDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Return the information of the mother and father of this patient
	 * 
	 * @param pid -
	 *            this patient
	 * @return
	 * @throws DBException
	 */
	public List&lt;FamilyMemberBean&gt; getParents(long pid) throws DBException {
		return getFamilyMembers(pid, &quot;Parent&quot;,
				&quot;SELECT p2.FirstName AS FirstName, p2.LastName AS LastName, p2.MID as MID &quot;
						+ &quot;FROM Patients p1, Patients p2 &quot;
						+ &quot;WHERE p1.MID=? AND (p1.MotherMID=p2.MID OR p1.FatherMID=p2.MID)&quot;, false);
	}

	/**
	 * Return a list of patients who share at least one parent (and that parent is not '0') with this patient
	 * 
	 * @param pid -
	 *            this patient
	 * @return A java.util.list of FamilyMemberBeans.
	 * @throws DBException
	 */
	public List&lt;FamilyMemberBean&gt; getSiblings(long pid) throws DBException {
		return getFamilyMembers(pid, &quot;Sibling&quot;,
				&quot;SELECT p2.FirstName AS FirstName, p2.LastName AS LastName, p2.MID as MID &quot;
						+ &quot;FROM Patients p1, Patients p2 &quot; + &quot;WHERE p1.MID=? AND p1.MID&lt;&gt;p2.MID &quot;
						+ &quot;AND( (p1.MotherMID=p2.MotherMID AND p2.MotherMID&lt;&gt;0)&quot;
						+ &quot;  OR (p1.FatherMID=p2.FatherMID AND p1.FatherMID&lt;&gt;0))&quot;, false);
	}

	/**
	 * Return a list of patients whose mother or father is this patient
	 * 
	 * @param pid -
	 *            this patient
	 * @return A java.util.List of FamilyMemberBeans.
	 * @throws DBException
	 */
	public List&lt;FamilyMemberBean&gt; getChildren(long pid) throws DBException {
		return getFamilyMembers(pid, &quot;Child&quot;, &quot;SELECT FirstName, LastName, MID FROM Patients &quot;
				+ &quot;WHERE MotherMID=? or FatherMID=?&quot;, true);
	}

	/**
	 * Private helper method (since all three are alike)
	 * 
	 * @param pid
	 * @param relation
	 * @param query
	 * @param secondParam -
	 *            add the pid as the second parameter (the 3rd query was a little different)
	 * 
	 * @return A java.util.List of FamilyMemberBeans.
	 * @throws DBException
	 */
	private List&lt;FamilyMemberBean&gt; getFamilyMembers(long pid, String relation, String query,
			boolean secondParam) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		familyBeanLoader = new FamilyBeanLoader(relation);
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(query);
			ps.setLong(1, pid);
			if (secondParam)
				ps.setLong(2, pid);
			ResultSet rs = ps.executeQuery();
			return familyBeanLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_HealthRecordsDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.HealthRecord;
import edu.ncsu.csc.itrust.beans.loaders.HealthRecordsBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Used for all health records where a whole history is kept.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class HealthRecordsDAO {
	private HealthRecordsBeanLoader loader = new HealthRecordsBeanLoader();
	private DAOFactory factory;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public HealthRecordsDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Returns a list of all health records for a particular patient
	 * 
	 * @param mid The MID of the patient to look up.
	 * @return A java.util.List of HealthRecords.
	 * @throws DBException
	 */
	public List&lt;HealthRecord&gt; getAllHealthRecords(long mid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM PersonalHealthInformation &quot;
					+ &quot;WHERE PatientID=? ORDER BY ASOFDATE DESC&quot;);
			ps.setLong(1, mid);
			ResultSet rs;
			rs = ps.executeQuery();
			return loader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Adds a health record for a particular patient
	 * 
	 * @param record The HealthRecord object to insert.
	 * @return A boolean indicating whether the insert was successful.
	 * @throws DBException
	 */
	public boolean add(HealthRecord record) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO PersonalHealthInformation(PatientID,Height,Weight,&quot;
					+ &quot;Smoker,BloodPressureN,BloodPressureD,CholesterolHDL,CholesterolLDL,CholesterolTri,&quot;
					+ &quot;HCPID) VALUES(?,?,?,?,?,?,?,?,?,?)&quot;);
			loader.loadParameters(ps, record);
			int numInserted = ps.executeUpdate();
			return (numInserted == 1);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_HospitalsDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.HospitalBean;
import edu.ncsu.csc.itrust.beans.loaders.HospitalBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Used for managing hospitals
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class HospitalsDAO {
	private DAOFactory factory;
	private HospitalBeanLoader hospitalLoader = new HospitalBeanLoader();

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public HospitalsDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Returns a list of all hospitals sorted alphabetically
	 * 
	 * @return A java.util.List of HospitalBeans.
	 * @throws DBException
	 */
	public List&lt;HospitalBean&gt; getAllHospitals() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM Hospitals ORDER BY HospitalName&quot;);
			ResultSet rs = ps.executeQuery();
			return hospitalLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a particular hospital given its ID
	 * 
	 * @param id The String ID of the hospital.
	 * @return A HospitalBean representing this hospital.
	 * @throws DBException
	 */
	public HospitalBean getHospital(String id) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM Hospitals WHERE HospitalID = ?&quot;);
			ps.setString(1, id);
			ResultSet rs = ps.executeQuery();
			if (rs.next())
				return hospitalLoader.loadSingle(rs);
			return null;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Adds a hospital
	 * 
	 * @param hosp The HospitalBean object to insert.
	 * @return A boolean indicating whether the insertion was successful.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public boolean addHospital(HospitalBean hosp) throws DBException, iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO Hospitals (HospitalID, HospitalName) &quot; + &quot;VALUES (?,?)&quot;);
			ps.setString(1, hosp.getHospitalID());
			ps.setString(2, hosp.getHospitalName());
			return (1 == ps.executeUpdate());
		} catch (SQLException e) {
			e.printStackTrace();
			if (1062 == e.getErrorCode())
				throw new iTrustException(&quot;Error: Hospital already exists.&quot;);
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Updates a particular hospital's description. Returns the number of rows affected (should be 1)
	 * 
	 * @param hosp The HospitalBean to update.
	 * @return An int indicating the number of affected rows.
	 * @throws DBException
	 */
	public int updateHospital(HospitalBean hosp) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE Hospitals SET HospitalName = ? &quot; + &quot;WHERE HospitalID = ?&quot;);
			ps.setString(1, hosp.getHospitalName());
			ps.setString(2, hosp.getHospitalID());
			return ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Assign an HCP to a hospital. If they have already been assigned to that hospital, then an
	 * iTrustException is thrown.
	 * 
	 * @param hcpID The HCP's MID to assign to the hospital.
	 * @param hospitalID The ID of the hospital to assign them to.
	 * @return A boolean indicating whether the assignment was a success.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public boolean assignHospital(long hcpID, String hospitalID) throws DBException, iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO HCPAssignedHos (HCPID, HosID) VALUES (?,?)&quot;);
			ps.setLong(1, hcpID);
			ps.setString(2, hospitalID);
			return (1 == ps.executeUpdate());
		} catch (SQLException e) {
			if (1062 == e.getErrorCode())
				throw new iTrustException(&quot;HCP &quot; + hcpID + &quot; already assigned to hospital &quot; + hospitalID);
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Unassigns an HCP to a hospital. Returns whether or not any changes were made
	 * 
	 * @param hcpID The MID of the HCP to remove.
	 * @param hospitalID The ID of the hospital being removed from.
	 * @return A boolean indicating success.
	 * @throws DBException
	 */
	public boolean removeHospitalAssignment(long hcpID, String hospitalID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;DELETE FROM HCPAssignedHos WHERE HCPID = ? AND HosID = ?&quot;);
			ps.setLong(1, hcpID);
			ps.setString(2, hospitalID);
			return (1 == ps.executeUpdate());
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Removes all hospital assignments for a particular HCP. Returns the number of rows affected.
	 * 
	 * @param hcpID The MID of the HCP.
	 * @return An int representing the number of hospital assignments removed.
	 * @throws DBException
	 */
	public int removeAllHospitalAssignmentsFrom(long hcpID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;DELETE FROM HCPAssignedHos WHERE HCPID = ?&quot;);
			ps.setLong(1, hcpID);
			return ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ICDCodesDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.DiagnosisBean;
import edu.ncsu.csc.itrust.beans.loaders.DiagnosisBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Used for managing all ICD codes.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * The International Statistical Classification of Diseases and Related Health Problems 
 * (most commonly known by the abbreviation ICD) provides codes to classify diseases and a 
 * wide variety of signs, symptoms, abnormal findings, complaints, social circumstances and 
 * external causes of injury or disease. 
 * 
 * @see http://www.cdc.gov/nchs/icd9.htm
 * @author Andy
 * 
 */
public class ICDCodesDAO {
	private DAOFactory factory;
	private DiagnosisBeanLoader diagnosisLoader = new DiagnosisBeanLoader();

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public ICDCodesDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Returns all ICD9CM codes sorted by code
	 * 
	 * @return java.util.List of DiagnosisBeans
	 * @throws DBException
	 */
	public List&lt;DiagnosisBean&gt; getAllICDCodes() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM ICDCodes ORDER BY CODE&quot;);
			ResultSet rs = ps.executeQuery();
			return diagnosisLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a particular description for a given code
	 * 
	 * @param code The String representation of the code.
	 * @return A DiagnosisBean of the code.
	 * @throws DBException
	 */
	public DiagnosisBean getICDCode(String code) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM ICDCodes WHERE Code = ?&quot;);
			ps.setString(1, code);
			ResultSet rs = ps.executeQuery();
			if (rs.next())
				return diagnosisLoader.loadSingle(rs);
			return null;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Adds an ICD9CM code. Returns whether or not the change was made.
	 * 
	 * @param diag The DiagnosisBean representing the changes.
	 * @return A boolean indicating success.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public boolean addICDCode(DiagnosisBean diag) throws DBException, iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO ICDCodes (Code, Description, Chronic) &quot; + &quot;VALUES (?,?,?)&quot;);
			ps.setString(1, diag.getICDCode());
			ps.setString(2, diag.getDescription());
			ps.setString(3, diag.getClassification());
			return (1 == ps.executeUpdate());
		} catch (SQLException e) {
			e.printStackTrace();
			if (1062 == e.getErrorCode())
				throw new iTrustException(&quot;Error: Code already exists.&quot;);
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Changes a the description of a particular code.
	 * 
	 * @param diag A DiagnosisBean representing the changes.
	 * @return A boolean indicating the number of updated rows.
	 * @throws DBException
	 */
	public int updateCode(DiagnosisBean diag) throws DBException {
		int rows;
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE ICDCodes SET Description = ?, Chronic = ? WHERE Code = ?&quot;);
			ps.setString(1, diag.getDescription());
			ps.setString(2, diag.getClassification());
			ps.setString(3, diag.getICDCode());
			rows = ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
		return rows;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_LOINCDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.LOINCbean;
import edu.ncsu.csc.itrust.beans.loaders.LOINCBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * Logical Observation Identifiers Names and Codes (LOINC) is a database and universal
 *  standard for identifying medical laboratory observations. 
 *  
 * @see http://loinc.org/
 * @author Ben Smith
 */
public class LOINCDAO {
	private DAOFactory factory;
	private LOINCBeanLoader LOINCLoader;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public LOINCDAO(DAOFactory factory) {
		this.factory = factory;
		LOINCLoader = new LOINCBeanLoader();
	}
	
	/**
	 * Adds a LOINC
	 * 
	 * @param hosp The LOINCbean representing the new code to be added.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public void addLOINC(LOINCbean hosp) throws DBException, iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO LOINC (LaboratoryProcedureCode, Component, KindOfProperty, TimeAspect, System, ScaleType, MethodType) &quot; + &quot;VALUES (?,?,?,?,?,?,?)&quot;);
			ps.setString(1, hosp.getLabProcedureCode());
			ps.setString(2, hosp.getComponent());
			ps.setString(3, hosp.getKindOfProperty());
			ps.setString(4, hosp.getTimeAspect());
			ps.setString(5, hosp.getSystem());
			ps.setString(6, hosp.getScaleType());
			ps.setString(7, hosp.getMethodType());
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			if (1062 == e.getErrorCode())
				throw new iTrustException(&quot;Error: LOINC already exists.&quot;);
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}	

	/**
	 * Returns all LOINCs associated with LaboratoryProcedureCode
	 * 
	 * @param visitID The code of the Laboratory Procedure Code as a String.
	 * @return A java.util.List of LOINCBeans matching the Laboratory Procedure Code.
	 * @throws DBException
	 */
	public List&lt;LOINCbean&gt; getProcedures(String visitID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;Select * From LOINC Where LaboratoryProcedureCode = ? &quot;);
			ps.setString(1, visitID);
			ResultSet rs = ps.executeQuery();
			return LOINCLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	
	/**
	 * Updates the information in LOINC.
	 * 
	 * @param ov
	 * @throws DBException
	 */
	public int update(LOINCbean ov) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE LOINC SET Component=?, KindOfProperty=?, TimeAspect=?, System=?, ScaleType=?, MethodType=? WHERE LaboratoryProcedureCode=?&quot;);
			ps.setString(1, ov.getComponent());
			ps.setString(2, ov.getKindOfProperty());
			ps.setString(3, ov.getTimeAspect());
			ps.setString(4, ov.getSystem());
			ps.setString(5, ov.getScaleType());
			ps.setString(6, ov.getMethodType());
			ps.setString(7, ov.getLabProcedureCode());
			return ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Returns all LOINCs as a list.
	 * 
	 * @return A java.util.List of LOINCbeans.
	 * @throws DBException
	 */
	public List&lt;LOINCbean&gt; getAllLOINC() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
			try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM LOINC&quot;);
			ResultSet rs = ps.executeQuery();
			return LOINCLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}


}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_LabProcedureDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.LabProcedureBean;
import edu.ncsu.csc.itrust.beans.loaders.LabProcedureBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * A DAO for managing lab procedure codes. Database Access Object. All info coming into a DAO is already validated. 
 * Just worry about DB stuff here. Note that all DAOs need to have a DAOFactory with which to access other 
 * DAOs and to get connections. Also, every DAO must have a constructor with a DAOFactory as a parameter.
 */
public class LabProcedureDAO {
	private DAOFactory factory;
	private LabProcedureBeanLoader labProcedureLoader;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public LabProcedureDAO(DAOFactory factory) {
		this.factory = factory;
		labProcedureLoader = new LabProcedureBeanLoader();
	}
	
	/**
	 * Get a list of the lab procedures associated with a given patient.
	 * @param id The MID of the patient as a long.
	 * @return A java.util.List of LabProcedureBeans
	 * @throws DBException
	 */
	public List&lt;LabProcedureBean&gt; getLabProceduresForPatient(long id) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			if (id == 0L) throw new SQLException(&quot;PatientMID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM LabProcedure WHERE PatientMID = ? AND Rights = ? ORDER BY UpdatedDate DESC&quot;);
			ps.setLong(1, id);
			ps.setString(2, LabProcedureBean.Allow);
			ResultSet rs = ps.executeQuery();
			return labProcedureLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Gets all the lab procedures for a given patient that occur within the next month.
	 * @param id The MID of the patient as a long.
	 * @return A java.util.List of LabProcedureBeans.
	 * @throws DBException
	 */
	public List&lt;LabProcedureBean&gt; getLabProceduresForPatientForNextMonth(long id) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			if (id == 0L) throw new SQLException(&quot;PatientMID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM LabProcedure WHERE PatientMID = ? AND Rights = ? AND Status = ? AND (DateDiff(SYSDATE(),UpdatedDate) &lt;= 30) ORDER BY UpdatedDate DESC&quot;);
			ps.setLong(1, id);
			ps.setString(2, LabProcedureBean.Allow);
			ps.setString(3, LabProcedureBean.Completed);
			ResultSet rs = ps.executeQuery();
			return labProcedureLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Gets an individual lab procedure.
	 * @param id The ID of the lab procedure.
	 * @return A LabProcedureBean representing the procedure.
	 * @throws DBException
	 */
	public LabProcedureBean getLabProcedure(long id) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM LabProcedure WHERE LaboratoryProcedureID = ?&quot;);
			ps.setLong(1, id);
			ResultSet rs = ps.executeQuery();
			rs.next();
			return labProcedureLoader.loadSingle(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	/**
	 * Gets all procedures for Patient
	 * @param mid patient id
	 * @return A java.util.List of LabProcedureBeans.
	 * @throws DBException
	 */
	public List&lt;LabProcedureBean&gt; getAllLabProceduresDate(long mid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			if (mid == 0L) throw new SQLException(&quot;PatientMID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM LabProcedure WHERE PatientMID = ? ORDER BY UpdatedDate DESC&quot;);
			ps.setLong(1, mid);
			ResultSet rs = ps.executeQuery();
			return labProcedureLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	/**
	 * This gets all the procedures for a particular patient on a particular office visit
	 * @param mid The MID of the patient.
	 * @param ovid The Office Visit ID.
	 * @return A java.util.List of LabProcedureBeans.
	 * @throws DBException
	 */
	public List&lt;LabProcedureBean&gt; getAllLabProceduresForDocOV(long mid, long ovid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			if (mid == 0L) throw new SQLException(&quot;PatientMID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM LabProcedure WHERE PatientMID = ? AND OfficeVisitID = ? ORDER BY UpdatedDate DESC&quot;);
			ps.setLong(1, mid);
			ps.setLong(2, ovid);
			ResultSet rs = ps.executeQuery();
			return labProcedureLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * This gets all the procedures for a particular patient on a particular office visit
	 * @param mid The MID of the patient.
	 * @param ovid The Office Visit ID.
	 * @return A java.util.List of LabProcedureBeans
	 * @throws DBException
	 */
	public List&lt;LabProcedureBean&gt; getAllLabProceduresForDocOV(long ovid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM LabProcedure WHERE OfficeVisitID = ? &quot;);
			ps.setLong(1, ovid);
			ResultSet rs = ps.executeQuery();
			return labProcedureLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Gets all lab procedures, period.
	 * @return A java.util.List of LabProcedureBeans.
	 * @throws DBException
	 */
	public List&lt;LabProcedureBean&gt; getAllLabProcedures() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM LabProcedure ORDER BY UpdatedDate ASC&quot;);
			ResultSet rs = ps.executeQuery();
			return labProcedureLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Gets the lab procedures for a given LHCP that occur within the next month.
	 * @param ovid The Office Visit ID conducted by the LHCP in question.
	 * @return A java.util.List of LabProcedureBeans.
	 * @throws DBException
	 */
	public List&lt;LabProcedureBean&gt; getLabProceduresForLHCPForNextMonth(long ovid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (ovid == 0L) throw new SQLException(&quot;OfficeVisitID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM LabProcedure WHERE OfficeVisitID = ? AND Status = ? AND (DateDiff(SYSDATE(),UpdatedDate) &lt;= 30) ORDER BY UpdatedDate DESC&quot;);
			ps.setLong(1, ovid);
			ps.setString(2, LabProcedureBean.Completed);
			ResultSet rs = ps.executeQuery();
			return labProcedureLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Inserts a lab procedure into the database.
	 * @param b The LabProcedureBean to be inserted.
	 * @return A long containing the ID of the newly inserted lab procedure bean.
	 * @throws DBException
	 */
	public long addLabProcedure(LabProcedureBean b) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (b.getPid() == 0L) throw new SQLException(&quot;PatientMID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO LabProcedure (PatientMID, LaboratoryProcedureCode, Status, Commentary, Results, OfficeVisitID, Rights) VALUES (?,?,?,?,?,?,?)&quot;);
			ps.setLong(1, b.getPid());
			ps.setString(2, b.getLoinc());
			ps.setString(3, b.getStatus());
			ps.setString(4, b.getCommentary());
			ps.setString(5, b.getResults());
			ps.setLong(6, b.getOvID());
			ps.setString(7, b.getRights());
			ps.executeUpdate();
			return DBUtil.getLastInsert(conn);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Updates an existing lab procedure.
	 * @param b The LabProcedureBean representing the procedure to be updated.
	 * @throws DBException
	 */
	public void updateLabProcedure(LabProcedureBean b) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (b.getPid() == 0L) throw new SQLException(&quot;PatientMID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE LabProcedure SET Status = ?, Commentary = ?, Results = ?, UpdatedDate = ? WHERE LaboratoryProcedureID=?&quot;);
			ps.setString(1, b.getStatus());
			ps.setString(2, b.getCommentary());
			ps.setString(3, b.getResults());
			ps.setTimestamp(4, new java.sql.Timestamp(System.currentTimeMillis()));
			ps.setLong(5, b.getProcedureID());
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Gets all the lab procedures that correspond to a particular LOINC.
	 * @param id The LOINC in question.
	 * @return A java.util.List of LabProcedureBeans.
	 * @throws DBException
	 */
	public List&lt;LabProcedureBean&gt; getAllLabProceduresLOINC(long id) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			if (id == 0L) throw new SQLException(&quot;PatientMID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM LabProcedure WHERE PatientMID = ? ORDER BY LaboratoryProcedureCode ASC&quot;);
			ps.setLong(1, id);
			ResultSet rs = ps.executeQuery();
			return labProcedureLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Updates the rights of a user on a given lab procedure.
	 * @param b The LabProcedureBean in question.
	 * @throws DBException
	 */
	public void updateRights(LabProcedureBean b) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (b.getPid() == 0L) throw new SQLException(&quot;PatientMID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE LabProcedure SET Rights = ?, UpdatedDate = ? WHERE LaboratoryProcedureID=?&quot;);
			ps.setString(1, b.getRights());
			ps.setTimestamp(2, new java.sql.Timestamp(System.currentTimeMillis()));
			ps.setLong(3, b.getProcedureID());
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}



}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_MessageDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.MessageBean;
import edu.ncsu.csc.itrust.beans.loaders.MessageBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Used for the logging mechanism.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class MessageDAO {
	private DAOFactory factory;
	private MessageBeanLoader mbLoader;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public MessageDAO(DAOFactory factory) {
		this.factory = factory;
		this.mbLoader = new MessageBeanLoader();
	}

	/**
	 * Gets all the messages for a certain user MID.
	 * @param mid The MID of the user to be looked up.
	 * @return A java.util.List of MessageBeans.
	 * @throws SQLException
	 */
	
	public List&lt;MessageBean&gt; getMessagesFor(long mid) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;

		conn = factory.getConnection();
		ps = conn.prepareStatement(&quot;SELECT * FROM message WHERE to_id = ? ORDER BY sent_date DESC&quot;);
		ps.setLong(1, mid);
		ResultSet rs = ps.executeQuery();

		List&lt;MessageBean&gt; mbList = this.mbLoader.loadList(rs);

		DBUtil.closeConnection(conn, ps);

		return mbList;
	}

	/**
	 * Gets all the messages for a certain user MID sorted by ascending time.
	 * @param mid The MID of the user to be looked up.
	 * @return A java.util.List of MessageBeans.
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getMessagesTimeAscending(long mid) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;

		conn = factory.getConnection();
		ps = conn.prepareStatement(&quot;SELECT * FROM message WHERE to_id = ? ORDER BY sent_date ASC&quot;);
		ps.setLong(1, mid);
		ResultSet rs = ps.executeQuery();

		List&lt;MessageBean&gt; mbList = this.mbLoader.loadList(rs);

		DBUtil.closeConnection(conn, ps);

		return mbList;
	}
	
	/**
	 * Gets all the messages for a certain user MID sorted by name ascending.
	 * @param mid The MID of the user to be looked up.
	 * @return A java.util.List of MessageBeans.
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getMessagesNameAscending(long mid) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs;

		conn = factory.getConnection();
		if(mid &gt;= (long) 999999999){
			ps = conn.prepareStatement(&quot;SELECT message.* FROM message, patients WHERE message.from_id=patients.mid AND message.to_id=? ORDER BY patients.lastName ASC, patients.firstName ASC, message.sent_date ASC&quot;);
			ps.setLong(1, mid);
			rs = ps.executeQuery();
		}
		else{
			ps = conn.prepareStatement(&quot;SELECT message.* FROM message, personnel WHERE message.from_id=personnel.mid AND message.to_id=? ORDER BY personnel.lastName ASC, personnel.firstName ASC, message.sent_date ASC&quot;);
			ps.setLong(1, mid);
			rs = ps.executeQuery();
		}

		List&lt;MessageBean&gt; mbList = this.mbLoader.loadList(rs);

		DBUtil.closeConnection(conn, ps);

		return mbList;
	}
	
	/**
	 * Gets all the messages for a certain user MID sorted by name descending.
	 * @param mid The MID of the user to be looked up.
	 * @return A java.util.List of MessageBeans.
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getMessagesNameDescending(long mid) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs;

		conn = factory.getConnection();
		if(mid &gt;= (long) 999999999){
			ps = conn.prepareStatement(&quot;SELECT message.* FROM message, patients WHERE message.from_id=patients.mid AND message.to_id=? ORDER BY patients.lastName DESC, patients.firstName DESC, message.sent_date DESC&quot;);
			ps.setLong(1, mid);
			rs = ps.executeQuery();
		}
		else{
			ps = conn.prepareStatement(&quot;SELECT message.* FROM message, personnel WHERE message.from_id=personnel.mid AND message.to_id=? ORDER BY personnel.lastName DESC, personnel.firstName DESC, message.sent_date DESC&quot;);
			ps.setLong(1, mid);
			rs = ps.executeQuery();
		}

		List&lt;MessageBean&gt; mbList = this.mbLoader.loadList(rs);

		DBUtil.closeConnection(conn, ps);

		return mbList;
	}
	
	/**
	 * Gets all the messages from a certain user MID.
	 * @param mid The MID of the user to be looked up.
	 * @return A java.util.List of MessageBeans.
	 * @throws SQLException
	 */
	
	public List&lt;MessageBean&gt; getMessagesFrom(long mid) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;

		conn = factory.getConnection();
		ps = conn.prepareStatement(&quot;SELECT * FROM message WHERE from_id = ? ORDER BY sent_date DESC&quot;);
		ps.setLong(1, mid);
		ResultSet rs = ps.executeQuery();

		List&lt;MessageBean&gt; mbList = this.mbLoader.loadList(rs);

		DBUtil.closeConnection(conn, ps);

		return mbList;
	}
	
	/**
	 * Gets all the messages for a certain user MID sorted by ascending time.
	 * @param mid The MID of the user to be looked up.
	 * @return A java.util.List of MessageBeans.
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getMessagesFromTimeAscending(long mid) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;

		conn = factory.getConnection();
		ps = conn.prepareStatement(&quot;SELECT * FROM message WHERE from_id = ? ORDER BY sent_date ASC&quot;);
		ps.setLong(1, mid);
		ResultSet rs = ps.executeQuery();

		List&lt;MessageBean&gt; mbList = this.mbLoader.loadList(rs);

		DBUtil.closeConnection(conn, ps);

		return mbList;
	}
	
	/**
	 * Gets all the messages for a certain user MID sorted by name ascending.
	 * @param mid The MID of the user to be looked up.
	 * @return A java.util.List of MessageBeans.
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getMessagesFromNameAscending(long mid) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs;

		conn = factory.getConnection();
		if(mid &gt;= (long) 999999999){
			ps = conn.prepareStatement(&quot;SELECT message.* FROM message, patients WHERE message.to_id=patients.mid AND message.from_id=? ORDER BY patients.lastName ASC, patients.firstName ASC, message.sent_date ASC&quot;);
			ps.setLong(1, mid);
			rs = ps.executeQuery();
		}
		else{
			ps = conn.prepareStatement(&quot;SELECT message.* FROM message, personnel WHERE message.to_id=personnel.mid AND message.from_id=? ORDER BY personnel.lastName ASC, personnel.firstName ASC, message.sent_date ASC&quot;);
			ps.setLong(1, mid);
			rs = ps.executeQuery();
		}

		List&lt;MessageBean&gt; mbList = this.mbLoader.loadList(rs);

		DBUtil.closeConnection(conn, ps);

		return mbList;
	}
	
	/**
	 * Gets all the messages for a certain user MID sorted by name descending.
	 * @param mid The MID of the user to be looked up.
	 * @return A java.util.List of MessageBeans.
	 * @throws SQLException
	 */
	public List&lt;MessageBean&gt; getMessagesFromNameDescending(long mid) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs;

		conn = factory.getConnection();
		if(mid &gt;= (long) 999999999){
			ps = conn.prepareStatement(&quot;SELECT message.* FROM message, patients WHERE message.to_id=patients.mid AND message.from_id=? ORDER BY patients.lastName DESC, patients.firstName DESC, message.sent_date DESC&quot;);
			ps.setLong(1, mid);
			rs = ps.executeQuery();
		}
		else{
			ps = conn.prepareStatement(&quot;SELECT message.* FROM message, personnel WHERE message.to_id=personnel.mid AND message.from_id=? ORDER BY personnel.lastName DESC, personnel.firstName DESC, message.sent_date DESC&quot;);
			ps.setLong(1, mid);
			rs = ps.executeQuery();
		}

		List&lt;MessageBean&gt; mbList = this.mbLoader.loadList(rs);

		DBUtil.closeConnection(conn, ps);

		return mbList;
	}

	/**
	 * Adds a message to the database.
	 * @param mBean A bean representing the message to be added.
	 * @throws SQLException
	 */
	public void addMessage(MessageBean mBean) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;

		conn = factory.getConnection();
		if (mBean.getParentMessageId() == 0L) {
			ps = conn.prepareStatement(
					&quot;INSERT INTO message (from_id, to_id, sent_date, message, subject, been_read) &quot;
				  + &quot;VALUES (?, ?, NOW(), ?, ?, ?)&quot;);
			this.mbLoader.loadParameters(ps, mBean);
		} else {
			ps = conn.prepareStatement(
					&quot;INSERT INTO message (from_id, to_id, sent_date, message, subject, been_read, parent_msg_id) &quot;
				  + &quot;  VALUES (?, ?, NOW(), ?, ?, ?, ?)&quot;);
			this.mbLoader.loadParameters(ps, mBean);
		}

		ps.executeUpdate();

		DBUtil.closeConnection(conn, ps);
	}
	
	public void updateRead(MessageBean mBean) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE message SET been_read=1 WHERE message_id=?&quot;);
			ps.setLong(1, mBean.getMessageId());
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_NDCodesDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.MedicationBean;
import edu.ncsu.csc.itrust.beans.loaders.MedicationBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Used for managing the ND Codes.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * The National Drug Code (NDC) is a universal product identifier used in the
 * United States for drugs intended for human use.
 * 
 * @see http://www.fda.gov/Drugs/InformationOnDrugs/ucm142438.htm
 * @author Andy
 * 
 */
public class NDCodesDAO {
	private DAOFactory factory;
	private MedicationBeanLoader medicationLoader = new MedicationBeanLoader();

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public NDCodesDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Returns a list of all ND codes
	 * 
	 * @return A java.util.List of MedicationBeans.
	 * @throws DBException
	 */
	public List&lt;MedicationBean&gt; getAllNDCodes() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM NDCodes ORDER BY CODE&quot;);
			ResultSet rs = ps.executeQuery();
			return medicationLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a particular description for a given code.
	 * 
	 * @param code The ND code to be looked up.
	 * @return A bean representing the Medication that was looked up.
	 * @throws DBException
	 */
	public MedicationBean getNDCode(String code) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM NDCodes WHERE Code = ?&quot;);
			ps.setString(1, code);
			ResultSet rs = ps.executeQuery();
			if (rs.next())
				return medicationLoader.loadSingle(rs);
			return null;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Adds a new ND code, returns whether or not the change was made. If the code already exists, an
	 * iTrustException is thrown.
	 * 
	 * @param med The medication bean to be added.
	 * @return A boolean indicating success or failure.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public boolean addNDCode(MedicationBean med) throws DBException, iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO NDCodes (Code, Description) &quot; + &quot;VALUES (?,?)&quot;);
			ps.setString(1, med.getNDCode());
			ps.setString(2, med.getDescription());
			return (1 == ps.executeUpdate());
		} catch (SQLException e) {
			e.printStackTrace();
			if (1062 == e.getErrorCode())
				throw new iTrustException(&quot;Error: Code already exists.&quot;);
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Updates a particular code's description
	 * 
	 * @param med A bean representing the particular medication to be updated.
	 * @return An int representing the number of updated rows.
	 * @throws DBException
	 */
	public int updateCode(MedicationBean med) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE NDCodes SET Description = ? &quot; + &quot;WHERE Code = ?&quot;);
			ps.setString(1, med.getDescription());
			ps.setString(2, med.getNDCode());
			return ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_OfficeVisitDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.DiagnosisBean;
import edu.ncsu.csc.itrust.beans.LabProcedureBean;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;
import edu.ncsu.csc.itrust.beans.PrescriptionBean;
import edu.ncsu.csc.itrust.beans.PrescriptionReportBean;
import edu.ncsu.csc.itrust.beans.ProcedureBean;
import edu.ncsu.csc.itrust.beans.loaders.DiagnosisBeanLoader;
import edu.ncsu.csc.itrust.beans.loaders.OfficeVisitLoader;
import edu.ncsu.csc.itrust.beans.loaders.PrescriptionBeanLoader;
import edu.ncsu.csc.itrust.beans.loaders.PrescriptionReportBeanLoader;
import edu.ncsu.csc.itrust.beans.loaders.ProcedureBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Used for doing tasks related to office visits. Use this for linking diagnoses to office visits, and similar
 * tasks.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class OfficeVisitDAO {
	private DAOFactory factory;
	private OfficeVisitLoader officeVisitLoader = new OfficeVisitLoader();
	private DiagnosisBeanLoader diagnosisLoader = new DiagnosisBeanLoader(true);
	private PrescriptionBeanLoader prescriptionLoader = new PrescriptionBeanLoader();
	private PrescriptionReportBeanLoader prescriptionReportBeanLoader = new PrescriptionReportBeanLoader();
	private ProcedureBeanLoader procedureBeanLoader = new ProcedureBeanLoader(true);

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public OfficeVisitDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Adds an visit and return its ID
	 * 
	 * @param ov The OfficeVisitBean to be added.
	 * @return A long indicating the unique ID for the office visit.
	 * @throws DBException
	 */
	public long add(OfficeVisitBean ov) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;INSERT INTO OfficeVisits (VisitDate, Notes, HCPID, PatientID, HospitalID) VALUES (?,?,?,?,?)&quot;);
			setValues(ps, ov);
			ps.executeUpdate();
			return DBUtil.getLastInsert(conn);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	private void setValues(PreparedStatement ps, OfficeVisitBean ov) throws SQLException {
		ps.setDate(1, new java.sql.Date(ov.getVisitDate().getTime()));
		ps.setString(2, ov.getNotes());
		ps.setLong(3, ov.getHcpID());
		ps.setLong(4, ov.getPatientID());
		ps.setString(5, ov.getHospitalID());
	}

	/**
	 * Updates the information in a particular office visit.
	 * 
	 * @param ov The Office Visit bean representing the changes.
	 * @throws DBException
	 */
	public void update(OfficeVisitBean ov) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE OfficeVisits SET VisitDate=?, Notes=?, HCPID=?, &quot;
					+ &quot;PatientID=?, HospitalID=? WHERE ID=?&quot;);
			setValues(ps, ov);
			ps.setLong(6, ov.getID());
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a particular office visit given an ID
	 * 
	 * @param visitID The unique ID of the office visit.
	 * @return An OfficeVisitBean with the specifics for that office visit.
	 * @throws DBException
	 */
	public OfficeVisitBean getOfficeVisit(long visitID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;Select * From OfficeVisits Where ID = ?&quot;);
			ps.setLong(1, visitID);
			ResultSet rs = ps.executeQuery();
			if (rs.next())
				return loadFullOfficeVist(rs, visitID);
			else
				return null;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	private OfficeVisitBean loadFullOfficeVist(ResultSet rs, long visitID) throws SQLException, DBException {
		OfficeVisitBean ov = new OfficeVisitBean(visitID);
		ov.setVisitDateStr(new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).format(new Date(rs.getDate(&quot;VisitDate&quot;)
				.getTime())));
		ov.setHcpID(rs.getLong(&quot;HCPID&quot;));
		ov.setNotes(rs.getString(&quot;notes&quot;));
		ov.setPatientID(rs.getLong(&quot;PatientID&quot;));
		ov.setHospitalID(rs.getString(&quot;HospitalID&quot;));
		ov.setDiagnoses(getDiagnoses(visitID));
		ov.setPrescriptions(getPrescriptions(visitID));
		ov.setProcedures(getProcedures(visitID));

		return ov;
	}

	/**
	 * Returns all of the procedures associated with the given office visit
	 * 
	 * @param visitID The unique ID of the office visit.
	 * @return A java.util.List of procedures.
	 * @throws DBException
	 */
	public List&lt;ProcedureBean&gt; getProcedures(long visitID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		List&lt;ProcedureBean&gt; procs;
		
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;select * from ovprocedure ovp, officevisits ov, cptcodes cpt where ov.id=? and ovp.visitid=? and cpt.code=ovp.cptcode&quot;);
			ps.setLong(1, visitID);
			ps.setLong(2, visitID);
			ResultSet rs = ps.executeQuery();
			procs = procedureBeanLoader.loadList(rs);
		} 
		catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} 
		finally {
			DBUtil.closeConnection(conn, ps);
		}
		
		return procs;
	}

	
	/**
	 * Returns all of the prescriptions associated with the given office visit
	 * 
	 * @param visitID The ID of the office visit.
	 * @return A java.util.List of prescriptions.
	 * @throws DBException
	 */
	public List&lt;PrescriptionBean&gt; getPrescriptions(long visitID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;Select * From OVMedication,NDCodes Where OVMedication.VisitID = ? &quot;
					+ &quot;AND NDCodes.Code=OVMedication.NDCode&quot;);
			ps.setLong(1, visitID);
			ResultSet rs = ps.executeQuery();
			return prescriptionLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns all of the diagnoses associated with the given office visit
	 * 
	 * @param visitID The unique ID of the office visit.
	 * @return A java.util.List of diagnoses.
	 * @throws DBException
	 */
	public List&lt;DiagnosisBean&gt; getDiagnoses(long visitID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;Select * From OVDiagnosis,ICDCodes Where OVDiagnosis.VisitID = ? &quot;
					+ &quot;AND ICDCodes.Code=OVDiagnosis.ICDCode&quot;);
			ps.setLong(1, visitID);
			ResultSet rs = ps.executeQuery();
			return diagnosisLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Adds the given CPT codes to the given office visit
	 * 
	 * @param cptCode
	 * @param visitID
	 * @return
	 * @throws DBException
	 */
	public long addProcedureToOfficeVisit (String cptCode, long visitID, String hcpid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO OVProcedure (CPTCode,VisitID,HCPID) VALUES (?,?,?)&quot;);
			ps.setString(1, cptCode);
			ps.setLong(2, visitID);
			ps.setString(3, hcpid);
			ps.executeUpdate();
			return DBUtil.getLastInsert(conn);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Removes the given procedure from its office visit
	 * 
	 * @param ovProcedureID The unique ID of the office visit procedure.
	 * @throws DBException
	 */
	public void removeProcedureFromOfficeVisit(long ovProcedureID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;DELETE FROM OVProcedure WHERE ID=? &quot;);
			ps.setLong(1, ovProcedureID);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Adds a prescription bean to the database.
	 * @param pres The prescription bean to be added.
	 * @return The unique ID of the newly added bean.
	 * @throws DBException
	 */
	public long addPrescription(PrescriptionBean pres) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;INSERT INTO OVMedication (VisitID,NDCode,StartDate,EndDate,Dosage,Instructions) VALUES (?,?,?,?,?,?)&quot;);
			prescriptionLoader.loadParameters(ps, pres);
			ps.executeUpdate();
			return DBUtil.getLastInsert(conn);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	
	/**
	 * Edits an existing prescription bean.
	 * 
	 * @param pres The newly updated prescription bean.
	 * @return A long indicating the ID of the newly updated prescription bean.
	 * @throws DBException
	 */
	public long editPrescription(PrescriptionBean pres) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			//ps = conn.prepareStatement(&quot;UPDATE OVMedication (VisitID,NDCode,StartDate,EndDate,Dosage,Instructions) VALUES (?,?,?,?,?,?)&quot;);
			String statement = &quot;UPDATE OVMedication &quot; +
				&quot;SET VisitID=?, NDCode=?, StartDate=?, EndDate=?, Dosage=?, Instructions=? &quot; +
				&quot;WHERE ID=?&quot;;
			ps = conn.prepareStatement(statement);
			prescriptionLoader.loadParameters(ps, pres);
			ps.setLong(7, pres.getId());
			ps.executeUpdate();
			return DBUtil.getLastInsert(conn);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Removes the given medication from its office visit
	 * 
	 * @param ovMedicationID The unique ID of the medication to be removed.
	 * @throws DBException
	 */
	public void removePrescription(long ovMedicationID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;DELETE FROM OVMedication WHERE ID=? &quot;);
			ps.setLong(1, ovMedicationID);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Adds the given CPT codes to the given office visit
	 * @param icd A double representing the ICD code to be added.
	 * @param visitID The ID of the office visit we are adding the code to.
	 * @return A long for the new ICD code's ID.
	 * @throws DBException
	 */
	public long addDiagnosisToOfficeVisit(double icd, long visitID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO OVDiagnosis (ICDCode,VisitID) VALUES (?,?)&quot;);
			ps.setDouble(1, icd);
			ps.setLong(2, visitID);
			ps.executeUpdate();
			return DBUtil.getLastInsert(conn);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	

	/**
	 * Removes a particular diagnosis from its office visit
	 * 
	 * @param ovDiagnosisID The ID for the office visit diagnosis to be removed. 
	 * @throws DBException
	 */
	public void removeDiagnosisFromOfficeVisit(long ovDiagnosisID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;DELETE FROM OVDiagnosis WHERE ID=? &quot;);
			ps.setLong(1, ovDiagnosisID);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Adds a LOINCCode to an office visit.
	 * 
	 * @param LOINCCode A string of the code being added.
	 * @param visitID The ID of the office visit the code is being added to.
	 * @param pid The patient's MID associated with this transaction.
	 * @return The unique ID of the code that was added.
	 * @throws DBException
	 */
	public long addLabProcedureToOfficeVisit(String LOINCCode, long visitID, long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO LabProcedure (LaboratoryProcedureCode,OfficeVisitID,&quot; +
					&quot;Commentary, Results, PatientMID, Status, Rights) VALUES (?,?,?,?,?,?,?)&quot;);
			ps.setString(1, LOINCCode);
			ps.setLong(2, visitID);
			ps.setString(3, &quot;&quot;);
			ps.setString(4, &quot;&quot;);
			ps.setLong(5, pid);
			ps.setString(6, LabProcedureBean.Not_Received);
			ps.setString(7, &quot;ALLOWED&quot;);
			ps.executeUpdate();
			return DBUtil.getLastInsert(conn);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Removes a given lab procedure.
	 * 
	 * @param labProcedureID The unique ID of the lab procedure.
	 * @throws DBException
	 */
	public void removeLabProcedureFromOfficeVisit(long labProcedureID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;DELETE FROM LabProcedure WHERE LaboratoryProcedureID=?&quot;);
			ps.setLong(1, labProcedureID);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Returns whether or not an office visit actually exists
	 * 
	 * @param ovID The ID of the office visit to be checked.
	 * @param pid The MID of the patient associated with this transaction.
	 * @return A boolean indicating its existence.
	 * @throws DBException
	 */
	public boolean checkOfficeVisitExists(long ovID, long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM OfficeVisits WHERE ID=? AND PatientID=?&quot;);
			ps.setLong(1, ovID);
			ps.setLong(2, pid);
			ResultSet rs = ps.executeQuery();
			return rs.next();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a list of all office visits for a given patient
	 * 
	 * @param pid The MID of the patient in question.
	 * @return A java.util.List of OfficeVisitBeans.
	 * @throws DBException
	 */
	public List&lt;OfficeVisitBean&gt; getAllOfficeVisits(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;SELECT * FROM OfficeVisits WHERE PatientID=? ORDER BY VisitDate DESC&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return officeVisitLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Returns a list of all office visits for a given patient
	 * 
	 * @param mid The MID of the LHCP you are looking up.
	 * @return A java.util.List of Office Visits.
	 * @throws DBException
	 */
	public List&lt;OfficeVisitBean&gt; getAllOfficeVisitsForLHCP(long mid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (mid == 0L) throw new SQLException(&quot;HCPID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;SELECT * FROM OfficeVisits WHERE HCPID=? ORDER BY VisitDate DESC&quot;);
			ps.setLong(1, mid);
			ResultSet rs = ps.executeQuery();
			return officeVisitLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a list of all office visits for a given patient
	 * 
	 * @param pid The MID of the patient.
	 * @return A java.util.List of Office Visits.
	 * @throws DBException
	 */
	public List&lt;OfficeVisitBean&gt; getOfficeVisitsWithNoSurvey(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;SELECT * FROM OfficeVisits where id not in (select visitid from OVSurvey) and PatientID = ? ORDER BY VisitDate DESC&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return officeVisitLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a list of information related to prescription reports given all of the office visits and the
	 * patient ID. The patient ID is necessary in case the office visit IDs are for different patients (the
	 * disambiguation is for security reasons).
	 * 
	 * @param ovIDs A java.util.List of Longs for the office visits.
	 * @param patientID A long representing the MID of the patient in question.
	 * @return A java.util.List of prescription reports.
	 * @throws DBException
	 */
	public List&lt;PrescriptionReportBean&gt; getPrescriptionReportsByDate(long patientID, String startDate, String endDate)
			throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM NDCodes, OVMedication, OfficeVisits &quot;
					+ &quot;WHERE NDCodes.Code=OVMedication.NDCode AND OVMedication.VisitID=OfficeVisits.ID &quot;
					+ &quot;AND PatientID=? AND ((DATE(?) &lt; OVMedication.EndDate AND DATE(?) &gt; OVMedication.StartDate)&quot;
					+ &quot;OR (DATE(?) &gt; OVMedication.StartDate  AND DATE(?) &lt; OVMedication.EndDate ) OR &quot;
					+ &quot;(DATE(?) &lt;= OVMedication.StartDate AND DATE(?) &gt;= OVMedication.StartDate)) &quot;
					+ &quot;ORDER BY VisitDate DESC&quot;);
			ps.setLong(1, patientID);
			ps.setString(2, startDate);
			ps.setString(3, startDate);
			ps.setString(4, endDate);
			ps.setString(5, endDate);
			ps.setString(6, startDate);
			ps.setString(7, endDate);
			ResultSet rs = ps.executeQuery();
			return prescriptionReportBeanLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a list of information related to prescription reports given all of the office visits and the
	 * patient ID. The patient ID is necessary in case the office visit IDs are for different patients (the
	 * disambiguation is for security reasons).
	 * 
	 * @param ovIDs A java.util.List of Longs for the office visits.
	 * @param patientID A long representing the MID of the patient in question.
	 * @return A java.util.List of prescription reports.
	 * @throws DBException
	 */
	public List&lt;PrescriptionReportBean&gt; getPrescriptionReports(List&lt;Long&gt; ovIDs, long patientID)
			throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			String preps = buildPreps(ovIDs.size());
			ps = conn.prepareStatement(&quot;SELECT * FROM NDCodes, OVMedication, OfficeVisits &quot;
					+ &quot;WHERE NDCodes.Code=OVMedication.NDCode AND OVMedication.VisitID=OfficeVisits.ID &quot;
					+ &quot;AND PatientID=? AND VisitID IN(&quot; + preps + &quot;) ORDER BY VisitDate DESC&quot;);
			ps.setLong(1, patientID);
			prepareOVIDs(ps, ovIDs);
			ResultSet rs = ps.executeQuery();
			return prescriptionReportBeanLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	private void prepareOVIDs(PreparedStatement ps, List&lt;Long&gt; ovIDs) throws SQLException {
		for (int i = 0; i &lt; ovIDs.size(); i++) {
			ps.setLong(i + 2, ovIDs.get(i));
		}
	}

	private String buildPreps(int size) {
		String prep = &quot;&quot;;
		for (int i = 0; i &lt; size; i++) {
			prep += &quot;?,&quot;;
		}
		if (prep.length() &gt; 0)
			return prep.substring(0, prep.length() - 1);
		else
			return prep;
	}
	
	/**
	 * Returns a list of all office visits at a given hospital
	 * @param hospitalID the id of the hospital
	 * @return a list of the OfficeVisitBeans that hold the office visits
	 * @throws DBException in the event of a database error
	 */
	public List&lt;OfficeVisitBean&gt; getOfficeVisitsFromHospital(String hospitalID) throws DBException{
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM officevisits WHERE hospitalID = ? ORDER BY ID DESC&quot;);
			ps.setString(1, hospitalID);
			ResultSet rs = ps.executeQuery();
			return officeVisitLoader.loadList(rs);
		} catch (SQLException e){
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
		
	}
	
	/**
	 * Gets all office visits corresponding to a particular ICD diagnosis.
	 * 
	 * @param icdcode A string represnting the ICD diagnosis to look up.
	 * @return A java.util.List of Office visits.
	 * @throws DBException
	 */
	public List&lt;OfficeVisitBean&gt; getAllOfficeVisitsForDiagnosis(String icdcode) throws DBException {
		
		List&lt;DiagnosisBean&gt; diags = null;
		List&lt;OfficeVisitBean&gt; ovs = new ArrayList&lt;OfficeVisitBean&gt;();
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs= null;
		
		try {
			if (icdcode == null) 
				throw new SQLException(&quot;icdcode cannot be null&quot;);
			
			conn = factory.getConnection();
			
			ps = conn.prepareStatement(&quot;SELECT * FROM ovdiagnosis ovd, icdcodes icd WHERE ovd.ICDCode=? and icd.Code=?&quot;);
			ps.setString(1, icdcode);
			ps.setString(2, icdcode);
			rs = ps.executeQuery();
			diags = diagnosisLoader.loadList(rs);
			rs.close();
			ps.close();
			ps = null;
			rs = null;
			
			for (DiagnosisBean bean: diags) {
				ps = conn.prepareStatement(&quot;SELECT * FROM officevisits ov WHERE ov.ID=?&quot;);
				ps.setInt(1, (int)bean.getVisitID());
				rs = ps.executeQuery();
				
				if (rs.next()) {
					ovs.add(loadFullOfficeVist(rs, bean.getVisitID()));
				}
				rs.close();
				ps.close();
			}
			
			return ovs;
		
		}
		catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PatientDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Vector;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.DiagnosisBean;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.beans.PrescriptionBean;
import edu.ncsu.csc.itrust.beans.ProcedureBean;
import edu.ncsu.csc.itrust.beans.loaders.DiagnosisBeanLoader;
import edu.ncsu.csc.itrust.beans.loaders.PatientLoader;
import edu.ncsu.csc.itrust.beans.loaders.PersonnelLoader;
import edu.ncsu.csc.itrust.beans.loaders.PrescriptionBeanLoader;
import edu.ncsu.csc.itrust.beans.loaders.ProcedureBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.DateUtil;

/**
 * Used for managing all static information related to a patient. For other information related to all aspects
 * of patient care, see the other DAOs.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class PatientDAO {
	private DAOFactory factory;
	private PatientLoader patientLoader;
	private PersonnelLoader personnelLoader;
	private DiagnosisBeanLoader diagnosisLoader;
	private PrescriptionBeanLoader prescriptionLoader;
	private ProcedureBeanLoader procedureLoader;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public PatientDAO(DAOFactory factory) {
		this.factory = factory;
		this.patientLoader = new PatientLoader();
		this.personnelLoader = new PersonnelLoader();
		this.diagnosisLoader = new DiagnosisBeanLoader(true);
		this.prescriptionLoader = new PrescriptionBeanLoader();
		this.procedureLoader = new ProcedureBeanLoader(true);
	}

	/**
	 * Returns the name for the given MID
	 * 
	 * @param mid The MID of the patient in question.
	 * @return A String representing the patient's first name and last name.
	 * @throws iTrustException
	 * @throws DBException
	 */
	public String getName(long mid) throws iTrustException, DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT firstName, lastName FROM Patients WHERE MID=?&quot;);
			ps.setLong(1, mid);
			ResultSet rs;
			rs = ps.executeQuery();
			if (rs.next()) {
				return rs.getString(&quot;firstName&quot;) + &quot; &quot; + rs.getString(&quot;lastName&quot;);
			} else {
				throw new iTrustException(&quot;User does not exist&quot;);
			}
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns the role of a particular patient - why is this in PatientDAO? It should be in AuthDAO
	 * 
	 * @param mid The MID of the patient in question.
	 * @param role A String representing the role of the patient.
	 * @return A String representing the patient's role.
	 * @throws iTrustException
	 * @throws DBException
	 */
	public String getRole(long mid, String role) throws iTrustException, DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT role FROM Users WHERE MID=? AND Role=?&quot;);
			ps.setLong(1, mid);
			ps.setString(2, role);
			ResultSet rs;
			rs = ps.executeQuery();
			if (rs.next()) {
				return rs.getString(&quot;role&quot;);
			} else {
				throw new iTrustException(&quot;User does not exist with the designated role&quot;);
			}
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Adds an empty patient to the table, returns the new MID
	 * 
	 * @return The MID of the patient as a long.
	 * @throws DBException
	 */
	public long addEmptyPatient() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO Patients(MID) VALUES(NULL)&quot;);
			ps.executeUpdate();
			return DBUtil.getLastInsert(conn);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns the patient's information for a given ID
	 * 
	 * @param mid The MID of the patient to retrieve.
	 * @return A PatientBean representing the patient.
	 * @throws DBException
	 */
	public PatientBean getPatient(long mid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM Patients WHERE MID = ?&quot;);
			ps.setLong(1, mid);
			ResultSet rs = ps.executeQuery();
			// pdao.logTransaction(type, loggedInMID, secondaryMID, addedInfo)
			if (rs.next()) {
				return patientLoader.loadSingle(rs);
			} else
				return null;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Updates a patient's information for the given MID
	 * 
	 * @param p The patient bean representing the new information for the patient.
	 * @throws DBException
	 */
	public void editPatient(PatientBean p) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE Patients SET firstName=?,lastName=?,email=?,&quot;
					+ &quot;address1=?,address2=?,city=?,state=?,zip1=?, zip2=?,phone1=?,phone2=?,phone3=?,&quot;
					+ &quot;eName=?,ePhone1=?,ePhone2=?,ePhone3=?,iCName=?,iCAddress1=?,iCAddress2=?,iCCity=?,&quot;
					+ &quot;ICState=?,iCZip1=?, iCZip2=?, iCPhone1=?,iCPhone2=?,iCPhone3=?,iCID=?,DateOfBirth=?,&quot;
					+ &quot;DateOfDeath=?,CauseOfDeath=?,MotherMID=?,FatherMID=?,&quot;
					+ &quot;BloodType=?,Ethnicity=?,Gender=?,TopicalNotes=?, CreditCardType=?, CreditCardNumber=?, MessageFilter=? WHERE MID=?&quot;);
			patientLoader.loadParameters(ps, p);
			ps.setLong(40, p.getMID());
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns whether or not the patient exists
	 * 
	 * @param pid The MID of the patient in question.
	 * @return A boolean indicating whether the patient exists.
	 * @throws DBException
	 */
	public boolean checkPatientExists(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM Patients WHERE MID=?&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return rs.next();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a list of HCPs who are declared by the given patient
	 * 
	 * @param pid The MID of the patient in question.
	 * @return A java.util.List of Personnel Beans.
	 * @throws DBException
	 */
	public List&lt;PersonnelBean&gt; getDeclaredHCPs(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (pid == 0L) throw new SQLException(&quot;pid cannot be 0&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM DeclaredHCP, Personnel &quot;
					+ &quot;WHERE PatientID=? AND Personnel.MID=DeclaredHCP.HCPID&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return personnelLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Declares an HCP for a particular patient
	 * 
	 * @param pid The MID of the patient in question.
	 * @param hcpID The HCP's MID.
	 * @return A boolean as to whether the insertion was successful.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public boolean declareHCP(long pid, long hcpID) throws DBException, iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO DeclaredHCP(PatientID, HCPID) VALUES(?,?)&quot;);
			ps.setLong(1, pid);
			ps.setLong(2, hcpID);
			return 1 == ps.executeUpdate();
		} catch (SQLException e) {
			if (1062 == e.getErrorCode())
				throw new iTrustException(&quot;HCP &quot; + hcpID + &quot; has already been declared for patient &quot; + pid);
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Undeclare an HCP for a given patient
	 * 
	 * @param pid The MID of the patient in question.
	 * @param hcpID The MID of the HCP in question.
	 * @return A boolean indicating whether the action was successful.
	 * @throws DBException
	 */
	public boolean undeclareHCP(long pid, long hcpID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;DELETE FROM DeclaredHCP WHERE PatientID=? AND HCPID=?&quot;);
			ps.setLong(1, pid);
			ps.setLong(2, hcpID);
			return 1 == ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Check if a patient has declared the given HCP
	 * 
	 * @param pid The MID of the patient in question as a long.
	 * @param hcpid The MID of the HCP in question as a long.
	 * @return
	 * @throws DBException
	 */
	public boolean checkDeclaredHCP(long pid, long hcpid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM DeclaredHCP WHERE PatientID=? AND HCPID=?&quot;);
			ps.setLong(1, pid);
			ps.setLong(2, hcpid);
			return ps.executeQuery().next();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Return a list of patients that the given patient represents
	 * 
	 * @param pid The MID of the patient in question.
	 * @return A java.util.List of PatientBeans
	 * @throws DBException
	 */
	public List&lt;PatientBean&gt; getRepresented(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT Patients.* FROM Representatives, Patients &quot;
					+ &quot;WHERE RepresenterMID=? AND RepresenteeMID=Patients.MID&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return patientLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Return a list of patients that the given patient is represented by
	 * 
	 * @param pid The MID of the patient in question.
	 * @return A java.util.List of PatientBeans.
	 * @throws DBException
	 */
	public List&lt;PatientBean&gt; getRepresenting(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT Patients.* FROM Representatives, Patients &quot;
					+ &quot;WHERE RepresenteeMID=? AND RepresenterMID=Patients.MID&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return patientLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Check if the given representer represents the representee
	 * 
	 * @param representer The MID of the representer in question.
	 * @param representee The MID of the representee in question.
	 * @return A boolean indicating whether represenation is in place.
	 * @throws DBException
	 */
	public boolean represents(long representer, long representee) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;SELECT * FROM Representatives WHERE RepresenterMID=? AND RepresenteeMID=?&quot;);
			ps.setLong(1, representer);
			ps.setLong(2, representee);
			ResultSet rs = ps.executeQuery();
			return rs.next();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Assign a representer to the representee
	 * 
	 * @param representer The MID of the representer as a long.
	 * @param representee The MID of the representee as a long.
	 * @return A boolean as to whether the insertion was correct.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public boolean addRepresentative(long representer, long representee) throws DBException, iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;INSERT INTO Representatives(RepresenterMID,RepresenteeMID) VALUES (?,?)&quot;);
			ps.setLong(1, representer);
			ps.setLong(2, representee);
			return 1 == ps.executeUpdate();
		} catch (SQLException e) {
			if (1062 == e.getErrorCode())
				throw new iTrustException(&quot;Patient &quot; + representer + &quot; already represents patient &quot;
						+ representee);
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Unassign the representation
	 * 
	 * @param representer The MID of the representer in question.
	 * @param representee The MID of the representee in question.
	 * @return A boolean indicating whether the unassignment was sucessful.
	 * @throws DBException
	 */
	public boolean removeRepresentative(long representer, long representee) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;DELETE FROM Representatives WHERE RepresenterMID=? AND RepresenteeMID=?&quot;);
			ps.setLong(1, representer);
			ps.setLong(2, representee);
			return 1 == ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Return a list of all diagnoses for a given patient
	 * 
	 * @param pid The MID of the patient in question.
	 * @return A java.util.List of Diagnoses.
	 * @throws DBException
	 */
	public List&lt;DiagnosisBean&gt; getDiagnoses(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (pid == 0L) throw new SQLException(&quot;pid cannot be 0&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM OVDiagnosis ovd, OfficeVisits ov, ICDCodes icd &quot;
					+ &quot;WHERE ovd.VisitID=ov.ID and icd.Code=ovd.ICDCode and ov.PatientID=? &quot;
					+ &quot;ORDER BY ov.visitDate DESC&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return diagnosisLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
 
	/**
	 * Return a list of all procedures for a given patient
	 * 
	 * @param pid The MID of the patient in question.
	 * @return A java.util.List of all the procedures.
	 * @throws DBException
	 */
	public List&lt;ProcedureBean&gt; getProcedures(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (pid == 0L) throw new SQLException(&quot;pid cannot be 0&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;Select * From OVProcedure ovp, OfficeVisits ov, CPTCodes cpt &quot;
					+ &quot;Where ovp.VisitID=ov.ID and cpt.code=ovp.cptcode and ov.patientID=? &quot;
					+ &quot;ORDER BY ov.visitDate desc&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return procedureLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Return a list of all immunization procedures for a given patient
	 * 
	 * @param pid The MID of the patient in question.
	 * @return A java.util.List of the procedures.
	 * @throws DBException
	 */
	public List&lt;ProcedureBean&gt; getImmunizationProcedures(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (pid == 0L) throw new SQLException(&quot;pid cannot be 0&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;Select * From OVProcedure ovp, OfficeVisits ov, CPTCodes cpt &quot;
					+ &quot;Where ovp.VisitID=ov.ID and cpt.code=ovp.cptcode and ov.patientID=? and cpt.attribute='immunization'&quot;
					+ &quot;ORDER BY ov.visitDate desc&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return procedureLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	
	/**
	 * Return a list of all prescriptions for a patient
	 * 
	 * @param patientID The MID of the patient in question.
	 * @return A java.util.List of prescriptions.
	 * @throws DBException
	 */
	public List&lt;PrescriptionBean&gt; getPrescriptions(long patientID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (patientID == 0L) throw new SQLException(&quot;pid cannot be 0&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;Select * From OVMedication,NDCodes,OfficeVisits &quot;
					+ &quot;Where OfficeVisits.PatientID = ? AND OVMedication.VisitID = &quot;
					+ &quot;OfficeVisits.ID AND NDCodes.Code=OVMedication.NDCode &quot;
					+ &quot;ORDER BY OfficeVisits.visitDate DESC, OVMedication.NDCode ASC;&quot;);
			ps.setLong(1, patientID);
			ResultSet rs = ps.executeQuery();
			return prescriptionLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Return a list of prescriptions which are currently prescribed for a patient
	 * 
	 * @param patientID The MID of the patient in question.
	 * @return A java.util.List of prescription beans.
	 * @throws DBException
	 */
	public List&lt;PrescriptionBean&gt; getCurrentPrescriptions(long patientID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (patientID == 0L) throw new SQLException(&quot;pid cannot be 0&quot;);
			conn = factory.getConnection();
			
			ps = conn.prepareStatement(&quot;Select * From OVMedication,NDCodes,OfficeVisits &quot;
					+ &quot;Where OfficeVisits.PatientID = ? AND OVMedication.VisitID = &quot;
					+ &quot;OfficeVisits.ID AND NDCodes.Code=OVMedication.NDCode AND &quot;
					+ &quot;OVMedication.EndDate &gt;= ?&quot; + &quot;ORDER BY OVMedication.ID DESC;&quot;);
			ps.setLong(1, patientID);
			ps.setDate(2, DateUtil.getSQLdateXDaysAgoFromNow(91));
			ResultSet rs = ps.executeQuery();
			return prescriptionLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Return a list of prescriptions which are expired prescription for a patient
	 * 
	 * @param patientID The MID of the patient in question.
	 * @return A java.util.List of prescriptions.
	 * @throws DBException
	 **/
	 
	public List&lt;PrescriptionBean&gt; getExpiredPrescriptions (long patientID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (patientID == 0L) throw new SQLException(&quot;pid cannot be 0&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;Select * From OVMedication,NDCodes,OfficeVisits &quot;
					+ &quot;Where OfficeVisits.PatientID = ? AND OVMedication.VisitID = &quot;
					+ &quot;OfficeVisits.ID AND NDCodes.Code=OVMedication.NDCode AND &quot;
					+ &quot;OVMedication.EndDate &lt; ?&quot; + &quot;ORDER BY OVMedication.ID DESC;&quot;);
			ps.setLong(1, patientID);
			ps.setDate(2, DateUtil.getSQLdateXDaysAgoFromNow(0));
			ResultSet rs = ps.executeQuery();
			return prescriptionLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Lists every patient in the database.
	 * 
	 * @return A java.util.List of PatientBeans representing the patients.
	 * @throws DBException
	 */
	public List&lt;PatientBean&gt; getAllPatients() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM patients &quot;);
			ResultSet rs = ps.executeQuery();
			return patientLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Return a list of patients with a special-diagnosis-history who
	 * have the logged in HCP as a DHCP and whose medications are going to
	 * expire within seven days.
	 * 
	 * @param hcpMID The MID of the logged in HCP
	 * @return A list of patients satisfying the conditions.
	 * @throws DBException
	 */
	public List&lt;PatientBean&gt; getRenewalNeedsPatients(long hcpMID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			
				
				ps = conn.prepareStatement(&quot;SELECT * FROM ( &quot; + 

				&quot;SELECT DISTINCT patients.* From patients, declaredhcp, ovdiagnosis, officevisits, ovmedication &quot; + 
				&quot;Where &quot; + 
				
				&quot;declaredHCP.HCPID = ? AND &quot; + 
				&quot;patients.MID = declaredhcp.PatientID AND &quot; + 
				
				
				&quot;( &quot; + 
				&quot;ovdiagnosis.VisitID = officevisits.ID AND officevisits.PatientID = declaredhcp.PatientID &quot; + 
				&quot;AND &quot; + 
				
				&quot;((ovdiagnosis.ICDCode &gt;= ? AND ovdiagnosis.ICDCode &lt; ?) &quot; + 
				&quot;OR (ovdiagnosis.ICDCode &gt;= ? AND ovdiagnosis.ICDCode &lt; ?) &quot; + 
				&quot;OR (ovdiagnosis.ICDCode &gt;= ? AND ovdiagnosis.ICDCode &lt; ?)) &quot; + 
				&quot;) &quot; + 
				
				
				
				&quot;UNION ALL &quot; + 
				
				
				&quot;SELECT DISTINCT patients.* From patients, declaredhcp, ovdiagnosis, officevisits, ovmedication &quot; + 
				&quot;Where &quot; + 
				
				&quot;declaredHCP.HCPID = ? AND &quot; + 
				&quot;patients.MID = declaredhcp.PatientID AND &quot; + 
				
				&quot;( &quot; + 
				&quot;declaredhcp.PatientID = officevisits.PatientID AND officevisits.ID = ovmedication.VisitID &quot; + 
				&quot;AND &quot; + 
				&quot;ovmedication.EndDate BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 7 DAY) &quot; + 
				&quot;) &quot; + 
				
				&quot;) AS final &quot; + 
				
				&quot;GROUP BY final.MID HAVING COUNT(*) = 2 &quot; + 
				
				&quot;ORDER BY final.lastname ASC, final.firstname ASC&quot;); 
			
			ps.setLong(1, hcpMID);
			
			ps.setFloat(2, 250.0f);
			ps.setFloat(3, 251.0f);
				
			ps.setFloat(4, 493.0f);
			ps.setFloat(5, 494.0f);
			
			ps.setFloat(6, 390.0f);
			ps.setFloat(7, 460.99f);

			ps.setLong(8, hcpMID);
			
			ResultSet rs = ps.executeQuery();
			return patientLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Returns all patients with names &quot;LIKE&quot; (as in SQL) the passed in parameters.
	 * 
	 * @param first The patient's first name.
	 * @param last The patient's last name.
	 * @return A java.util.List of PatientBeans.
	 * @throws DBException
	 */
	public List&lt;PatientBean&gt; searchForPatientsWithName(String first, String last) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		
		if (first.equals(&quot;%&quot;) &amp;&amp; last.equals(&quot;%&quot;)) return new Vector&lt;PatientBean&gt;();
		
		try {
			conn = factory.getConnection();
			
			ps = conn.prepareStatement(&quot;SELECT * FROM patients WHERE firstName LIKE ? AND lastName LIKE ?&quot;);
			ps.setString(1, first);
			ps.setString(2, last);
			ResultSet rs = ps.executeQuery();
			return patientLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PersonnelDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Vector;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.HospitalBean;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.beans.PrescriptionBean;
import edu.ncsu.csc.itrust.beans.loaders.HospitalBeanLoader;
import edu.ncsu.csc.itrust.beans.loaders.PersonnelLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;
import edu.ncsu.csc.itrust.enums.Role;


/**
 * Used for managing information related to personnel: HCPs, UAPs, Admins
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class PersonnelDAO {
	private DAOFactory factory;
	private PersonnelLoader personnelLoader;
	private HospitalBeanLoader hospitalBeanLoader;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public PersonnelDAO(DAOFactory factory) {
		this.factory = factory;
		personnelLoader = new PersonnelLoader();
		hospitalBeanLoader = new HospitalBeanLoader();
	}

	/**
	 * Returns the name for a given MID
	 * 
	 * @param mid The MID of the personnel in question.
	 * @return A String representing the name of the personnel.
	 * @throws iTrustException
	 * @throws DBException
	 */
	public String getName(long mid) throws iTrustException, DBException {
		Connection conn = null;
		PreparedStatement pstmt = null;
		try {
			conn = factory.getConnection();
			pstmt = conn.prepareStatement(&quot;SELECT firstName, lastName FROM Personnel WHERE MID=?&quot;);
			pstmt.setLong(1, mid);
			ResultSet rs;

			rs = pstmt.executeQuery();
			if (rs.next()) {
				return rs.getString(&quot;firstName&quot;) + &quot; &quot; + rs.getString(&quot;lastName&quot;);
			} else {
				throw new iTrustException(&quot;User does not exist&quot;);
			}
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, pstmt);
		}
	}

	/**
	 * Adds an empty personnel, and returns the MID.
	 * 
	 * @return A long indicating the new MID.
	 * @param role A {@link Role} enum indicating the personnel's specific role.
	 * @throws DBException
	 * @throws iTrustException
	 */
	public long addEmptyPersonnel(Role role) throws DBException, iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		long newID;

		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO Personnel(Role) VALUES(?)&quot;);
			ps.setString(1, role.name());
			ps.executeUpdate();
			newID = DBUtil.getLastInsert(conn);
			return newID;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Retrieves a PersonnelBean with all of the specific information for a given employee.
	 * 
	 * @param mid The MID of the personnel in question.
	 * @return A PersonnelBean representing the employee.
	 * @throws DBException
	 */
	public PersonnelBean getPersonnel(long mid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM Personnel WHERE MID = ?&quot;);
			ps.setLong(1, mid);
			ResultSet rs = ps.executeQuery();
			if (rs.next()) {
				return personnelLoader.loadSingle(rs);
			} else
				return null;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Updates the demographics for a personnel.
	 * 
	 * @param p The personnel bean with the updated information.
	 * @throws DBException
	 */
	public void editPersonnel(PersonnelBean p) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE Personnel SET AMID=?,firstName=?,lastName=?,&quot;
					+ &quot;phone1=?,phone2=?,phone3=?, address1=?,address2=?,city=?, state=?, zip=?, zip1=?, zip2=?, email=?, MessageFilter=?&quot;
					+ &quot; WHERE MID=?&quot;);
			personnelLoader.loadParameters(ps, p);
			ps.setLong(16, p.getMID());
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Indicates whether a certain personnel is in the database.
	 * 
	 * @param pid The MID of the personnel in question.
	 * @return A boolean indicating whether this personnel exists.
	 * @throws DBException
	 */
	public boolean checkPersonnelExists(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM Personnel WHERE MID=?&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return rs.next();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns all of the hospitals this LHCP is associated with.
	 * 
	 * @param mid The MID of the personnel in question.
	 * @return A java.util.List of HospitalBeans.
	 * @throws DBException
	 */
	public List&lt;HospitalBean&gt; getHospitals(long mid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM HCPAssignedHos hah,Hospitals h &quot;
					+ &quot;WHERE hah.HCPID=? AND hah.HosID=h.HospitalID ORDER BY HospitalName ASC&quot;);
			ps.setLong(1, mid);
			ResultSet rs = ps.executeQuery();
			return hospitalBeanLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	
	
	/**
	 * Returns all personnel in the database.
	 * 
	 * @return A java.util.List of personnel.
	 * @throws DBException
	 */
	public List&lt;PersonnelBean&gt; getAllPersonnel() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM personnel where role in ('hcp','uap','er') &quot;);
			ResultSet rs = ps.executeQuery();
			return personnelLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a list of UAPs who work for this LHCP.
	 * 
	 * @param hcpid The MID of the personnel in question.
	 * @return A java.util.List of UAPs.
	 * @throws DBException
	 */
	public List&lt;PersonnelBean&gt; getUAPsForHCP(long hcpid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM Personnel WHERE MID IN (SELECT UAP FROM HCPRelations WHERE HCP=?)&quot;);
			ps.setLong(1, hcpid);
			ResultSet rs = ps.executeQuery();
			return personnelLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Given a prescription that has been given, this method returns all the information for the
	 * doctor who authorized that prescription.
	 * 
	 * @param prescription The PrescriptionBean describing the prescription in question.
	 * @return The PersonnelBean describing the doctor who authorized it.
	 * @throws DBException
	 */
	public PersonnelBean getPrescribingDoctor(PrescriptionBean prescription) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM Personnel WHERE MID IN (SELECT HCPID FROM OfficeVisits WHERE ID=?)&quot;);
			ps.setLong(1, prescription.getVisitID());
			ResultSet rs = ps.executeQuery();
			return personnelLoader.loadList(rs).get(0);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Matches all personnel who have names LIKE (as in SQL) the first and last names passed in.
	 * 
	 * @param first The first name to be searched for.
	 * @param last The last name to be searched for.
	 * @return A java.util.List of personnel who match these names.
	 * @throws DBException
	 */
	public List&lt;PersonnelBean&gt; searchForPersonnelWithName(String first, String last) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		
		if (first.equals(&quot;%&quot;) &amp;&amp; last.equals(&quot;%&quot;)) return new Vector&lt;PersonnelBean&gt;();
		
		try {
			conn = factory.getConnection();
			
			ps = conn.prepareStatement(&quot;SELECT * FROM personnel WHERE firstName LIKE ? AND lastName LIKE ?&quot;);
			ps.setString(1, first);
			ps.setString(2, last);
			ResultSet rs = ps.executeQuery();
			return personnelLoader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ReferralDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.ReferralBean;
import edu.ncsu.csc.itrust.beans.loaders.ReferralBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Used to update referrals, and fetch lists of referrals sent to and
 * from HCPs.
 *
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 */
public class ReferralDAO {
	private DAOFactory factory;
	private ReferralBeanLoader referralLoader;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public ReferralDAO(DAOFactory factory) {
		this.factory = factory;
		referralLoader = new ReferralBeanLoader();
	}

	

	/**
	 * Gets a list of all referrals sent from an HCP
	 * @param mid The HCP's mid.
	 * @return The list of the referrals they sent.
	 * @throws DBException
	 */
	public List&lt;ReferralBean&gt; getReferralsSentFrom(long mid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM referrals WHERE SenderID = ?&quot;);
			ps.setLong(1, mid);
			ResultSet rs = ps.executeQuery();
			
			
			return referralLoader.loadList(rs);
			
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	
	/**
	 * Gets a list of all referrals sent to an HCP
	 * @param mid The HCP's mid.
	 * @return The list of the referrals sent to them.
	 * @throws DBException
	 */
	public List&lt;ReferralBean&gt; getReferralsSentTo(long mid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM referrals WHERE ReceiverID = ?&quot;);
			ps.setLong(1, mid);
			ResultSet rs = ps.executeQuery();
			
			
			return referralLoader.loadList(rs);
			
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}


	/**
	 * Updates a given referral in the database.
	 * @param r The referral to update.
	 * @throws DBException
	 */
	public void editReferral(ReferralBean r) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE referrals SET PatientID=?,SenderID=?,ReceiverID=?,&quot;
					+ &quot;ReferralDetails=?,ConsultationDetails=?,Status=?  WHERE ID=?&quot;);
			referralLoader.loadParameters(ps, r);
			ps.setLong(7, r.getId());
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Adds a given referral to the database.
	 * @param r The referral to add.
	 * @throws DBException
	 */
	public void addReferral(ReferralBean r) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO referrals (PatientID,SenderID,ReceiverID,&quot;
					+ &quot;ReferralDetails,ConsultationDetails,Status)  &quot;
					+ &quot;VALUES (?,?,?,?,?,?)&quot;);
			referralLoader.loadParameters(ps, r);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_RemoteMonitoringDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.util.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.RemoteMonitoringDataBean;
import edu.ncsu.csc.itrust.beans.loaders.RemoteMonitoringDataBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.iTrustException;

/**
 * Used for the keeping track of remote monitoring data.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 */
public class RemoteMonitoringDAO {
	private DAOFactory factory;
	private RemoteMonitoringDataBeanLoader loader = new RemoteMonitoringDataBeanLoader();

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public RemoteMonitoringDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Returns patient data for a given HCP
	 * 
	 * @return
	 * @throws DBException
	 */
	public List&lt;RemoteMonitoringDataBean&gt; getPatientsData(long loggedInMID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM RemoteMonitoringLists WHERE HCPMID=? ORDER BY PatientMID&quot;);
			ps.setLong(1, loggedInMID);
			ResultSet patientRS = ps.executeQuery();
			ps = conn.prepareStatement(&quot;SELECT * FROM RemoteMonitoringData WHERE timelogged &gt;= CURRENT_DATE ORDER BY PatientID, timeLogged DESC&quot;);
			ResultSet dataRS = ps.executeQuery();
			
			List&lt;String&gt; patientList = new ArrayList&lt;String&gt;();
			while(patientRS.next()) {
				patientList.add(patientRS.getLong(&quot;PatientMID&quot;) + &quot;&quot;);
			}
			List&lt;RemoteMonitoringDataBean&gt; dataList = loader.loadList(dataRS);			
			
			int i, j;
			//Go through all patients and remove any that aren't monitored by this HCP
			for(i = 0; i &lt; dataList.size(); i++) {
				if(!patientList.contains(dataList.get(i).getPatientMID() + &quot;&quot;)) {
					dataList.remove(i);
					i--;
				}
			}
			
			//Add values in patient list with no data for today to list.
			boolean itsThere;
			for(i = 0; i &lt; patientList.size(); i++) {
				itsThere = false;
				for(j = 0; j &lt; dataList.size(); j++) {
					if((dataList.get(j).getPatientMID() + &quot;&quot;).equals(patientList.get(i))) {
						itsThere = true;
						break;
					}
				}
				if(!itsThere) {
					dataList.add(new RemoteMonitoringDataBean(Long.parseLong(patientList.get(i))));
				}
			}
			
			return dataList;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	public List&lt;RemoteMonitoringDataBean&gt; getPatientDataByDate(long patientMID, Date lower, Date upper) throws DBException{
		Connection conn = null;
		PreparedStatement ps = null;
		try{
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM remotemonitoringdata WHERE PatientID=? AND timeLogged &gt;= ? AND timeLogged &lt;= ? ORDER BY timeLogged DESC&quot;);
			ps.setLong(1, patientMID);
			ps.setTimestamp(2, new Timestamp(lower.getTime()));
			// add 1 day's worth to include the upper
			ps.setTimestamp(3, new Timestamp(upper.getTime() + 1000L * 60L * 60 * 24L));
			ResultSet rs = ps.executeQuery();
			List&lt;RemoteMonitoringDataBean&gt; dataList = loader.loadList(rs);
			return dataList;
		}catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Store data for a given patient in the RemoteMonitoringData table
	 * 
	 * @param patientMID The MID of the patient
	 * @param systolicBloodPressure The systolic blood pressure of the patient
	 * @param diastolicBloodPressure The diastolic blood pressure of the patient
	 * @param glucoseLevel The glucose level of the patient
	 * @param reporterRole  The role of the person that reported these monitoring stats
	 * @param reporterMID  The MID of the person that reported these monitoring stats
	 * @throws DBException
	 */
	public void storePatientData(long patientMID, int systolicBloodPressure, int diastolicBloodPressure, int glucoseLevel, String reporterRole, long reporterMID)
			throws DBException, iTrustException {
		if(getNumberOfDailyEntries(patientMID) &gt;= 10)
			throw new iTrustException(&quot;Patient entries for today cannot exceed 10.&quot;);
		
		if(reporterRole.equals(&quot;patient representative&quot;))
			validatePR(reporterMID, patientMID);
		
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO RemoteMonitoringData(PatientID, systolicBloodPressure, &quot;
					+ &quot;diastolicBloodPressure, glucoseLevel, ReporterRole, ReporterID) VALUES(?,?,?,?,?,?)&quot;);
			ps.setLong(1, patientMID);
			ps.setLong(2, systolicBloodPressure);
			ps.setInt(3, diastolicBloodPressure);
			ps.setInt(4, glucoseLevel);
			ps.setString(5, reporterRole);
			ps.setLong(6, reporterMID);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Store data for a given patient in the RemoteMonitoringData table
	 * 
	 * @param patientMID The MID of the patient
	 * @param systolicBloodPressure The systolic blood pressure of the patient
	 * @param diastolicBloodPressure The diastolic blood pressure of the patient
	 * @param glucoseLevel The glucose level of the patient
	 * @param reporterRole  The role of the person that reported these monitoring stats
	 * @param reporterMID  The MID of the person that reported these monitoring stats
	 * @throws DBException
	 */
	public void storePatientData(long patientMID, int glucoseLevel, String reporterRole, long reporterMID)
			throws DBException, iTrustException {
		if(getNumberOfDailyEntries(patientMID) &gt;= 10)
			throw new iTrustException(&quot;Patient entries for today cannot exceed 10.&quot;);
		
		if(reporterRole.equals(&quot;patient representative&quot;))
			validatePR(reporterMID, patientMID);
		
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO RemoteMonitoringData(PatientID, glucoseLevel, ReporterRole, ReporterID) VALUES(?,?,?,?)&quot;);
			ps.setLong(1, patientMID);
			ps.setInt(2, glucoseLevel);
			ps.setString(3, reporterRole);
			ps.setLong(4, reporterMID);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Store data for a given patient in the RemoteMonitoringData table
	 * 
	 * @param patientMID The MID of the patient
	 * @param systolicBloodPressure The systolic blood pressure of the patient
	 * @param diastolicBloodPressure The diastolic blood pressure of the patient
	 * @param glucoseLevel The glucose level of the patient
	 * @param reporterRole  The role of the person that reported these monitoring stats
	 * @param reporterMID  The MID of the person that reported these monitoring stats
	 * @throws DBException
	 */
	public void storePatientData(long patientMID, int systolicBloodPressure, int diastolicBloodPressure, String reporterRole, long reporterMID)
			throws DBException, iTrustException {
		if(getNumberOfDailyEntries(patientMID) &gt;= 10)
			throw new iTrustException(&quot;Patient entries for today cannot exceed 10.&quot;);
		
		if(reporterRole.equals(&quot;patient representative&quot;))
			validatePR(reporterMID, patientMID);
		
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO RemoteMonitoringData(PatientID, systolicBloodPressure, &quot;
					+ &quot;diastolicBloodPressure, ReporterRole, ReporterID) VALUES(?,?,?,?,?)&quot;);
			ps.setLong(1, patientMID);
			ps.setLong(2, systolicBloodPressure);
			ps.setInt(3, diastolicBloodPressure);
			ps.setString(4, reporterRole);
			ps.setLong(5, reporterMID);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Private method to get the number of entries for a certain patientID for today.
	 * @param patientMID
	 * @return the number of entries
	 * @throws DBException
	 */
	private int getNumberOfDailyEntries(long patientMID) throws DBException{
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM RemoteMonitoringData WHERE PatientID=? AND DATE(timeLogged)=CURRENT_DATE&quot;);
			ps.setLong(1, patientMID);
			ResultSet rs = ps.executeQuery();
			List&lt;RemoteMonitoringDataBean&gt; patients = loader.loadList(rs);
			return patients.size();
			
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	public void validatePR(long representativeMID, long patientMID)
			throws iTrustException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM Representatives WHERE RepresenterMID=? AND RepresenteeMID=?&quot;);
			ps.setLong(1, representativeMID);
			ps.setLong(2, patientMID);
			ResultSet rs = ps.executeQuery();
			if(!rs.next()) //no rows
				throw new iTrustException(&quot;Representer is not valid for patient &quot; + patientMID);
			
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Add a patient to the list of HCPs' monitoring lists of Patients
	 * 
	 * @param patientMID The MID of the patient
	 * @param HCPMID The MID of the HCP
	 * @return true if added successfully, false if already in list
	 */
	public boolean addPatientToList(long patientMID, long HCPMID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM RemoteMonitoringLists WHERE PatientMID = ? AND HCPMID = ?&quot;);
			ps.setLong(1, patientMID);
			ps.setLong(2, HCPMID);
			ResultSet rs = ps.executeQuery();
			if(rs.next())
				return false;
			ps = conn.prepareStatement(&quot;INSERT INTO RemoteMonitoringLists(PatientMID, HCPMID) VALUES(?,?)&quot;);
			ps.setLong(1, patientMID);
			ps.setLong(2, HCPMID);
			ps.executeUpdate();
			return true;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Remove a patient from the list of HCPs' monitoring lists of Patients
	 * 
	 * @param patientMID The MID of the patient
	 * @param HCPMID The MID of the HCP
	 * @return true if removed successfully, false if not in list
	 */
	public boolean removePatientFromList(long patientMID, long HCPMID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			/*ps = conn.prepareStatement(&quot;SELECT * FROM RemoteMonitoringList WHERE PatientMID = ? AND HCPMID = ?&quot;);
			ps.setLong(1, patientMID);
			ps.setLong(2, HCPMID);
			ResultSet rs = ps.executeQuery();
			if(!rs.next())
				return false;*/
			ps = conn.prepareStatement(&quot;DELETE FROM RemoteMonitoringLists WHERE PatientMID = ? AND HCPMID = ?&quot;);
			ps.setLong(1, patientMID);
			ps.setLong(2, HCPMID);
			if(ps.executeUpdate() == 0)
				return false;
			return true;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ReportRequestDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Date;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.ReportRequestBean;
import edu.ncsu.csc.itrust.beans.loaders.ReportRequestBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Used for handling data related to report requests.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 */
public class ReportRequestDAO {
	private DAOFactory factory;
	private ReportRequestBeanLoader loader;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public ReportRequestDAO(DAOFactory factory) {
		this.factory = factory;
		loader = new ReportRequestBeanLoader();
	}
	
	/**
	 * Returns a full bean describing a given report request.
	 * 
	 * @param id The unique ID of the bean in the database.
	 * @return The bean describing this report request.
	 * @throws DBException
	 */
	public ReportRequestBean getReportRequest(long id) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (id == 0L) throw new SQLException(&quot;ID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM ReportRequests WHERE ID = ?&quot;);
			ps.setLong(1, id);
			ResultSet rs = ps.executeQuery();
			rs.next();
			return loader.loadSingle(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Returns all report requests associated with a given requester.
	 * 
	 * @param mid The MID of the personnel in question.
	 * @return A java.util.List of report requests.
	 * @throws DBException
	 */
	public List&lt;ReportRequestBean&gt; getAllReportRequestsForRequester(long mid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			if (mid == 0L) throw new SQLException(&quot;RequesterMID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM ReportRequests WHERE RequesterMID = ?&quot;);
			ps.setLong(1, mid);
			ResultSet rs = ps.executeQuery();
			return loader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns all of the report requests associated with a specific patient.
	 * 
	 * @param pid The MID of the patient in question.
	 * @return A java.util.List of report requests.
	 * @throws DBException
	 */
	public List&lt;ReportRequestBean&gt; getAllReportRequestsForPatient(long pid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			if (pid == 0L) throw new SQLException(&quot;PatientMID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM ReportRequests WHERE PatientMID = ?&quot;);
			ps.setLong(1, pid);
			ResultSet rs = ps.executeQuery();
			return loader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
//	/**
//	 * Returns every report request in the database.
//	 * @return A java.util.List of report requests.
//	 * @throws DBException
//	 */
//	public List&lt;ReportRequestBean&gt; getAllReportRequests() throws DBException {
//		Connection conn = null;
//		PreparedStatement ps = null;
//
//		try {
//			conn = factory.getConnection();
//			ps = conn.prepareStatement(&quot;SELECT * FROM ReportRequests&quot;);
//			ResultSet rs = ps.executeQuery();
//			return loader.loadList(rs);
//		} catch (SQLException e) {
//			e.printStackTrace();
//			throw new DBException(e);
//		} finally {
//			DBUtil.closeConnection(conn, ps);
//		}
//	}
	
	/**
	 * Adds a request for a report.
	 * 
	 * @param requesterMID The MID of the requester.
	 * @param patientMID The MID of the patient in question.
	 * @param date The date the request was made.
	 * @return A long of the unique ID of the report request.
	 * @throws DBException
	 */
	public long addReportRequest(long requesterMID, long patientMID, Date date) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (requesterMID == 0L) throw new SQLException(&quot;RequesterMID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO ReportRequests (ID, RequesterMID, PatientMID, RequestedDate, Status) VALUES (null,?,?,?,'Requested')&quot;);
			ps.setLong(1, requesterMID);
			ps.setLong(2, patientMID);
			ps.setTimestamp(3, new java.sql.Timestamp(date.getTime()));
			ps.executeUpdate();
			return DBUtil.getLastInsert(conn);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
//	/**
//	 * Sets the status of a request to 'Approved'
//	 * 
//	 * @param ID The unique ID of the report.
//	 * @param approverMID The MID of the person approving the request.
//	 * @param date The date the approval was made.
//	 * @throws DBException
//	 */
//	public void approveReportRequest(long ID, long approverMID, Date date) throws DBException {
//		Connection conn = null;
//		PreparedStatement ps = null;
//		try {
//			if (ID == 0L) throw new SQLException(&quot;ID cannot be null&quot;);
//			conn = factory.getConnection();
//			ps = conn.prepareStatement(&quot;UPDATE ReportRequests set ApproverMID = ?, ApprovedDate = ?, Status = 'Approved' where ID = ?&quot;);
//			ps.setLong(1, approverMID);
//			ps.setTimestamp(2, new java.sql.Timestamp(date.getTime()));
//			ps.setLong(3, ID);
//			ps.executeUpdate();
//		} catch (SQLException e) {
//			e.printStackTrace();
//			throw new DBException(e);
//		} finally {
//			DBUtil.closeConnection(conn, ps);
//		}
//	}
//
//	/**
//	 * Sets the status of a report request to 'Rejected'
//	 * 
//	 * @param ID The unique ID of the request in question.
//	 * @param approverMID The MID of the rejecter in question.
//	 * @param date The date the rejection was made.
//	 * @param comment A comment describing why the request was rejected.
//	 * @throws DBException
//	 */
//	public void rejectReportRequest(long ID, long approverMID, Date date, String comment) throws DBException {
//		Connection conn = null;
//		PreparedStatement ps = null;
//		try {
//			if (ID == 0L) throw new SQLException(&quot;ID cannot be null&quot;);
//			conn = factory.getConnection();
//			ps = conn.prepareStatement(&quot;UPDATE ReportRequests set ApproverMID = ?, ApprovedDate = ?, Status = 'Rejected', comment = ? where ID = ?&quot;);
//			ps.setLong(1, approverMID);
//			ps.setTimestamp(2, new java.sql.Timestamp(date.getTime()));
//			ps.setString(3, comment);
//			ps.setLong(4, ID);
//			ps.executeUpdate();
//		} catch (SQLException e) {
//			e.printStackTrace();
//			throw new DBException(e);
//		} finally {
//			DBUtil.closeConnection(conn, ps);
//		}
//	}
	
	/**
	 * Sets the status of a report request to 'Viewed'
	 * 
	 * @param ID The unique ID of the request in question.
	 * @param date The date the request was viewed.
	 * @throws DBException
	 */
	public void setViewed(long ID, Date date) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			if (ID == 0L) throw new SQLException(&quot;ID cannot be null&quot;);
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;UPDATE ReportRequests set ViewedDate = ?, Status = 'Viewed' where ID = ?&quot;);
			ps.setTimestamp(1, new java.sql.Timestamp(date.getTime()));
			ps.setLong(2, ID);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
		
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_RiskDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.FamilyMemberBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Used for finding risk factors for a given patient.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class RiskDAO {
	private DAOFactory factory;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public RiskDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * This method is implemented using {@link FamilyDAO} for 2 reasons: (a) definitions of family members
	 * might change, so it's better to centralize that code and (2) to make this code a little bit &quot;nicer&quot;
	 * even though it executes one query per family member. If this method gets slow, then you will need to
	 * refactor. Otherwise, let's just keep it simple...
	 * 
	 * @param patientID The MID of the patient in question.
	 * @param icdLower A double of the lower bound for the codes.
	 * @param icdUpper A double of the upper bound for the codes.
	 * @return A boolean indicating whether a family member had a match in this range.
	 * @throws DBException
	 */
	public boolean hasFamilyHistory(long patientID, double icdLower, double icdUpper) throws DBException {
		List&lt;FamilyMemberBean&gt; familyMembers = getFamilyMembers(patientID);
		for (FamilyMemberBean famMember : familyMembers) {
			if (hadPriorDiagnoses(famMember.getMid(), icdLower, icdUpper))
				return true;
		}
		return false;
	}

	private List&lt;FamilyMemberBean&gt; getFamilyMembers(long patientID) throws DBException {
		FamilyDAO famDAO = factory.getFamilyDAO();
		List&lt;FamilyMemberBean&gt; familyMembers = famDAO.getParents(patientID);
		familyMembers.addAll(famDAO.getSiblings(patientID));
		return familyMembers;
	}

	/**
	 * Returns whether or not a patient had a childhood infection for the exact, given ICD codes.
	 * 
	 * @param patientID The MID of the patient in question.
	 * @param icdCodes A parameter list of the ICD codes to match.
	 * @return A boolean indicating whether this patient had all the listed ICD codes.
	 * @throws DBException
	 */
	public boolean hadChildhoodInfection(long patientID, double... icdCodes) throws DBException {
		// Note the datediff call - this is a MySQL function that takes the difference between two
		// dates and returns that value in terms of days. 6570 days is 18 years (not counting leap years)
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM OVDiagnosis ovd, OfficeVisits ov, Patients p &quot;
					+ &quot;WHERE ovd.visitID=ov.id AND ov.patientid=p.mid AND p.mid=? &quot;
					+ &quot;AND datediff(ov.visitdate,p.dateofbirth) &lt; 6570 AND ovd.icdcode IN (&quot;
					+ createPrepared(icdCodes.length) + &quot;)&quot;);
			ps.setLong(1, patientID);
			setICDs(2, ps, icdCodes);
			return ps.executeQuery().next(); // if this query has ANY rows, then yes
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	private String createPrepared(int length) {
		String str = &quot;&quot;;
		for (int i = 0; i &lt; length; i++)
			str += &quot;?,&quot;;
		return str.substring(0, str.length() - 1);
	}

	private void setICDs(int start, PreparedStatement ps, double[] icdCodes) throws SQLException {
		for (double icdCode : icdCodes) {
			ps.setDouble(start++, icdCode);
		}
	}

	/**
	 * Returns if the patient has ever smoked in their life
	 * 
	 * @param patientID The MID of the patient in question.
	 * @return A boolean indicating whether the patient smoked.
	 * @throws DBException
	 */
	public boolean hasSmoked(long patientID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;SELECT * FROM PersonalHealthInformation WHERE PatientID=? AND Smoker=1&quot;);
			ps.setLong(1, patientID);
			return ps.executeQuery().next(); // if this query has ANY rows, then yes
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns if a patient has ever been diagnosed with the given ICD code, in the range [lower,upper)
	 * 
	 * @param patientID The MID of the patient in question.
	 * @param lowerICDCode A double of the lower ICD code.
	 * @param upperICDCode A double of the upper ICD code.
	 * @return A boolean indicating whether there was a match in the given range.
	 * @throws DBException
	 */
	public boolean hadPriorDiagnoses(long patientID, double lowerICDCode, double upperICDCode)
			throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM OVDiagnosis ovd, OfficeVisits ov, Patients p &quot;
					+ &quot;WHERE ovd.visitID=ov.id AND ov.patientid=p.mid AND p.mid=? &quot;
					+ &quot;AND ovd.icdcode&gt;=? AND ovd.icdcode&lt;?&quot;);
			ps.setLong(1, patientID);
			ps.setDouble(2, lowerICDCode);
			ps.setDouble(3, upperICDCode);
			return ps.executeQuery().next(); // if this query has ANY rows, then yes
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SurveyDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Date;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.SurveyBean;
import edu.ncsu.csc.itrust.beans.loaders.SurveyLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * A DAO for handling all Survey data.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 */
public class SurveyDAO {
	private DAOFactory factory;
	private SurveyLoader surveyLoader;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public SurveyDAO(DAOFactory factory) {
		this.factory = factory;
		this.surveyLoader = new SurveyLoader();
	}
	
	/**
	 * Insert survey data into database.
	 * @param surveyBean The Bean representing the user's responses which will be inserted.
	 * @param date The date the survey was completed.
	 */
	public void addCompletedSurvey(SurveyBean surveyBean, Date date) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO OVSurvey (VisitID, SurveyDate) VALUES (?,?)&quot;);
			ps.setLong(1, surveyBean.getVisitID());
			ps.setTimestamp(2, new java.sql.Timestamp(date.getTime()));
			ps.executeUpdate();
			if (surveyBean.getWaitingRoomMinutes() &gt; 0) {
				ps = conn.prepareStatement(&quot;update OVSurvey set WaitingRoomMinutes = ? where VisitID = ?&quot;);
				ps.setFloat(1, surveyBean.getWaitingRoomMinutes());
				ps.setLong(2, surveyBean.getVisitID());
				ps.executeUpdate();
			}
			if (surveyBean.getExamRoomMinutes() &gt; 0) {
				ps = conn.prepareStatement(&quot;update OVSurvey set ExamRoomMinutes = ? where VisitID = ?&quot;);
				ps.setFloat(1, surveyBean.getExamRoomMinutes());
				ps.setLong(2, surveyBean.getVisitID());
				ps.executeUpdate();
			}
			if (surveyBean.getVisitSatisfaction() &gt; 0) {
				ps = conn.prepareStatement(&quot;update OVSurvey set VisitSatisfaction = ? where VisitID = ?&quot;);
				ps.setFloat(1, surveyBean.getVisitSatisfaction());
				ps.setLong(2, surveyBean.getVisitID());
				ps.executeUpdate();
			}
			if (surveyBean.getTreatmentSatisfaction() &gt; 0) {
				ps = conn.prepareStatement(&quot;update OVSurvey set TreatmentSatisfaction = ? where VisitID = ?&quot;);
				ps.setFloat(1, surveyBean.getTreatmentSatisfaction());
				ps.setLong(2, surveyBean.getVisitID());
				ps.executeUpdate();
			}
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Gets survey data from the database by the office visit id. Creates an instance of an
	 * SurveyBean with data and returns it.
	 * 
	 * @param id The unique ID of the survey in question.
	 * @return A bean containing the SurveyBean.
	 * @throws DBException
	 */
	public SurveyBean getSurveyData(long id) throws DBException {

		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM OVSurvey WHERE VisitID = ?&quot;);
			ps.setLong(1, id);
			ResultSet rs = ps.executeQuery();
			rs.next();
			return surveyLoader.loadSingle(rs);

		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Has this survey been completed?
	 * 
	 * @param visitID The unique ID of the office visit we are wondering about.
	 * @return boolean indicating whether this survey is completed.
	 * @throws DBException
	 */
	public boolean isSurveyCompleted(long visitID) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT count(*) FROM OVSurvey WHERE VisitID = ?&quot;);
			ps.setLong(1, visitID);
			ResultSet rs = ps.executeQuery();
			rs.next();
			return (rs.getInt(1) == 0) ? false : true;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SurveyResultDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.SurveyResultBean;
import edu.ncsu.csc.itrust.beans.loaders.SurveyResultBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * A DAO for handling all Survey results.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 */
public class SurveyResultDAO {
	private DAOFactory factory;
	private SurveyResultBeanLoader loader;
	
	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public SurveyResultDAO(DAOFactory factory) {
		this.factory = factory;
		this.loader = new SurveyResultBeanLoader();
	}
	
	/**
	 * Returns all the survey results in the database that correspond to a particular zip code.
	 * 
	 * @param zip The zipcode we are interested in as a String.
	 * @param specialty The specialty we are interested in as a String.
	 * @return A java.util.List of SurveyResultBeans.
	 * @throws DBException
	 */
	public List&lt;SurveyResultBean&gt; getSurveyResultsForZip(String zip, String specialty) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		StringBuffer sql = new StringBuffer();
		sql.append(&quot;select p.mid, p.firstname, p.lastname, p.address1, p.address2, p.city, p.state, p.zip, p.specialty, &quot;);
		sql.append(&quot;'na' hospitalID, &quot;);
		sql.append(&quot;avg(s.WaitingRoomMinutes) AvgWaitingRoomMinutes, &quot;);
		sql.append(&quot;avg(s.ExamRoomMinutes) AvgExamRoomMinutes, &quot;);
		sql.append(&quot;avg(s.VisitSatisfaction) AvgVisitSatisfaction, &quot;);
		sql.append(&quot;avg(s.TreatmentSatisfaction) AvgTreatmentSatisfation, &quot;);
		sql.append(&quot;count(*) / &quot;);
		sql.append(&quot;	(select count(*) from personnel p1, officevisits v1 &quot;);
		sql.append(&quot;	 where v1.hcpid = p1.mid &quot;);
		sql.append(&quot;	 and substr(p1.zip,1,3) = ? &quot;);
		sql.append(&quot;	 and p1.mid = p.mid) * 100 PercentSatisfactionResults &quot;);
		sql.append(&quot;from ovsurvey s, personnel p, officevisits v &quot;);
		sql.append(&quot;where s.visitid = v.id &quot;);
		sql.append(&quot;and v.hcpid = p.mid &quot;);
		sql.append(&quot;and substr(p.zip,1,3) = ? &quot;);
		if (!specialty.equals(SurveyResultBean.ANY_SPECIALTY))
			sql.append(&quot;and specialty = ?&quot;);
		sql.append(&quot;group by p.mid, p.firstname, p.lastname, p.address1, p.address2, p.city, p.state, p.zip, hospitalID &quot;);
		if (!specialty.equals(SurveyResultBean.ANY_SPECIALTY))
			sql.append(&quot;, p.specialty &quot;);
		sql.append(&quot;order by p.mid &quot;);
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(sql.toString());
			ps.setString(1, zip.substring(0, 3));
			ps.setString(2, zip.substring(0, 3));
			if (!specialty.equals(SurveyResultBean.ANY_SPECIALTY))
				ps.setString(3, specialty);
			return loader.loadList(ps.executeQuery());

		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * Returns all the survey data associated with a given hospital and a certain specialty.
	 * 
	 * @param hospitalID The unique ID of the iTrust hospital we are querying about.
	 * @param specialty A string representing the specialty we are interested in.
	 * @return A java.util.List of SurveyResultBeans.
	 * @throws DBException
	 */
	public List&lt;SurveyResultBean&gt; getSurveyResultsForHospital(String hospitalID, String specialty) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		StringBuffer sql = new StringBuffer();
		sql.append(&quot;select p.mid, p.firstname, p.lastname, p.address1, p.address2, p.city, p.state, p.zip, p.specialty, &quot;);
		sql.append(&quot;h.hosid hospitalID, &quot;);
		sql.append(&quot;avg(s.WaitingRoomMinutes) AvgWaitingRoomMinutes, &quot;);
		sql.append(&quot;avg(s.ExamRoomMinutes) AvgExamRoomMinutes, &quot;);
		sql.append(&quot;avg(s.VisitSatisfaction) AvgVisitSatisfaction, &quot;);
		sql.append(&quot;avg(s.TreatmentSatisfaction) AvgTreatmentSatisfation, &quot;);
		sql.append(&quot;count(*) / &quot;);
		sql.append(&quot;	(select count(*) from personnel p1, officevisits v1, HCPAssignedHos h1 &quot;);
		sql.append(&quot;	 where v1.hcpid = p1.mid &quot;);
		sql.append(&quot;	 and v1.hcpid = h1.hcpid &quot;);
		sql.append(&quot;	 and h1.hosid = ? &quot;);
		sql.append(&quot;	 and p1.mid = p.mid) * 100 PercentSatisfactionResults &quot;);
		sql.append(&quot;from ovsurvey s, personnel p, officevisits v, HCPAssignedHos h &quot;);
		sql.append(&quot;where s.visitid = v.id &quot;);
		sql.append(&quot;and v.hcpid = p.mid &quot;);
		sql.append(&quot;and v.hcpid = h.hcpid &quot;);
		sql.append(&quot;and h.hosid = ? &quot;);
		if (!specialty.equals(SurveyResultBean.ANY_SPECIALTY))
			sql.append(&quot;and p.specialty = ?&quot;);
		sql.append(&quot;group by p.mid, p.firstname, p.lastname, p.address1, p.address2, p.city, p.state, p.zip, hospitalID &quot;);
		if (!specialty.equals(SurveyResultBean.ANY_SPECIALTY))
			sql.append(&quot;, p.specialty &quot;);
		sql.append(&quot;order by p.mid &quot;);
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(sql.toString());
			ps.setString(1, hospitalID);
			ps.setString(2, hospitalID);
			if (!specialty.equals(SurveyResultBean.ANY_SPECIALTY)) {
				ps.setString(3, specialty);
			}
			return loader.loadList(ps.executeQuery());

		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
		
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_TransactionDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Date;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.beans.OperationalProfile;
import edu.ncsu.csc.itrust.beans.TransactionBean;
import edu.ncsu.csc.itrust.beans.loaders.OperationalProfileLoader;
import edu.ncsu.csc.itrust.beans.loaders.TransactionBeanLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.enums.TransactionType;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Used for the logging mechanism.
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class TransactionDAO {
	private DAOFactory factory;
	private TransactionBeanLoader loader = new TransactionBeanLoader();
	private OperationalProfileLoader operationalProfileLoader = new OperationalProfileLoader();

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public TransactionDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Returns the whole transaction log
	 * 
	 * @return
	 * @throws DBException
	 */
	public List&lt;TransactionBean&gt; getAllTransactions() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT * FROM TransactionLog ORDER BY timeLogged DESC&quot;);
			ResultSet rs = ps.executeQuery();
			return loader.loadList(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Log a transaction, just giving it the person who is logged in and the type
	 * 
	 * @param type The {@link TransactionType} enum representing the type this transaction is.
	 * @param loggedInMID The MID of the user who is logged in.
	 * @throws DBException
	 */
	public void logTransaction(TransactionType type, long loggedInMID) throws DBException {
		logTransaction(type, loggedInMID, 0L, &quot;&quot;);
	}

	/**
	 * Log a transaction, with all of the info. The meaning of secondaryMID and addedInfo changes depending on
	 * the transaction type.
	 * 
	 * @param type The {@link TransactionType} enum representing the type this transaction is.
	 * @param loggedInMID The MID of the user who is logged in.
	 * @param secondaryMID Typically, the MID of the user who is being acted upon.
	 * @param addedInfo A note about a subtransaction, or specifics of this transaction (for posterity).
	 * @throws DBException
	 */
	public void logTransaction(TransactionType type, long loggedInMID, long secondaryMID, String addedInfo)
			throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;INSERT INTO TransactionLog(loggedInMID, secondaryMID, &quot;
					+ &quot;transactionCode, addedInfo) VALUES(?,?,?,?)&quot;);
			ps.setLong(1, loggedInMID);
			ps.setLong(2, secondaryMID);
			ps.setInt(3, type.getCode());
			ps.setString(4, addedInfo);
			ps.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Return a list of all transactions in which an HCP accessed the given patient's record
	 * 
	 * @param patientID The MID of the patient in question.
	 * @return A java.util.List of transactions.
	 * @throws DBException
	 */
	public List&lt;TransactionBean&gt; getAllRecordAccesses(long patientID, boolean getByRole) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;SELECT * FROM TransactionLog WHERE secondaryMID=? AND transactionCode &quot;
							+ &quot;IN(&quot; + TransactionType.patientViewableStr + &quot;) ORDER BY timeLogged DESC&quot;);
			ps.setLong(1, patientID);
			ResultSet rs = ps.executeQuery();
			List&lt;TransactionBean&gt; tbList = loader.loadList(rs);

			tbList = addAndSortRoles(tbList, patientID, getByRole);
			
			return tbList;
			
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * The Most Thorough Fetch 
	 * @param loggedInRole Role of loggedIn
	 * @param secondaryRole Role of secondary
	 * @param begin Beginning of date range
	 * @param end End of date range
	 * @param type Type of transaction
	 * @return
	 * @throws DBException
	 */
	public List&lt;TransactionBean&gt; getTransactionsFor(String loggedInRole, String secondaryRole, Date begin, Date end, TransactionType type) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			conn = factory.getConnection();
			
			
			
			if(loggedInRole.compareTo(&quot;any&quot;) == 0) {
				loggedInRole = &quot;*&quot;;
			}
			if(secondaryRole.compareTo(&quot;any&quot;) == 0) {
				secondaryRole = &quot;*&quot;;
			}
			
			ps = conn
					.prepareStatement(&quot;SELECT * FROM TransactionLog, Users  WHERE (MID=loggedInMID OR MID=secondaryMID) AND (Role=? OR Role=?) &quot;
							+ &quot; AND transactionCode=? AND timeLogged &gt;= ? AND timeLogged &lt;= ?&quot; + &quot; ORDER BY timeLogged DESC&quot;);
			ps.setString(1, loggedInRole);
			ps.setString(2, secondaryRole);
			ps.setInt(3, type.getCode());
			ps.setDate(4, begin);
			ps.setDate(5, end);
			ResultSet rs = ps.executeQuery();
			List&lt;TransactionBean&gt; tbList = loader.loadList(rs);

			//tbList = addAndSortRoles(tbList, patientID, getByRole);
			
			return tbList;
			
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Return a list of all transactions in which an HCP accessed the given patient's record, within the dates
	 * 
	 * @param patientID The MID of the patient in question.
	 * @param lower The starting date as a java.util.Date
	 * @param upper The ending date as a java.util.Date
	 * @return A java.util.List of transactions.
	 * @throws DBException
	 */
	public List&lt;TransactionBean&gt; getRecordAccesses(long patientID, java.util.Date lower, java.util.Date upper, boolean getByRole) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn
					.prepareStatement(&quot;SELECT * FROM TransactionLog WHERE secondaryMID=? AND transactionCode IN (&quot;
							+ TransactionType.patientViewableStr
							+ &quot;) &quot;
							+ &quot;AND timeLogged &gt;= ? AND timeLogged &lt;= ? ORDER BY timeLogged DESC&quot;);
			ps.setLong(1, patientID);
			ps.setTimestamp(2, new Timestamp(lower.getTime()));
			// add 1 day's worth to include the upper
			ps.setTimestamp(3, new Timestamp(upper.getTime() + 1000L * 60L * 60 * 24L));
			ResultSet rs = ps.executeQuery();
			List&lt;TransactionBean&gt; tbList = loader.loadList(rs);

			tbList = addAndSortRoles(tbList, patientID, getByRole);
			
			return tbList;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns the operation profile
	 * 
	 * @return The OperationalProfile as a bean.
	 * @throws DBException
	 */
	public OperationalProfile getOperationalProfile() throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT TransactionCode, count(transactionID) as TotalCount, &quot;
					+ &quot;count(if(loggedInMID&lt;9000000000, transactionID, null)) as PatientCount, &quot;
					+ &quot;count(if(loggedInMID&gt;=9000000000, transactionID, null)) as PersonnelCount &quot;
					+ &quot;FROM TransactionLog GROUP BY transactionCode ORDER BY transactionCode ASC&quot;);
			ResultSet rs = ps.executeQuery();
			return operationalProfileLoader.loadSingle(rs);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	/**
	 * 
	 * @param tbList
	 * @param patientID
	 * @param sortByRole
	 * @return
	 * @throws DBException
	 */
	private List&lt;TransactionBean&gt; addAndSortRoles(List&lt;TransactionBean&gt; tbList, long patientID, boolean sortByRole) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		
		try {
			conn = factory.getConnection();
			
			for(TransactionBean t : tbList) {
				
				ps = conn
						.prepareStatement(&quot;SELECT Role FROM Users WHERE MID=?&quot;);
				ps.setLong(1, t.getLoggedInMID());
				ResultSet rs = ps.executeQuery();
				String role = &quot;&quot;;
				if(rs.next())
					role = rs.getString(&quot;Role&quot;);
				if(role.equals(&quot;er&quot;))
					role = &quot;Emergency Responder&quot;;
				else if(role.equals(&quot;uap&quot;))
					role = &quot;UAP&quot;;
				else if(role.equals(&quot;hcp&quot;)) {
					role = &quot;LHCP&quot;;
					ps = conn
							.prepareStatement(&quot;SELECT PatientID FROM DeclaredHCP WHERE HCPID=?&quot;);
					ps.setLong(1, t.getLoggedInMID());
					ResultSet rs2 = ps.executeQuery();
					while(rs2.next()) {
						if (rs2.getLong(&quot;PatientID&quot;) == patientID){
							role = &quot;DLHCP&quot;;
							break;
						}
					}
				}
				else if(role.equals(&quot;patient&quot;)){
					role = &quot;Patient&quot;;
					ps = conn
							.prepareStatement(&quot;SELECT representeeMID FROM Representatives WHERE representerMID=?&quot;);
					ps.setLong(1, t.getLoggedInMID());
					ResultSet rs2 = ps.executeQuery();
					while(rs2.next()) {
						if (rs2.getLong(&quot;representeeMID&quot;) == patientID){
							role = &quot;Personal Health Representative&quot;;
							break;
						}
					}
				}
					
				t.setRole(role);
				
			}
			
			if(sortByRole){
				TransactionBean[] array = new TransactionBean[tbList.size()];
				array[0] = tbList.get(0);
				TransactionBean t;
				for(int i = 1; i &lt; tbList.size(); i++) {
					t = tbList.get(i);
					String role = t.getRole();
					int j = 0;
					while(array[j] != null &amp;&amp; role.compareToIgnoreCase(array[j].getRole()) &gt;= 0)
						j++;
					for(int k = i; k &gt; j; k--) {
						array[k] = array[k-1];
					}
					array[j] = t;
				}
				int size = tbList.size();
				for(int i = 0; i &lt; size; i++)
					tbList.set(i, array[i]);
				
			}
		
			return tbList;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}
	
	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_VisitRemindersDAO</id>
            <content>package edu.ncsu.csc.itrust.dao.mysql;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.DBUtil;
import edu.ncsu.csc.itrust.DateUtil;
import edu.ncsu.csc.itrust.beans.VisitFlag;
import edu.ncsu.csc.itrust.beans.forms.VisitReminderReturnForm;
import edu.ncsu.csc.itrust.beans.loaders.VisitReminderReturnFormLoader;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Used for queries related to patient reminders
 * 
 * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,
 * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are
 * added. DAOs can assume that all data has been validated and is correct.
 * 
 * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be
 * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC
 * connections and/or accessing other DAOs.
 * 
 * @author Andy
 * 
 */
public class VisitRemindersDAO {
	private DAOFactory factory;

	/**
	 * The typical constructor.
	 * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.
	 */
	public VisitRemindersDAO(DAOFactory factory) {
		this.factory = factory;
	}

	/**
	 * Returns a list of patients associated with a given HCP.
	 * 
	 * @param hcpid The MID of the HCP in question.
	 * @return A java.util.List of Visit Reminder Forms.
	 */
	public List&lt;VisitReminderReturnForm&gt; getPatients(long hcpid) throws DBException {
		
	
		VisitReminderReturnForm temp;
		VisitReminderReturnFormLoader loader = new VisitReminderReturnFormLoader();
		List&lt;VisitReminderReturnForm&gt; patients = new ArrayList&lt;VisitReminderReturnForm&gt;();
		
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(
					  &quot;SELECT DISTINCT&quot; 
					+ &quot;       ? as hid, &quot;
					+ &quot;       dhcp.patientid, &quot;
					+ &quot;       p.lastName, &quot;
					+ &quot;       p.firstName, &quot;
					+ &quot;       p.phone1, &quot;
					+ &quot;       p.phone2, &quot;
					+ &quot;       p.phone3 &quot;
					+ &quot;  FROM &quot;
					+ &quot;       Patients p, &quot;
					+ &quot;       declaredhcp dhcp &quot;
					+ &quot; WHERE &quot;
					+ &quot;		dhcp.hcpid = ? &quot;
					+ &quot; AND &quot;
					+ &quot;     p.MID = dhcp.patientid &quot;
					+ &quot; AND &quot;
					+ &quot;		p.dateofdeath is null &quot;
					+ &quot; AND &quot;
					+ &quot;     p.dateofbirth &gt; DATE_SUB(CURDATE(), INTERVAL 19 YEAR) &quot;
					);

			ps.setLong(1, hcpid);
			ps.setLong(2, hcpid);
			rs = ps.executeQuery();

			while (rs.next()) {
				temp = loader.loadSingle(rs);
				patients.add(temp);
			}

		}
		catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} 
		finally {
			DBUtil.closeConnection(conn, ps);
		}
		return patients;
	}


	/**
	 * Returns a list of patients who need a visit for this HCP. This means:
	 * 
	 * Alive patient, no office visit for &gt; 1 yr, diagnosed: - Diabetes: 250.xx - Asthma: 493.xx -
	 * Circulatory-System Disease: [ 390.00 , 459.99 ]
	 * 
	 * @param hcpid The MID of the HCP in question.
	 * @return A java.util.List of visit reminders.
	 */
	public List&lt;VisitReminderReturnForm&gt; getDiagnosedVisitNeeders(long hcpid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(
					  &quot;SELECT DISTINCT&quot; 
					+ &quot;       ? as hid, &quot;
					+ &quot;       ov.PatientID, &quot;
					+ &quot;       p.lastName, &quot;
					+ &quot;       p.firstName, &quot;
					+ &quot;       p.phone1, &quot;
					+ &quot;       p.phone2, &quot;
					+ &quot;       p.phone3, &quot;
					+ &quot;       ovd.ICDCode, &quot;
					+ &quot;       ov.visitDate &quot;
					+ &quot;  FROM &quot;
					+ &quot;       Patients p, &quot;
					+ &quot;       OfficeVisits ov, &quot;
					+ &quot;       OVDiagnosis ovd &quot;
					+ &quot; WHERE &quot;
					+ &quot;       p.MID = ov.PatientID &quot;
					+ &quot;   AND &quot;
					+ &quot;       ov.ID = ovd.VisitID &quot;
					+ &quot;   AND &quot;
					+ &quot;       p.DateOfDeath is null &quot;
					+ &quot;   AND &quot;
					+ &quot;       ov.visitDate &lt;= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) &quot;
					+ &quot;   AND &quot;
					+ &quot;       ( &quot;
					+ &quot;            ovd.ICDCode BETWEEN ? AND ? &quot; //250.00 AND 250.99
					+ &quot;         OR &quot;
					+ &quot;            ovd.ICDCode BETWEEN ? AND ? &quot; //390.00 AND 459.99
					+ &quot;         OR &quot;
					+ &quot;            ovd.ICDCode BETWEEN ? AND ? &quot; //493.00 AND 493.99
					+ &quot;        )&quot;
					+ &quot;GROUP BY &quot;
					+ &quot;       p.MID &quot;
					+ &quot;ORDER BY &quot;
					+ &quot; p.lastName, p.firstName, ov.PatientID &quot;);

			ps.setLong(1, hcpid);
			
			ps.setFloat(2, 250.0f);
			ps.setFloat(3, 250.99f);
				
			ps.setFloat(4, 390.0f);
			ps.setFloat(5, 459.99f);
				
			ps.setFloat(6, 493.0f);
			ps.setFloat(7, 493.99f);
			
			rs = ps.executeQuery();
			List&lt;VisitReminderReturnForm&gt; patients = new ArrayList&lt;VisitReminderReturnForm&gt;();
			VisitReminderReturnForm temp;
			VisitReminderReturnFormLoader loader = new VisitReminderReturnFormLoader();
			while (rs.next()) {
				temp = loader.loadSingle(rs);
				temp.addVisitFlag(new VisitFlag(VisitFlag.DIAGNOSED, rs.getString(8)));
				temp.addVisitFlag(new VisitFlag(VisitFlag.LAST_VISIT, rs.getString(9)));
				patients.add(temp);
			}
			return patients;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}

	/**
	 * Returns a list of old people who need a flu shot
	 * 
	 * CURRENT SPEC: Alive patient, over 50 years old, no flu shot - 90656, 90658, 90660 a) during the months
	 * 09 - 12 of current calendar year if in 09 - 12 b) during the months 09 - 12 of last calendar year if
	 * not in 09 - 12
	 * 
	 * Determines current date and calls one of two private methods these methods return different sets of
	 * people - a: people who haven't had a flu shot yet this year and need one - b: people who missed last
	 * year's flu shot and need a check-up
	 * 
	 * @return A java.util.List of Visit Reminder Forms.
	 * @param hcpid The MID of the HCP in question.
	 * @param patientBirthday The birthday of the patient in question.
	 * @throws DBException
	 */
	public List&lt;VisitReminderReturnForm&gt; getFluShotDelinquents(long hcpid) throws DBException {
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;

		/*
		 * Fall 2007 Bug Fix: Use the correct range for a zero-based calendar (eg January is 0)
		 * 
		 */
		boolean thisYear = DateUtil.currentlyInMonthRange(8, 11);

		String flagType = thisYear ? VisitFlag.MISSING_MEDICATION : VisitFlag.MISSED_MEDICATION;

		java.sql.Date september = new java.sql.Date(0l), december = new java.sql.Date(0l);
		DateUtil.setSQLMonthRange(september, 8, thisYear ? 0 : 1, december, 11, thisYear ? 0 : 1);

		try {
			conn = factory.getConnection();
			ps = conn.prepareStatement(&quot;SELECT DISTINCT &quot;
					+ &quot;? as hid, ov.patientid, p.lastname, p.firstname, &quot; + &quot;p.phone1, p.phone2, p.phone3 &quot;
					+ &quot;FROM OfficeVisits ov, Patients p &quot; + &quot;WHERE ov.patientid=p.mid &quot;
					+ &quot;AND p.dateofdeath IS NULL &quot;
					+ &quot;AND p.dateofbirth &lt; DATE_SUB(CURDATE(), INTERVAL 50 YEAR) &quot; + &quot;AND patientid NOT IN &quot;
					+ &quot;(SELECT patientid FROM OfficeVisits ov, OVMedication om &quot; + &quot;WHERE ov.id=om.visitid &quot;
					+ &quot;AND NDCode IN (90656, 90658, 90660) &quot; + &quot;AND ((StartDate BETWEEN ? AND ?) &quot;
					+ &quot;OR (EndDate BETWEEN ? AND ?))) &quot; + &quot;ORDER BY lastname, firstname, ov.patientid&quot;);
			ps.setLong(1, hcpid);
			ps.setDate(2, september);
			ps.setDate(3, december);
			ps.setDate(4, september);
			ps.setDate(5, december);
			rs = ps.executeQuery();
			List&lt;VisitReminderReturnForm&gt; patients = new ArrayList&lt;VisitReminderReturnForm&gt;();
			VisitReminderReturnForm temp;
			VisitReminderReturnFormLoader loader = new VisitReminderReturnFormLoader();
			while (rs.next()) {
				temp = loader.loadSingle(rs);
				temp.addVisitFlag(new VisitFlag(flagType, &quot;Flu Shot&quot;));
				patients.add(temp);
			}
			return patients;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new DBException(e);
		} finally {
			DBUtil.closeConnection(conn, ps);
		}
	}	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ApptBean</id>
            <content>package edu.ncsu.csc.itrust.beans;

import java.sql.Timestamp;


public class ApptBean {
	private String apptType;
	private long patient;
	private long hcp;
	private Timestamp date;
	private String comment;
	
	/**
	 * @return the apptType
	 */
	public String getApptType() {
		return apptType;
	}
	/**
	 * @param apptType the apptType to set
	 */
	public void setApptType(String apptType) {
		this.apptType = apptType;
	}
	/**
	 * @return the patient
	 */
	public long getPatient() {
		return patient;
	}
	/**
	 * @param patient the patient to set
	 */
	public void setPatient(long patient) {
		this.patient = patient;
	}
	/**
	 * @return the hcp
	 */
	public long getHcp() {
		return hcp;
	}
	/**
	 * @param hcp the hcp to set
	 */
	public void setHcp(long hcp) {
		this.hcp = hcp;
	}
	/**
	 * @return the date
	 */
	public Timestamp getDate() {
		return date;
	}
	/**
	 * @param date the date to set
	 */
	public void setDate(Timestamp date) {
		this.date = date;
	}
	/**
	 * @return the comment
	 */
	public String getComment() {
		return comment;
	}
	/**
	 * @param comment the comment to set
	 */
	public void setComment(String comment) {
		this.comment = comment;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ApptTypeBean</id>
            <content>package edu.ncsu.csc.itrust.beans;

public class ApptTypeBean {
	
	private String name;
	private int duration;
	
	public ApptTypeBean() {
		this.name = null;
		this.duration = 0;
	}
	
	public ApptTypeBean(String name, int duration) {
		this.name = name;
		this.duration = duration;
	}

	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public int getDuration() {
		return duration;
	}
	
	public void setDuration(int duration) {
		this.duration = duration;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_MedicationBean</id>
            <content>package edu.ncsu.csc.itrust.beans;

/**
 * A medication is the same thing as an ND code - it's like &quot;Aspirin&quot;. A medication is not associated with an
 * office visit; that's a &quot;prescription&quot;. See {@link PrescriptionBean}
 * 
 * @author Andy Meneely
 * 
 */
public class MedicationBean {
	private String NDCode = &quot;&quot;;
	private String description = &quot;&quot;;

	public MedicationBean() {
	}

	public MedicationBean(String code) {
		NDCode = code;
	}

	public MedicationBean(String code, String description) {
		NDCode = code;
		this.description = description;
	}

	/**
	 * Gets the ND Code for this procedure
	 * 
	 * @return The ND Code for this procedure
	 */
	public String getNDCode() {
		return NDCode;
	}

	public void setNDCode(String code) {
		NDCode = code;
	}

	/**
	 * Gets the ND Description for this procedure
	 * 
	 * @return The ND Description for this procedure
	 */
	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getNDCodeFormatted() {
		String code = getNDCode();
		if (code.length() &gt; 5)
			return code.substring(0, 5) + &quot;-&quot; + code.substring(5);
		else
			return code;
	}

	@Override
	public boolean equals(Object other) {
		return (other != null) &amp;&amp; this.getClass().equals(other.getClass())
				&amp;&amp; this.equals((MedicationBean) other);
	}

	public int hashCode() {
		assert false : &quot;hashCode not designed&quot;;
		return 42; // any arbitrary constant will do
	}

	private boolean equals(MedicationBean other) {
		return description.equals(other.description) &amp;&amp; NDCode.equals(other.NDCode);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PrescriptionReportBean</id>
            <content>package edu.ncsu.csc.itrust.beans;

/**
 * This is the container bean for the Prescription Report requirement. It contains a PrescriptionBean (which
 * in turn contains a Medication Bean), and an office visit bean. &lt;br /&gt;
 * &lt;br /&gt;
 * This was made so that the prescription report could be done all in one clean query.&lt;br /&gt;
 * &lt;br /&gt;
 * See {@link PrescriptionBean} See {@link OfficeVisitBean}
 * 
 * @author Andy Meneely
 * 
 */
public class PrescriptionReportBean {
	PrescriptionBean prescription;
	OfficeVisitBean officeVisit;

	public PrescriptionReportBean() {
	}

	public PrescriptionBean getPrescription() {
		return prescription;
	}

	public void setPrescription(PrescriptionBean prescription) {
		this.prescription = prescription;
	}

	public OfficeVisitBean getOfficeVisit() {
		return officeVisit;
	}

	public void setOfficeVisit(OfficeVisitBean officeVisit) {
		this.officeVisit = officeVisit;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SurveyResultBean</id>
            <content>package edu.ncsu.csc.itrust.beans;

/**
 * Bean to be used for survey results (search).  Stores address information about a HCP
 * in addition to their specialty, hospital, and averages from survey (results range from 1-5).  This
 * beans also contains a variable that stores the percent of office visits that satisfaction results are 
 * available.
 */
public class SurveyResultBean {

	private long hcpMID;
	private String hcpFirstName;
	private String hcpLastName;
	private String hcpAddress1;
	private String hcpAddress2;
	private String hcpCity;
	private String hcpState;
	private String hcpZip;
	private String hcpSpecialty;
	private String hcpHospitalID;
	private float avgWaitingRmMinutes;
	private float avgExamRmMinutues;
	private float avgVisitSatisfaction;
	private float avgTreatmentSatisfaction;
	private float percentSatResultsAvailable;
	
	//list of specialties
	public final static String GENERAL_SPECIALTY = &quot;General&quot;;
	public final static String SURGEON_SPECIALTY = &quot;Surgeon&quot;;
	public final static String HEART_SPECIALTY = &quot;Heart Specialist&quot;;
	public final static String PEDIATRICIAN_SPECIALTY = &quot;Pediatrician&quot;;
	public final static String OBGYN_SPECIALTY = &quot;OB/GYN&quot;;
	public final static String ANY_SPECIALTY = &quot;None&quot;;
	
	public void setHCPMID(long mid) {
		hcpMID = mid;
	}
	public long getHCPMID() {
		return hcpMID;
	}
	
	public void setHCPFirstName(String firstName) {
		this.hcpFirstName = firstName;
	}
	public String getHCPFirstName() {
		return hcpFirstName;
	}
	
	public void setHCPLastName(String lastName) {
		this.hcpLastName = lastName;
	}
	public String getHCPLastName() {
		return hcpLastName;
	}
	
	public void setHCPaddress1(String address1) {
		this.hcpAddress1 = address1;
	}
	public String getHCPaddress1() {
		return hcpAddress1;
	}
	
	public void setHCPaddress2(String address2) {
		this.hcpAddress2 = address2;
	}
	public String getHCPaddress2() {
		return hcpAddress2;
	}
	
	public void setHCPcity(String city) {
		this.hcpCity = city;
	}
	public String getHCPcity() {
		return hcpCity;
	}
	
	public void setHCPstate(String state) {
		this.hcpState = state;
	}
	public String getHCPstate() {
		return hcpState;
	}
	
	public void setHCPzip(String zip) {
		this.hcpZip = zip;
	}
	public String getHCPzip() {
		return hcpZip;
	}
	
	public void setHCPspecialty(String specialty) {
		this.hcpSpecialty = specialty;
	}
	public String getHCPspecialty() {
		return hcpSpecialty;
	}
	
	public void setHCPhospital(String hospital) {
		this.hcpHospitalID = hospital;
	}
	public String getHCPhospital() {
		return hcpHospitalID;
	}
	
	public void setAvgWaitingRoomMinutes(float waitingRoomMinutes) {
		this.avgWaitingRmMinutes = waitingRoomMinutes;
	}
	public float getAvgWaitingRoomMinutes() {
		return avgWaitingRmMinutes;
	}
	
	public void setAvgExamRoomMinutes(float examRoomMinutes) {
		this.avgExamRmMinutues = examRoomMinutes;
	}
	public float getAvgExamRoomMinutes() {
		return avgExamRmMinutues;
	}
	
	public void setAvgVisitSatisfaction(float visitSatisfaction) {
		this.avgVisitSatisfaction = visitSatisfaction;
	}
	public float getAvgVisitSatisfaction() {
		return avgVisitSatisfaction;
	}
	
	public void setAvgTreatmentSatisfaction(float treatmentSatisfaction) {
		this.avgTreatmentSatisfaction = treatmentSatisfaction;
	}
	public float getAvgTreatmentSatisfaction() {
		return avgTreatmentSatisfaction;
	}
	
	public void setPercentSatisfactionResults (float percent) {
		this.percentSatResultsAvailable= percent;
	}
	public float getPercentSatisfactionResults() {
		return percentSatResultsAvailable;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AdverseEventBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.AdverseEventBean;

/**
 * A loader for AdverseEventBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class AdverseEventBeanLoader implements BeanLoader&lt;AdverseEventBean&gt; {

	public List&lt;AdverseEventBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;AdverseEventBean&gt; list = new ArrayList&lt;AdverseEventBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public AdverseEventBean loadSingle(ResultSet rs) throws SQLException {
		AdverseEventBean adverseEvent = new AdverseEventBean();
		adverseEvent.setMID(rs.getString(&quot;PatientMID&quot;));
		adverseEvent.setDrug(rs.getString(&quot;PresImmu&quot;));
		adverseEvent.setDescription(rs.getString(&quot;Comment&quot;));
		adverseEvent.setCode(rs.getString(&quot;Code&quot;));
		adverseEvent.setDate(rs.getTimestamp(&quot;TimeLogged&quot;).toString());
		adverseEvent.setId(rs.getInt(&quot;id&quot;));
		adverseEvent.setStatus(rs.getString(&quot;Status&quot;));
		return adverseEvent;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, AdverseEventBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AllergyBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.AllergyBean;

/**
 * A loader for AllergyBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class AllergyBeanLoader implements BeanLoader&lt;AllergyBean&gt; {

	public List&lt;AllergyBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;AllergyBean&gt; list = new ArrayList&lt;AllergyBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public AllergyBean loadSingle(ResultSet rs) throws SQLException {
		AllergyBean allergy = new AllergyBean();
		allergy.setId(rs.getLong(&quot;ID&quot;));
		allergy.setPatientID(rs.getLong(&quot;PatientID&quot;));
		allergy.setDescription(rs.getString(&quot;Description&quot;));
		allergy.setFirstFound(rs.getTimestamp(&quot;FirstFound&quot;));
		return allergy;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, AllergyBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ApptBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.ApptBean;

public class ApptBeanLoader implements BeanLoader&lt;ApptBean&gt; {

	public List&lt;ApptBean&gt; loadList(ResultSet rs) throws SQLException {
		List&lt;ApptBean&gt; list = new ArrayList&lt;ApptBean&gt;();
		while (rs.next())
			list.add(loadSingle(rs));
		return list;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, ApptBean bean) throws SQLException {
		ps.setString(1, bean.getApptType());
		ps.setLong(2, bean.getPatient());
		ps.setLong(3, bean.getHcp());
		ps.setTimestamp(4, bean.getDate());
		ps.setString(5, bean.getComment());
		return ps;
	}

	public ApptBean loadSingle(ResultSet rs) throws SQLException {
		ApptBean bean = new ApptBean();
		bean.setApptType(rs.getString(&quot;appt_type&quot;));
		bean.setPatient(rs.getLong(&quot;patient_id&quot;));
		bean.setHcp(rs.getLong(&quot;doctor_id&quot;));
		bean.setDate(rs.getTimestamp(&quot;sched_date&quot;));
		bean.setComment(rs.getString(&quot;comment&quot;));
		return bean;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ApptTypeBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.ApptTypeBean;

public class ApptTypeBeanLoader implements BeanLoader&lt;ApptTypeBean&gt; {

	public List&lt;ApptTypeBean&gt; loadList(ResultSet rs) throws SQLException {
		List&lt;ApptTypeBean&gt; list = new ArrayList&lt;ApptTypeBean&gt;();
		while (rs.next())
			list.add(loadSingle(rs));
		return list;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, ApptTypeBean apptType) throws SQLException {
		ps.setString(1, apptType.getName());
		ps.setInt(2, apptType.getDuration());
		return ps;
	}

	public ApptTypeBean loadSingle(ResultSet rs) throws SQLException {
		ApptTypeBean apptType = new ApptTypeBean();
		apptType.setName(rs.getString(&quot;appt_type&quot;));
		apptType.setDuration(rs.getInt(&quot;duration&quot;));
		return apptType;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_BeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

/**
 * This interface helps enforce the paradigm of what should be contained in a loader.
 * 
 * The generic type &lt;T&gt; specifies the type of bean that the loader is responsible for extacting from
 * a result set.
 * 
 * @param &lt;T&gt; A type for the bean that will be loaded with this class.
 */
public interface BeanLoader&lt;T&gt; {
	/**
	 * Loads a list of the bean of type T from a result set.  Typically makes iterated calls
	 * to loadSingle.
	 * @param rs The java.sql.ResultSet we are extracting.
	 * @return A java.util.List&lt;T&gt; where T is the type for this loader.
	 * @throws SQLException
	 */
	public List&lt;T&gt; loadList(ResultSet rs) throws SQLException;

	/**
	 * Contains the instructions for mapping the rows in this java.sql.ResultSet into
	 * beans of type &lt;T&gt;.
	 * @param rs The java.sql.ResultSet to be loaded.
	 * @return A Bean of type T containing the loaded information, typically of the first (or next) item in the result set.
	 * @throws SQLException
	 */
	public T loadSingle(ResultSet rs) throws SQLException;

	/**
	 * Used for an insert or update, this method contains the instructions for mapping the fields within
	 * a bean of type T into a prepared statement which modifies the appropriate table.
	 * @param ps The prepared statement to be loaded.
	 * @param bean The bean containing the data to be placed.
	 * @return A prepared statement with the appropriately loaded parameters.
	 * @throws SQLException
	 */
	public PreparedStatement loadParameters(PreparedStatement ps, T bean) throws SQLException;
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_DiagnosisBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.DiagnosisBean;

/**
 * A loader for DiagnosisBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency.
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader} 
 */

public class DiagnosisBeanLoader implements BeanLoader&lt;DiagnosisBean&gt; {
	private boolean loadOVDiagnosisID = false;

	public DiagnosisBeanLoader() {
		loadOVDiagnosisID = false;
	}

	public DiagnosisBeanLoader(boolean loadOVDiagnosisID) {
		this.loadOVDiagnosisID = loadOVDiagnosisID;
	}

	public List&lt;DiagnosisBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;DiagnosisBean&gt; list = new ArrayList&lt;DiagnosisBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public DiagnosisBean loadSingle(ResultSet rs) throws SQLException {
		
		DiagnosisBean diag = new DiagnosisBean(rs.getString(&quot;Code&quot;), rs.getString(&quot;Description&quot;), rs.getString(&quot;Chronic&quot;));
		if (loadOVDiagnosisID) {
			diag.setOvDiagnosisID(rs.getInt(&quot;ID&quot;));
			diag.setVisitID(rs.getLong(&quot;VisitID&quot;));
		}
		return diag;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, DiagnosisBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_DrugInteractionBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.DrugInteractionBean;

/**
 * A loader for MedicationBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class DrugInteractionBeanLoader implements BeanLoader&lt;DrugInteractionBean&gt; {
	public DrugInteractionBeanLoader() {
	}

	public List&lt;DrugInteractionBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;DrugInteractionBean&gt; list = new ArrayList&lt;DrugInteractionBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public DrugInteractionBean loadSingle(ResultSet rs) throws SQLException {
		// MedicationBean med = new MedicationBean();
		DrugInteractionBean drugIt = new DrugInteractionBean();
		drugIt.setDescription(rs.getString(&quot;Description&quot;));
		drugIt.setFirstDrug(rs.getString(&quot;FirstDrug&quot;));
		drugIt.setSecondDrug(rs.getString(&quot;SecondDrug&quot;));
		return drugIt;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, DrugInteractionBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EmailBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import edu.ncsu.csc.itrust.beans.Email;

/**
 * A loader for Fake Emails.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class EmailBeanLoader implements BeanLoader&lt;Email&gt; {

	public List&lt;Email&gt; loadList(ResultSet rs) throws SQLException {
		List&lt;Email&gt; list = new ArrayList&lt;Email&gt;();
		while (rs.next())
			list.add(loadSingle(rs));
		return list;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, Email email) throws SQLException {
		ps.setString(1, email.getToListStr());
		ps.setString(2, email.getFrom());
		ps.setString(3, email.getSubject());
		ps.setString(4, email.getBody());
		return ps;
	}

	public Email loadSingle(ResultSet rs) throws SQLException {
		Email email = new Email();
		email.setFrom(rs.getString(&quot;FromAddr&quot;));
		email.setToList(Arrays.asList(rs.getString(&quot;ToAddr&quot;).split(&quot;,&quot;)));
		email.setBody(rs.getString(&quot;Body&quot;));
		email.setSubject(rs.getString(&quot;Subject&quot;));
		email.setTimeAdded(rs.getTimestamp(&quot;AddedDate&quot;));
		return email;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_FamilyBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.FamilyMemberBean;

/**
 * A loader for FamilyMemberBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class FamilyBeanLoader implements BeanLoader&lt;FamilyMemberBean&gt; {
	private String relation;

	public FamilyBeanLoader(String relation) {
		this.relation = relation;
	}

	public List&lt;FamilyMemberBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;FamilyMemberBean&gt; list = new ArrayList&lt;FamilyMemberBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, FamilyMemberBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

	public FamilyMemberBean loadSingle(ResultSet rs) throws SQLException {
		FamilyMemberBean fam = new FamilyMemberBean();
		fam.setRelation(relation);
		fam.setFirstName(rs.getString(&quot;FirstName&quot;));
		fam.setLastName(rs.getString(&quot;LastName&quot;));
		fam.setMid(rs.getInt(&quot;MID&quot;));
		return fam;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_HealthRecordsBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.HealthRecord;

/**
 * A loader for HealthRecords.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class HealthRecordsBeanLoader implements BeanLoader&lt;HealthRecord&gt; {
	public List&lt;HealthRecord&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;HealthRecord&gt; list = new ArrayList&lt;HealthRecord&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, HealthRecord bean) throws SQLException {
		int i = 1;
		ps.setLong(i++, bean.getPatientID());
		ps.setDouble(i++, bean.getHeight());
		ps.setDouble(i++, bean.getWeight());
		ps.setInt(i++, bean.isSmoker() ? 1 : 0);
		ps.setInt(i++, bean.getBloodPressureN());
		ps.setInt(i++, bean.getBloodPressureD());
		ps.setInt(i++, bean.getCholesterolHDL());
		ps.setInt(i++, bean.getCholesterolLDL());
		ps.setInt(i++, bean.getCholesterolTri());
		ps.setLong(i++, bean.getPersonnelID());
		return ps;
	}

	public HealthRecord loadSingle(ResultSet rs) throws SQLException {
		HealthRecord hr = new HealthRecord();
		hr.setBloodPressureN(rs.getInt(&quot;BloodPressureN&quot;));
		hr.setBloodPressureD(rs.getInt(&quot;BloodPressureD&quot;));
		hr.setCholesterolHDL(rs.getInt(&quot;CholesterolHDL&quot;));
		hr.setCholesterolLDL(rs.getInt(&quot;CholesterolLDL&quot;));
		hr.setCholesterolTri(rs.getInt(&quot;CholesterolTri&quot;));
		hr.setDateRecorded(rs.getTimestamp(&quot;AsOfDate&quot;));
		hr.setSmoker(rs.getInt(&quot;Smoker&quot;) == 1);
		hr.setHeight(rs.getDouble(&quot;Height&quot;));
		hr.setWeight(rs.getDouble(&quot;Weight&quot;));
		hr.setPersonnelID(rs.getLong(&quot;HCPID&quot;));
		hr.setPatientID(rs.getLong(&quot;PatientID&quot;));
		return hr;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_HospitalBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.HospitalBean;

/**
 * A loader for HospitalBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */

public class HospitalBeanLoader implements BeanLoader&lt;HospitalBean&gt; {
	public List&lt;HospitalBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;HospitalBean&gt; list = new ArrayList&lt;HospitalBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public HospitalBean loadSingle(ResultSet rs) throws SQLException {
		// HospitalBean hosp = new HospitalBean();
		HospitalBean hosp = new HospitalBean(rs.getString(&quot;HospitalID&quot;), rs.getString(&quot;HospitalName&quot;));
		return hosp;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, HospitalBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_LOINCBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.LOINCbean;

/**
 * A loader for LOINCBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class LOINCBeanLoader implements BeanLoader&lt;LOINCbean&gt; {
	
	public List&lt;LOINCbean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;LOINCbean&gt; list = new ArrayList&lt;LOINCbean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public LOINCbean loadSingle(ResultSet rs) throws SQLException {
		LOINCbean LOINC = new LOINCbean();
		LOINC.setLabProcedureCode(rs.getString(&quot;LaboratoryProcedureCode&quot;));
		LOINC.setComponent(rs.getString(&quot;Component&quot;));
		LOINC.setKindOfProperty(rs.getString(&quot;KindOfProperty&quot;));
		LOINC.setTimeAspect(rs.getString(&quot;TimeAspect&quot;));
		LOINC.setSystem(rs.getString(&quot;System&quot;));
		LOINC.setScaleType(rs.getString(&quot;ScaleType&quot;));
		LOINC.setMethodType(rs.getString(&quot;MethodType&quot;));
		return LOINC;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, LOINCbean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_LabProcedureBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.LabProcedureBean;

/**
 * A loader for LabProcedureBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class LabProcedureBeanLoader implements BeanLoader&lt;LabProcedureBean&gt; {
	
	public List&lt;LabProcedureBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;LabProcedureBean&gt; list = new ArrayList&lt;LabProcedureBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public LabProcedureBean loadSingle(ResultSet rs) throws SQLException {
		LabProcedureBean LabProcedure = new LabProcedureBean();
		LabProcedure.setProcedureID(rs.getLong(&quot;LaboratoryProcedureID&quot;));
		LabProcedure.setPid(rs.getLong(&quot;PatientMID&quot;));
		LabProcedure.setLoinc(rs.getString(&quot;LaboratoryProcedureCode&quot;));
		LabProcedure.setStatus(rs.getString(&quot;Status&quot;));
		LabProcedure.setCommentary(rs.getString(&quot;Commentary&quot;));
		LabProcedure.setResults(rs.getString(&quot;Results&quot;));
		LabProcedure.setOvID(rs.getLong(&quot;OfficeVisitID&quot;));
		LabProcedure.setTimestamp(rs.getTimestamp(&quot;UpdatedDate&quot;));
		LabProcedure.setRights(rs.getString(&quot;Rights&quot;));		
		return LabProcedure;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, LabProcedureBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_MedicationBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.MedicationBean;

/**
 * A loader for MedicationBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class MedicationBeanLoader implements BeanLoader&lt;MedicationBean&gt; {
	public MedicationBeanLoader() {
	}

	public List&lt;MedicationBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;MedicationBean&gt; list = new ArrayList&lt;MedicationBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public MedicationBean loadSingle(ResultSet rs) throws SQLException {
		// MedicationBean med = new MedicationBean();
		MedicationBean med = new MedicationBean(rs.getString(&quot;Code&quot;));
		med.setDescription(rs.getString(&quot;Description&quot;));
		return med;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, MedicationBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_MessageBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.MessageBean;

/**
 * A loader for MessageBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class MessageBeanLoader implements BeanLoader&lt;MessageBean&gt; {

	public List&lt;MessageBean&gt; loadList(ResultSet rs) throws SQLException {
		List&lt;MessageBean&gt; list = new ArrayList&lt;MessageBean&gt;();
		while (rs.next())
			list.add(loadSingle(rs));
		return list;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, MessageBean message) throws SQLException {
		ps.setLong(1, message.getFrom());
		ps.setLong(2, message.getTo());
		ps.setString(3, message.getBody());
		ps.setString(4, message.getSubject());
		ps.setInt(5, message.getRead());
		if (message.getParentMessageId() != 0L) {
				ps.setLong(6, message.getParentMessageId());
		}
		return ps;
	}

	public MessageBean loadSingle(ResultSet rs) throws SQLException {
		MessageBean message = new MessageBean();
		message.setMessageId(rs.getLong(&quot;message_id&quot;));
		message.setFrom(rs.getLong(&quot;from_id&quot;));
		message.setTo(rs.getLong(&quot;to_id&quot;));
		message.setSubject(rs.getString(&quot;subject&quot;));
		message.setBody(rs.getString(&quot;message&quot;));
		message.setSentDate(rs.getTimestamp(&quot;sent_date&quot;));
		message.setRead(rs.getInt(&quot;been_read&quot;));
		message.setParentMessageId(rs.getLong(&quot;parent_msg_id&quot;));
		return message;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_OfficeVisitLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import edu.ncsu.csc.itrust.beans.OfficeVisitBean;

/**
 * A loader for OfficeVisitBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class OfficeVisitLoader implements BeanLoader&lt;OfficeVisitBean&gt; {
	public List&lt;OfficeVisitBean&gt; loadList(ResultSet rs) throws SQLException {
		List&lt;OfficeVisitBean&gt; list = new ArrayList&lt;OfficeVisitBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public OfficeVisitBean loadSingle(ResultSet rs) throws SQLException {
		OfficeVisitBean ov = new OfficeVisitBean(rs.getInt(&quot;ID&quot;));
		ov.setHcpID(rs.getLong(&quot;HCPID&quot;));
		ov.setNotes(rs.getString(&quot;Notes&quot;));
		ov.setPatientID(rs.getLong(&quot;PatientID&quot;));
		ov.setHospitalID(rs.getString(&quot;HospitalID&quot;));
		ov.setVisitDateStr(new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).format(new Date(rs.getDate(&quot;VisitDate&quot;).getTime())));

		return ov;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, OfficeVisitBean p) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_OperationalProfileLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.beans.OperationalProfile;
import edu.ncsu.csc.itrust.enums.TransactionType;

/**
 * A loader for the operational profile.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class OperationalProfileLoader implements BeanLoader&lt;OperationalProfile&gt; {
	public List&lt;OperationalProfile&gt; loadList(ResultSet rs) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

	public PreparedStatement loadParameters(PreparedStatement ps, OperationalProfile bean)
			throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

	public OperationalProfile loadSingle(ResultSet rs) throws SQLException {
		OperationalProfile op = new OperationalProfile();
		int grandTotal = 0;
		int grandPatient = 0;
		int grandPersonnel = 0;
		while (rs.next()) {
			TransactionType type = TransactionType.parse(rs.getInt(&quot;TransactionCode&quot;));
			int totalCount = rs.getInt(&quot;TotalCount&quot;);
			int patientCount = rs.getInt(&quot;PatientCount&quot;);
			int personnelCount = rs.getInt(&quot;PersonnelCount&quot;);
			op.getTotalCount().put(type, totalCount);
			op.getPatientCount().put(type, patientCount);
			op.getPersonnelCount().put(type, personnelCount);
			grandTotal += totalCount;
			grandPatient += patientCount;
			grandPersonnel += personnelCount;
		}
		op.setNumTotalTransactions(grandTotal);
		op.setNumPatientTransactions(grandPatient);
		op.setNumPersonnelTransactions(grandPersonnel);
		return op;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PatientLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.PatientBean;

/**
 * A loader for PatientBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class PatientLoader implements BeanLoader&lt;PatientBean&gt; {
	public List&lt;PatientBean&gt; loadList(ResultSet rs) throws SQLException {
		List&lt;PatientBean&gt; list = new ArrayList&lt;PatientBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public PatientBean loadSingle(ResultSet rs) throws SQLException {
		PatientBean p = new PatientBean();
		p.setMID(rs.getInt(&quot;MID&quot;));
		p.setFirstName(rs.getString(&quot;firstName&quot;));
		p.setLastName(rs.getString(&quot;LastName&quot;));
		Date dateOfBirth = rs.getDate(&quot;DateOfBirth&quot;);
		if (dateOfBirth != null)
			p.setDateOfBirthStr(new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).format(dateOfBirth));
		Date dateOfDeath = rs.getDate(&quot;DateOfDeath&quot;);
		if (dateOfDeath != null)
			p.setDateOfDeathStr(new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).format(dateOfDeath));
		p.setCauseOfDeath(rs.getString(&quot;CauseOfDeath&quot;));
		p.setEmail(rs.getString(&quot;Email&quot;));
		p.setStreetAddress1(rs.getString(&quot;address1&quot;));
		p.setStreetAddress2(rs.getString(&quot;address2&quot;));
		p.setCity(rs.getString(&quot;City&quot;));
		p.setState(rs.getString(&quot;State&quot;));
		p.setZip1((rs.getString(&quot;Zip1&quot;)));
		p.setZip2((rs.getString(&quot;Zip2&quot;)));
		p.setPhone1((rs.getString(&quot;phone1&quot;)));
		p.setPhone2((rs.getString(&quot;phone2&quot;)));
		p.setPhone3((rs.getString(&quot;phone3&quot;)));
		p.setEmergencyName(rs.getString(&quot;eName&quot;));
		p.setEmergencyPhone1(rs.getString(&quot;ePhone1&quot;));
		p.setEmergencyPhone2(rs.getString(&quot;ePhone2&quot;));
		p.setEmergencyPhone3(rs.getString(&quot;ePhone3&quot;));
		p.setIcName(rs.getString(&quot;icName&quot;));
		p.setIcAddress1(rs.getString(&quot;icAddress1&quot;));
		p.setIcAddress2(rs.getString(&quot;icAddress2&quot;));
		p.setIcCity(rs.getString(&quot;icCity&quot;));
		p.setIcState(rs.getString(&quot;icState&quot;));
		p.setIcZip1(rs.getString(&quot;icZip1&quot;));
		p.setIcZip2(rs.getString(&quot;icZip2&quot;));
		p.setIcPhone1(rs.getString(&quot;icPhone1&quot;));
		p.setIcPhone2(rs.getString(&quot;icPhone2&quot;));
		p.setIcPhone3(rs.getString(&quot;icPhone3&quot;));
		p.setIcID(rs.getString(&quot;icID&quot;));
		p.setMotherMID(rs.getString(&quot;MotherMID&quot;));
		p.setFatherMID(rs.getString(&quot;FatherMID&quot;));
		p.setBloodTypeStr(rs.getString(&quot;BloodType&quot;));
		p.setEthnicityStr(rs.getString(&quot;Ethnicity&quot;));
		p.setGenderStr(rs.getString(&quot;Gender&quot;));
		p.setTopicalNotes(rs.getString(&quot;TopicalNotes&quot;));
		p.setCreditCardType(rs.getString(&quot;CreditCardType&quot;));
		p.setCreditCardNumber(rs.getString(&quot;CreditCardNumber&quot;));
		p.setMessageFilter(rs.getString(&quot;MessageFilter&quot;));
		return p;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, PatientBean p) throws SQLException {
		int i = 1;
		ps.setString(i++, p.getFirstName());
		ps.setString(i++, p.getLastName());
		ps.setString(i++, p.getEmail());
		// ps.setString(i++, p.getSecurityQuestion());
		// ps.setString(i++, p.getSecurityAnswer());
		ps.setString(i++, p.getStreetAddress1());
		ps.setString(i++, p.getStreetAddress2());
		ps.setString(i++, p.getCity());
		ps.setString(i++, p.getState());
		ps.setString(i++, p.getZip1());
		ps.setString(i++, p.getZip2());
		ps.setString(i++, p.getPhone1());
		ps.setString(i++, p.getPhone2());
		ps.setString(i++, p.getPhone3());
		ps.setString(i++, p.getEmergencyName());
		ps.setString(i++, p.getEmergencyPhone1());
		ps.setString(i++, p.getEmergencyPhone2());
		ps.setString(i++, p.getEmergencyPhone3());
		ps.setString(i++, p.getIcName());
		ps.setString(i++, p.getIcAddress1());
		ps.setString(i++, p.getIcAddress2());
		ps.setString(i++, p.getIcCity());
		ps.setString(i++, p.getIcState());
		ps.setString(i++, p.getIcZip1());
		ps.setString(i++, p.getIcZip2());
		ps.setString(i++, p.getIcPhone1());
		ps.setString(i++, p.getIcPhone2());
		ps.setString(i++, p.getIcPhone3());
		ps.setString(i++, p.getIcID());
		Date date = null;
		try {
			date = new java.sql.Date(new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(p.getDateOfBirthStr())
					.getTime());
		} catch (ParseException e) {
			e.printStackTrace();
		}
		ps.setDate(i++, date);
		date = null;
		try {
			date = new java.sql.Date(new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(p.getDateOfDeathStr())
					.getTime());
		} catch (ParseException e) {
			if (&quot;&quot;.equals(p.getDateOfDeathStr()))
				date = null;
			else
				e.printStackTrace();
		}
		ps.setDate(i++, date);
		ps.setString(i++, p.getCauseOfDeath());
		ps.setString(i++, p.getMotherMID());
		ps.setString(i++, p.getFatherMID());
		ps.setString(i++, p.getBloodType().getName());
		ps.setString(i++, p.getEthnicity().getName());
		ps.setString(i++, p.getGender().getName());
		ps.setString(i++, p.getTopicalNotes());
		ps.setString(i++, p.getCreditCardType());
		ps.setString(i++, p.getCreditCardNumber());
		ps.setString(i++, p.getMessageFilter());
		return ps;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PersonnelLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.enums.Role;

/**
 * A loader for PersonnelBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class PersonnelLoader implements BeanLoader&lt;PersonnelBean&gt; {
	public List&lt;PersonnelBean&gt; loadList(ResultSet rs) throws SQLException {
		List&lt;PersonnelBean&gt; list = new ArrayList&lt;PersonnelBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public PersonnelBean loadSingle(ResultSet rs) throws SQLException {
		PersonnelBean p = new PersonnelBean();
		p.setMID(rs.getLong(&quot;MID&quot;));
		p.setAMID(rs.getLong(&quot;amid&quot;));
		p.setRole(Role.parse(rs.getString(&quot;role&quot;)));
		p.setLastName(rs.getString(&quot;lastName&quot;));
		p.setFirstName(rs.getString(&quot;firstName&quot;));
		p.setPhone1(rs.getString(&quot;phone1&quot;));
		p.setPhone2(rs.getString(&quot;phone2&quot;));
		p.setPhone3(rs.getString(&quot;phone3&quot;));
		p.setStreetAddress1(rs.getString(&quot;address1&quot;));
		p.setStreetAddress2(rs.getString(&quot;address2&quot;));
		p.setCity(rs.getString(&quot;city&quot;));
		p.setState(rs.getString(&quot;state&quot;));
		p.setZip1((rs.getString(&quot;zip1&quot;)));
		p.setZip2((rs.getString(&quot;zip2&quot;)));
		p.setEmail(rs.getString(&quot;email&quot;));
		p.setSpecialty(rs.getString(&quot;specialty&quot;));
		p.setMessageFilter(rs.getString(&quot;MessageFilter&quot;));
		return p;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, PersonnelBean p) throws SQLException {
		int i = 1;
		ps.setLong(i++, p.getAMID());
		ps.setString(i++, p.getFirstName());
		ps.setString(i++, p.getLastName());
		ps.setString(i++, p.getPhone1());
		ps.setString(i++, p.getPhone2());
		ps.setString(i++, p.getPhone3());
		ps.setString(i++, p.getStreetAddress1());
		ps.setString(i++, p.getStreetAddress2());
		ps.setString(i++, p.getCity());
		ps.setString(i++, p.getState());
		ps.setString(i++, p.getZip());
		ps.setString(i++, p.getZip1());
		ps.setString(i++, p.getZip2());
		//ps.setString(i++, p.getSpecialty());
		ps.setString(i++, p.getEmail());
		ps.setString(i++, p.getMessageFilter());
		return ps;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PrescriptionBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.PrescriptionBean;

/**
 * A loader for PrescriptionBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class PrescriptionBeanLoader implements BeanLoader&lt;PrescriptionBean&gt; {
	private MedicationBeanLoader medLoader;

	public PrescriptionBeanLoader() {
		medLoader = new MedicationBeanLoader();
	}

	public List&lt;PrescriptionBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;PrescriptionBean&gt; list = new ArrayList&lt;PrescriptionBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public PrescriptionBean loadSingle(ResultSet rs) throws SQLException {
		PrescriptionBean pres = new PrescriptionBean();
		pres.setId(rs.getLong(&quot;ID&quot;));
		pres.setVisitID((long) rs.getInt(&quot;VisitID&quot;));
		pres.setStartDateStr(new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).format(new java.util.Date(rs.getDate(
				&quot;StartDate&quot;).getTime())));
		pres.setEndDateStr(new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).format(new java.util.Date(rs.getDate(&quot;EndDate&quot;)
				.getTime())));
		pres.setDosage(rs.getInt(&quot;Dosage&quot;));
		pres.setInstructions(rs.getString(&quot;Instructions&quot;));
		pres.setMedication(medLoader.loadSingle(rs));
		return pres;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, PrescriptionBean pres) throws SQLException {
		ps.setLong(1, pres.getVisitID());
		ps.setString(2, pres.getMedication().getNDCode());
		ps.setDate(3, new java.sql.Date(pres.getStartDate().getTime()));
		ps.setDate(4, new java.sql.Date(pres.getEndDate().getTime()));
		ps.setInt(5, pres.getDosage());
		ps.setString(6, pres.getInstructions());
		return ps;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PrescriptionReportBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.PrescriptionReportBean;

/**
 * A loader for PrescriptionReportBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class PrescriptionReportBeanLoader implements BeanLoader&lt;PrescriptionReportBean&gt; {
	private PrescriptionBeanLoader presLoader;
	private OfficeVisitLoader ovLoader;

	public PrescriptionReportBeanLoader() {
		ovLoader = new OfficeVisitLoader();
		presLoader = new PrescriptionBeanLoader();
	}

	public List&lt;PrescriptionReportBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;PrescriptionReportBean&gt; list = new ArrayList&lt;PrescriptionReportBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public PrescriptionReportBean loadSingle(ResultSet rs) throws SQLException {
		PrescriptionReportBean pres = new PrescriptionReportBean();
		pres.setOfficeVisit(ovLoader.loadSingle(rs));
		pres.setPrescription(presLoader.loadSingle(rs));
		return pres;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, PrescriptionReportBean pres)
			throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ProcedureBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.ProcedureBean;

/**
 * A loader for ProcedureBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class ProcedureBeanLoader implements BeanLoader&lt;ProcedureBean&gt; {
	private boolean loadOVProcedureID;

	public ProcedureBeanLoader() {
		this.loadOVProcedureID = false;
	}

	public ProcedureBeanLoader(boolean loadOVProcedureID) {
		this.loadOVProcedureID = loadOVProcedureID;
	}

	public List&lt;ProcedureBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;ProcedureBean&gt; list = new ArrayList&lt;ProcedureBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public ProcedureBean loadSingle(ResultSet rs) throws SQLException {
		ProcedureBean procedure = new ProcedureBean(rs.getString(&quot;Code&quot;));
		procedure.setDescription(rs.getString(&quot;Description&quot;));
		procedure.setAttribute(rs.getString(&quot;Attribute&quot;));
		if (loadOVProcedureID) {
			procedure.setOvProcedureID(rs.getLong(&quot;ID&quot;));
			procedure.setDate(rs.getDate(&quot;visitDate&quot;));
		}
		
		return procedure;

	}

	public PreparedStatement loadParameters(PreparedStatement ps, ProcedureBean bean) throws SQLException {
		ps.setString(1, bean.getDescription());
		return ps;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ReferralBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.ReferralBean;
import edu.ncsu.csc.itrust.beans.ReferralBean.ReferralStatus;

/**
 * A loader for ReferralBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class ReferralBeanLoader implements BeanLoader&lt;ReferralBean&gt; {

	public ReferralBeanLoader() {

	}

	public List&lt;ReferralBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;ReferralBean&gt; list = new ArrayList&lt;ReferralBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public ReferralBean loadSingle(ResultSet rs) throws SQLException {
		ReferralBean ref = new ReferralBean();
		// ERIC: fixed to correct for the mysql database bug plaguing java 1.5
		ref.setId((long) rs.getInt(&quot;id&quot;));
		//ref.setId(rs.getLong(&quot;id&quot;));
		ref.setSenderID(rs.getLong(&quot;SenderID&quot;));
		ref.setReceiverID(rs.getLong(&quot;ReceiverID&quot;));
		ref.setPatientID((long) rs.getInt(&quot;PatientID&quot;));
		ref.setReferralDetails(rs.getString(&quot;ReferralDetails&quot;));
		ref.setConsultationDetails(rs.getString(&quot;ConsultationDetails&quot;));
		
		if (rs.getString(&quot;Status&quot;).equals(&quot;Pending&quot;)) 
			ref.setStatus(ReferralStatus.Pending);
		else if (rs.getString(&quot;Status&quot;).equals(&quot;Finished&quot;)) 
			ref.setStatus(ReferralStatus.Finished);
		else 
			ref.setStatus(ReferralStatus.Declined);
		
		
		return ref;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, ReferralBean ref) throws SQLException {
		ps.setLong(1, ref.getPatientID());
		ps.setLong(2, ref.getSenderID());
		ps.setLong(3, ref.getReceiverID());
		ps.setString(4, ref.getReferralDetails());
		ps.setString(5, ref.getConsultationDetails());
		ps.setString(6, ref.getStatus().toString());
		return ps;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_RemoteMonitoringDataBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.RemoteMonitoringDataBean;

/**
 * A loader for RemoteMonitoringDataBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class RemoteMonitoringDataBeanLoader implements BeanLoader&lt;RemoteMonitoringDataBean&gt; {

	public List&lt;RemoteMonitoringDataBean&gt; loadList(ResultSet rs) throws SQLException {
		List&lt;RemoteMonitoringDataBean&gt; list = new ArrayList&lt;RemoteMonitoringDataBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, RemoteMonitoringDataBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

	public RemoteMonitoringDataBean loadSingle(ResultSet rs) throws SQLException {
		RemoteMonitoringDataBean d = new RemoteMonitoringDataBean();
		d.setLoggedInMID(rs.getLong(&quot;PatientID&quot;));
		d.setSystolicBloodPressure(rs.getInt(&quot;systolicBloodPressure&quot;));
		d.setDiastolicBloodPressure(rs.getInt(&quot;diastolicBloodPressure&quot;));
		d.setGlucoseLevel(rs.getInt(&quot;glucoseLevel&quot;));
		d.setTime(rs.getTimestamp(&quot;timeLogged&quot;));
		d.setReporterRole(rs.getString(&quot;ReporterRole&quot;));
		d.setReporterMID(rs.getLong(&quot;ReporterID&quot;));
		return d;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ReportRequestBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.ReportRequestBean;


/**
 * A loader for ReportRequestBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class ReportRequestBeanLoader implements BeanLoader&lt;ReportRequestBean&gt; {

	public List&lt;ReportRequestBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;ReportRequestBean&gt; list = new ArrayList&lt;ReportRequestBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public ReportRequestBean loadSingle(ResultSet rs) throws SQLException {
		ReportRequestBean b = new ReportRequestBean();
		b.setID(rs.getLong(&quot;ID&quot;));
		b.setRequesterMID(rs.getLong(&quot;RequesterMID&quot;));
		b.setPatientMID(rs.getLong(&quot;PatientMID&quot;));
		b.setRequestedDate(rs.getTimestamp(&quot;RequestedDate&quot;));
		b.setViewedDate(rs.getTimestamp(&quot;ViewedDate&quot;));
		b.setStatus(rs.getString(&quot;Status&quot;));
		return b;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, ReportRequestBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}


}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SurveyLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import edu.ncsu.csc.itrust.beans.SurveyBean;


/**
 * A loader for SurveyBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class SurveyLoader implements BeanLoader&lt;SurveyBean&gt;{

	public List&lt;SurveyBean&gt; loadList(ResultSet rs) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

	public PreparedStatement loadParameters(PreparedStatement ps, SurveyBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

	public SurveyBean loadSingle(ResultSet rs) throws SQLException {
		SurveyBean survey = new SurveyBean();
		survey.setVisitID(rs.getLong(&quot;VisitID&quot;));
		survey.setSurveyDate(rs.getTimestamp(&quot;SurveyDate&quot;));
		survey.setExamRoomMinutes(rs.getInt(&quot;ExamRoomMinutes&quot;));
		survey.setWaitingRoomMinutes(rs.getInt(&quot;WaitingRoomMinutes&quot;));
		survey.setTreatmentSatisfaction(rs.getInt(&quot;TreatmentSatisfaction&quot;));
		survey.setVisitSatisfaction(rs.getInt(&quot;VisitSatisfaction&quot;));

		return survey;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SurveyResultBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.SurveyResultBean;
/**
 * A loader for SurveyResultBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class SurveyResultBeanLoader implements BeanLoader&lt;SurveyResultBean&gt; {

	public List&lt;SurveyResultBean&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;SurveyResultBean&gt; list = new ArrayList&lt;SurveyResultBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, SurveyResultBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

	public SurveyResultBean loadSingle(ResultSet rs) throws SQLException {
		SurveyResultBean surveyResult = new SurveyResultBean();
		surveyResult.setHCPMID(rs.getLong(&quot;mid&quot;));
		surveyResult.setAvgExamRoomMinutes(rs.getFloat(&quot;AvgExamRoomMinutes&quot;));
		surveyResult.setAvgTreatmentSatisfaction(rs.getFloat(&quot;AvgTreatmentSatisfation&quot;));
		surveyResult.setAvgVisitSatisfaction(rs.getFloat(&quot;AvgVisitSatisfaction&quot;));
		surveyResult.setAvgWaitingRoomMinutes(rs.getFloat(&quot;AvgWaitingRoomMinutes&quot;));
		surveyResult.setHCPaddress1(rs.getString(&quot;address1&quot;));
		surveyResult.setHCPaddress2(rs.getString(&quot;address2&quot;));
		surveyResult.setHCPcity(rs.getString(&quot;city&quot;));
		surveyResult.setHCPstate(rs.getString(&quot;state&quot;));
		surveyResult.setHCPzip(rs.getString(&quot;zip&quot;));
		surveyResult.setHCPhospital(rs.getString(&quot;hospitalID&quot;));
		surveyResult.setHCPFirstName(rs.getString(&quot;firstName&quot;));
		surveyResult.setHCPLastName(rs.getString(&quot;lastName&quot;));
		surveyResult.setHCPspecialty(rs.getString(&quot;specialty&quot;));
		surveyResult.setPercentSatisfactionResults(rs.getFloat(&quot;PercentSatisfactionResults&quot;));
		
		return surveyResult;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_TransactionBeanLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.TransactionBean;
import edu.ncsu.csc.itrust.enums.TransactionType;

/**
 * A loader for TransactionBeans.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class TransactionBeanLoader implements BeanLoader&lt;TransactionBean&gt; {

	public List&lt;TransactionBean&gt; loadList(ResultSet rs) throws SQLException {
		List&lt;TransactionBean&gt; list = new ArrayList&lt;TransactionBean&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public PreparedStatement loadParameters(PreparedStatement ps, TransactionBean bean) throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

	public TransactionBean loadSingle(ResultSet rs) throws SQLException {
		TransactionBean t = new TransactionBean();
		t.setAddedInfo(rs.getString(&quot;addedInfo&quot;));
		t.setLoggedInMID(rs.getLong(&quot;loggedInMID&quot;));
		t.setSecondaryMID(rs.getLong(&quot;secondaryMID&quot;));
		t.setTimeLogged(rs.getTimestamp(&quot;timeLogged&quot;));
		t.setTransactionType(TransactionType.parse(rs.getInt(&quot;transactionCode&quot;)));
		t.setTransactionID(rs.getLong(&quot;transactionID&quot;));
		return t;
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_VisitReminderReturnFormLoader</id>
            <content>package edu.ncsu.csc.itrust.beans.loaders;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.forms.VisitReminderReturnForm;

/**
 * A loader for VisitReminderReturnForms.
 * 
 * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. 
 * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}
 */
public class VisitReminderReturnFormLoader implements BeanLoader&lt;VisitReminderReturnForm&gt; {

	public List&lt;VisitReminderReturnForm&gt; loadList(ResultSet rs) throws SQLException {
		ArrayList&lt;VisitReminderReturnForm&gt; list = new ArrayList&lt;VisitReminderReturnForm&gt;();
		while (rs.next()) {
			list.add(loadSingle(rs));
		}
		return list;
	}

	public VisitReminderReturnForm loadSingle(ResultSet rs) throws SQLException {
		int i = 0;
		return new VisitReminderReturnForm(rs.getLong(++i),// hcpid
				rs.getLong(++i),// patient ID
				rs.getString(++i),// last name
				rs.getString(++i),// first
				rs.getString(++i),// phone1
				rs.getString(++i),// phone2
				rs.getString(++i));// ,// phone3
		// &quot;diagnosis: &quot; + rs.getString(++i),
		// &quot;last visit: &quot; + rs.getString(++i));
	}

	public PreparedStatement loadParameters(PreparedStatement ps, VisitReminderReturnForm bean)
			throws SQLException {
		throw new IllegalStateException(&quot;unimplemented!&quot;);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AddPatientValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.AddPatientAction;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * The validator used by {@link AddPatientAction}. Only checks first name, last name, and email
 * 
 * @author Andy
 * 
 */
public class AddPatientValidator extends BeanValidator&lt;PatientBean&gt; {
	/**
	 * The default constructor.
	 */
	public AddPatientValidator() {
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(PatientBean p) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;First name&quot;, p.getFirstName(), ValidationFormat.NAME, false));
		errorList.addIfNotNull(checkFormat(&quot;Last name&quot;, p.getLastName(), ValidationFormat.NAME, false));
		errorList.addIfNotNull(checkFormat(&quot;Email&quot;, p.getEmail(), ValidationFormat.EMAIL, false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}
	
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AddPersonnelValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.AddPatientAction;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * The validator used by {@link AddPatientAction}. Only checks first name, last name, and email
 * 
 * @author Andy
 * 
 */
public class AddPersonnelValidator extends BeanValidator&lt;PersonnelBean&gt; {
	
	/**
	 * The default constructor.
	 */
	public AddPersonnelValidator() {
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(PersonnelBean p) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;First name&quot;, p.getFirstName(), ValidationFormat.NAME, false));
		errorList.addIfNotNull(checkFormat(&quot;Last name&quot;, p.getLastName(), ValidationFormat.NAME, false));
		errorList.addIfNotNull(checkFormat(&quot;Email&quot;, p.getEmail(), ValidationFormat.EMAIL, false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AdverseEventValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.beans.AdverseEventBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validates an adverse event bean, from {@link AdverseEventAction}
 * 
 */
public class AdverseEventValidator extends BeanValidator&lt;AdverseEventBean&gt; {
	/**
	 * The default constructor.
	 */
	public AdverseEventValidator() {
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param d A bean of the type to be validated.
	 */
	@Override
	public void validate(AdverseEventBean b) throws FormValidationException {
		ErrorList errorList = new ErrorList();errorList.addIfNotNull(checkFormat(&quot;comment&quot;, b.getDescription(), ValidationFormat.ADVERSE_EVENT_COMMENTS,false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AllergyBeanValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.EditOfficeVisitAction;
import edu.ncsu.csc.itrust.beans.AllergyBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validator used to validate adding a new allergy in {@link EditOfficeVisitAction}
 * 
 * @author Andy
 * 
 */
public class AllergyBeanValidator extends BeanValidator&lt;AllergyBean&gt; {
	/**
	 * The default constructor.
	 */
	public AllergyBeanValidator() {
	}
	
	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(AllergyBean m) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;Allergy Description&quot;, m.getDescription(),
				ValidationFormat.ALLERGY_DESCRIPTION, false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ApptBeanValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.beans.ApptBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

public class ApptBeanValidator extends BeanValidator&lt;ApptBean&gt;{

	public void validate(ApptBean bean) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		if(bean.getComment() == null)
			return;
		errorList.addIfNotNull(checkFormat(&quot;Appointment Comment&quot;, bean.getComment(), ValidationFormat.APPT_COMMENT, false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ApptTypeBeanValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.beans.ApptTypeBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

public class ApptTypeBeanValidator extends BeanValidator&lt;ApptTypeBean&gt; {

	@Override
	public void validate(ApptTypeBean a) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;Appointment Type Name&quot;, a.getName(), ValidationFormat.APPT_TYPE_NAME, false));
		errorList.addIfNotNull(checkFormat(&quot;Appointment Type Duration&quot;, a.getDuration()+&quot;&quot;, ValidationFormat.APPT_TYPE_DURATION, false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_BeanValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.enums.Gender;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;


/**
 * Abstract class used by all validators that provides utility methods for checking formatting of a particular
 * field. Specify the Bean to be validated
 * 
 * @author Andy
 * 
 * @param &lt;T&gt;
 *            The bean type to be validated
 */
abstract public class BeanValidator&lt;T&gt; {
	abstract public void validate(T bean) throws FormValidationException;
	
	/**
	 * Check the format against the given enum. isNullable will check if the string is empty or a Java null.
	 * Otherwise, an error message will be returned. Use this in conjunction with {@link ErrorList}.
	 * 
	 * @param name
	 * @param value
	 * @param format
	 * @param isNullable
	 * @return
	 */
	protected String checkFormat(String name, String value, ValidationFormat format, boolean isNullable) {
		 
		String errorMessage = name + &quot;: &quot; + format.getDescription();
		 if (value == null || &quot;&quot;.equals(value))
			return isNullable ? &quot;&quot; : errorMessage;
		else if (format.getRegex().matcher(value).matches())
			return &quot;&quot;;
		else
			return errorMessage;
	}

	/**
	 * Check a long value against a particular format. isNullable will check if it is empty or a Java null.
	 * Otherwise, an error message will be returned. Use this in conjunction with {@link ErrorList}.
	 * 
	 * @param name
	 * @param longValue
	 * @param format
	 * @param isNullable
	 * @return
	 */
	protected String checkFormat(String name, Long longValue, ValidationFormat format, boolean isNullable) {
		String str = &quot;&quot;;
		if (longValue != null)
			str = String.valueOf(longValue);
		return checkFormat(name, str, format, isNullable);
	}

	/**
	 * Check the format against the given enum. isNullable will check if it is a Java null. Otherwise, an
	 * error message will be returned. Use this in conjunction with {@link ErrorList}.
	 * 
	 * @param name
	 * @param doubleValue
	 * @param format
	 * @param isNullable
	 * @return
	 */
	protected String checkFormat(String name, Double doubleValue, ValidationFormat format, boolean isNullable) {
		String str = &quot;&quot;;
		if (doubleValue != null)
			str = String.valueOf(doubleValue);
		return checkFormat(name, str, format, isNullable);
	}

	/**
	 * Check against the proper gender
	 * 
	 * @param name
	 * @param gen
	 * @param format
	 * @param isNullable
	 * @return
	 */
	protected String checkGender(String name, Gender gen, ValidationFormat format, boolean isNullable) {
		String str = &quot;&quot;;
		if (gen != null)
			str = gen.toString();
		return checkFormat(name, str, format, isNullable);
	}

	/**
	 * The that an integer is the proper format, and is in the correct range
	 * 
	 * @param name
	 * @param value
	 * @param lower
	 * @param upper
	 * @param isNullable
	 * @return
	 */
	protected String checkInt(String name, String value, int lower, int upper, boolean isNullable) {
		if (isNullable &amp;&amp; (value == null || &quot;&quot;.equals(value)))
			return &quot;&quot;;
		try {
			int intValue = Integer.valueOf(value);
			if (lower &lt;= intValue &amp;&amp; intValue &lt;= upper)
				return &quot;&quot;;
		} catch (NumberFormatException e) {
			// just fall through to returning the error message
		}

		return name + &quot; must be an integer in [&quot; + lower + &quot;,&quot; + upper + &quot;]&quot;;
	}

	/**
	 * Check that a double is in the proper format and is in the correct range
	 * 
	 * @param name
	 * @param value
	 * @param lower
	 * @param upper
	 * @return
	 */
	protected String checkDouble(String name, String value, double lower, double upper) {
		try {
			double doubleValue = Double.valueOf(value);
			if (lower &lt;= doubleValue &amp;&amp; doubleValue &lt; upper)
				return &quot;&quot;;
		} catch (NumberFormatException e) {
			// just fall through to returning the error message
		}
		return name + &quot; must be a decimal in [&quot; + lower + &quot;,&quot; + upper + &quot;)&quot;;
	}

	/**
	 * Check that the value fits the &quot;true&quot; or &quot;false&quot;
	 * 
	 * @param name
	 * @param value
	 * @return
	 */
	protected String checkBoolean(String name, String value) {
		if (&quot;true&quot;.equals(value) || &quot;false&quot;.equals(value))
			return &quot;&quot;;
		else
			return name + &quot; must be either 'true' or 'false'&quot;;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_DiagnosisBeanValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.beans.DiagnosisBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validates an ICD9CM code
 * 
 * @author Andy
 * 
 */
public class DiagnosisBeanValidator extends BeanValidator&lt;DiagnosisBean&gt; {
	/**
	 * The default constructor.
	 */
	public DiagnosisBeanValidator() {
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(DiagnosisBean d) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;ICD9CM Code&quot;, d.getICDCode(), ValidationFormat.ICD9CM, false));
		errorList.addIfNotNull(checkFormat(&quot;Description&quot;, d.getDescription(),
				ValidationFormat.ICD_CODE_DESCRIPTION, false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_DrugInteractionValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.beans.DrugInteractionBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validates a drug interaction bean, from {@link DrugInteractionAction}
 * 
 */
public class DrugInteractionValidator extends BeanValidator&lt;DrugInteractionBean&gt; {
	/**
	 * The default constructor.
	 */
	public DrugInteractionValidator() {
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param d A bean of the type to be validated.
	 */
	@Override
	public void validate(DrugInteractionBean d) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;FirstDrug&quot;, d.getFirstDrug(), ValidationFormat.ND,false));
		errorList.addIfNotNull(checkFormat(&quot;SecondDrug&quot;, d.getSecondDrug(), ValidationFormat.ND,false));
		errorList.addIfNotNull(checkFormat(&quot;description&quot;, d.getDescription(), ValidationFormat.DRUG_INT_COMMENTS,false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EMailValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.beans.MessageBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;


public class EMailValidator extends BeanValidator&lt;MessageBean&gt;  {
	/**
	 * The default constructor.
	 */
	public EMailValidator(){
		
	}
	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param m A bean of the type to be validated.
	 */
	
	public void validate(MessageBean m) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;body&quot;, m.getBody(), ValidationFormat.EMAILS,
				false));

		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EditOfficeVisitValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import edu.ncsu.csc.itrust.action.EditOfficeVisitAction;
import edu.ncsu.csc.itrust.beans.forms.EditOfficeVisitForm;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Used to validate updating an office visit, by {@link EditOfficeVisitAction}
 * 
 * @author Andy
 * 
 */
public class EditOfficeVisitValidator extends BeanValidator&lt;EditOfficeVisitForm&gt; {
	private boolean validatePrescription = false;

	/**
	 * The default constructor.
	 */
	public EditOfficeVisitValidator() {
	}

	public EditOfficeVisitValidator(boolean validatePrescription) {
		this.validatePrescription = validatePrescription;
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(EditOfficeVisitForm form) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;HCP ID&quot;, form.getHcpID(), ValidationFormat.MID, false));
		errorList.addIfNotNull(checkFormat(&quot;Hospital ID&quot;, form.getHospitalID(), ValidationFormat.HOSPITAL_ID,
				true));
		errorList.addIfNotNull(checkFormat(&quot;Notes&quot;, form.getNotes(), ValidationFormat.NOTES, true));
		errorList.addIfNotNull(checkFormat(&quot;Patient ID&quot;, form.getPatientID(), ValidationFormat.MID, false));
		errorList.addIfNotNull(checkFormat(&quot;Visit Date&quot;, form.getVisitDate(), ValidationFormat.DATE, false));
		if (validatePrescription) {
			errorList.addIfNotNull(checkFormat(&quot;Start Date&quot;, form.getStartDate(), ValidationFormat.DATE,
					false));
			errorList.addIfNotNull(checkFormat(&quot;End Date&quot;, form.getEndDate(), ValidationFormat.DATE, false));
			errorList.addIfNotNull(checkFormat(&quot;Instructions&quot;, form.getInstructions(),
					ValidationFormat.NOTES, true));
			errorList.addIfNotNull(checkInt(&quot;Dosage&quot;, form.getDosage(), 0, 9999, false));
			if ((checkFormat(&quot;Start Date&quot;, form.getStartDate(), ValidationFormat.DATE, false)) == &quot;&quot;
					&amp;&amp; (checkFormat(&quot;End Date&quot;, form.getEndDate(), ValidationFormat.DATE, false)) == &quot;&quot;) {
				Date sd = null;
				Date ed = null;
				try {
					sd = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(form.getStartDate());
					ed = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;).parse(form.getEndDate());
					String dateError = null;
					if (sd.after(ed)) {
						dateError = &quot;The start date of the prescription must be before the end date.&quot;;
					}
					errorList.addIfNotNull(dateError);
				} catch (ParseException e) {
					errorList.addIfNotNull(ValidationFormat.DATE.getDescription());
				}

			}
		}
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_HealthRecordFormValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.EditHealthHistoryAction;
import edu.ncsu.csc.itrust.beans.forms.HealthRecordForm;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validator used in adding health information on Basic Health History, {@link EditHealthHistoryAction}
 * 
 * @author Andy
 * 
 */
public class HealthRecordFormValidator extends BeanValidator&lt;HealthRecordForm&gt; {
	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(HealthRecordForm bean) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkInt(&quot;Systolic blood pressure&quot;, bean.getBloodPressureN(), 0, 999, false));
		errorList.addIfNotNull(checkInt(&quot;Diastolic blood pressure&quot;, bean.getBloodPressureD(), 0, 999, false));
		errorList.addIfNotNull(checkInt(&quot;Cholesterol HDL&quot;, bean.getCholesterolHDL(), 0, 89, false));
		errorList.addIfNotNull(checkInt(&quot;Cholesterol LDL&quot;, bean.getCholesterolLDL(), 0, 600, false));
		errorList.addIfNotNull(checkInt(&quot;Cholesterol Triglycerides&quot;, bean.getCholesterolTri(), 100, 600,
				false));
		errorList.addIfNotNull(checkFormat(&quot;Height&quot;, bean.getHeight(), ValidationFormat.Height, false));
		errorList.addIfNotNull(checkFormat(&quot;Weight&quot;, bean.getWeight(), ValidationFormat.Weight, false));
		errorList.addIfNotNull(checkBoolean(&quot;Smoker&quot;, bean.getIsSmoker()));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_HospitalBeanValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.UpdateHospitalListAction;
import edu.ncsu.csc.itrust.beans.HospitalBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validates the input for hospital beans, {@link UpdateHospitalListAction}
 * 
 * @author Andy
 * 
 */
public class HospitalBeanValidator extends BeanValidator&lt;HospitalBean&gt; {
	/**
	 * The default constructor.
	 */
	public HospitalBeanValidator() {
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(HospitalBean h) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;Hospital ID&quot;, h.getHospitalID(), ValidationFormat.HOSPITAL_ID,
				false));
		errorList.addIfNotNull(checkFormat(&quot;Hospital Name&quot;, h.getHospitalName(),
				ValidationFormat.HOSPITAL_NAME, false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_LOINCBeanValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;


import edu.ncsu.csc.itrust.beans.LOINCbean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;


/**
 * Validator used to validate LOINCbean
 */
public class LOINCBeanValidator extends BeanValidator&lt;LOINCbean&gt; {
	/**
	 * The default constructor.
	 */
	public LOINCBeanValidator() {
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(LOINCbean m) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		if(m.getLabProcedureCode()==null || m.getComponent()==null || m.getKindOfProperty()==null){
			throw new FormValidationException(&quot;You must have a Lab Procedure Code, Component and Kind Of Property&quot;);
		}
		errorList.addIfNotNull(checkFormat(&quot;LaboratoryProcedureCode&quot;, m.getLabProcedureCode(), ValidationFormat.LOINC, false));
		errorList.addIfNotNull(checkFormat(&quot;Component&quot;, m.getComponent(), ValidationFormat.LOINC_ITEM, false));
		errorList.addIfNotNull(checkFormat(&quot;KindOfProperty&quot;, m.getKindOfProperty(), ValidationFormat.LOINC_ITEM, false));
		errorList.addIfNotNull(checkFormat(&quot;TimeAspect&quot;, m.getTimeAspect(), ValidationFormat.LOINC_ITEM, true));
		errorList.addIfNotNull(checkFormat(&quot;System&quot;, m.getSystem(), ValidationFormat.LOINC_ITEM, true));
		errorList.addIfNotNull(checkFormat(&quot;ScaleType&quot;,m.getScaleType(), ValidationFormat.LOINC_ITEM, true));
		errorList.addIfNotNull(checkFormat(&quot;MethodType&quot;, m.getMethodType(), ValidationFormat.LOINC_ITEM, true));

		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_LabProcedureValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.beans.LabProcedureBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

public class LabProcedureValidator {
	
	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	public void validate(LabProcedureBean b) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;LOINC&quot;, b.getLoinc(), ValidationFormat.LOINC, false));
		errorList.addIfNotNull(checkFormat(&quot;Commentary&quot;, b.getCommentary(), ValidationFormat.COMMENTS, true));
		errorList.addIfNotNull(checkFormat(&quot;Results&quot;, b.getCommentary(), ValidationFormat.COMMENTS, true));
		errorList.addIfNotNull(checkFormat(&quot;Status&quot;, b.getStatus(), ValidationFormat.LAB_STATUS, false));
		errorList.addIfNotNull(checkFormat(&quot;Rights&quot;, b.getRights(), ValidationFormat.LAB_RIGHTS, false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

	protected String checkFormat(String name, String value, ValidationFormat format, boolean isNullable) {
		String errorMessage = name + &quot;: &quot; + format.getDescription();
		if (value == null || &quot;&quot;.equals(value))
			return isNullable ? &quot;&quot; : errorMessage;
		if (format.getRegex().matcher(value).matches())
			return &quot;&quot;;
		else
			return errorMessage;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_MailValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.exception.FormValidationException;
import org.apache.commons.validator.*;


public class MailValidator extends EmailValidator {
	/**
	 * The default constructor.
	 */
	public MailValidator(){
		
	}
	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	public boolean validateEmail(String email) throws FormValidationException {
		MailValidator val = new MailValidator();
	
		return val.isValid(email);
		
	}
	

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_MedicationBeanValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.UpdateNDCodeListAction;
import edu.ncsu.csc.itrust.beans.MedicationBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validates ND code beans, from {@link UpdateNDCodeListAction}
 * 
 * @author Andy
 * 
 */
public class MedicationBeanValidator extends BeanValidator&lt;MedicationBean&gt; {
	/**
	 * The default constructor.
	 */
	public MedicationBeanValidator() {
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(MedicationBean m) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;ND Code&quot;, m.getNDCode(), ValidationFormat.ND, false));
		errorList.addIfNotNull(checkFormat(&quot;Description&quot;, m.getDescription(),
				ValidationFormat.ND_CODE_DESCRIPTION, false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_MessageValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.EditOfficeVisitAction;
import edu.ncsu.csc.itrust.beans.MessageBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Used to validate updating an office visit, by {@link EditOfficeVisitAction}
 * 
 * @author Andy
 * 
 */
public class MessageValidator extends BeanValidator&lt;MessageBean&gt; {

	public MessageValidator() {
	}
	
	public void validate(MessageBean mBean) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;body&quot;, mBean.getBody(), ValidationFormat.MESSAGES_BODY, false));
		errorList.addIfNotNull(checkFormat(&quot;subject&quot;, mBean.getSubject(), ValidationFormat.MESSAGES_SUBJECT, false));
		
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PatientValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.EditPatientAction;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;
import org.apache.commons.validator.CreditCardValidator;
import java.util.Date;

/**
 * Validates a patient bean, from {@link EditPatientAction}
 * 
 * @author Andy
 * 
 */
public class PatientValidator extends BeanValidator&lt;PatientBean&gt; {
	/**
	 * The default constructor.
	 */
	public PatientValidator() {
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(PatientBean p) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;First name&quot;, p.getFirstName(), ValidationFormat.NAME, false));
		errorList.addIfNotNull(checkFormat(&quot;Last name&quot;, p.getLastName(), ValidationFormat.NAME, false));
		errorList.addIfNotNull(checkFormat(&quot;Date of Birth&quot;, p.getDateOfBirthStr(), ValidationFormat.DATE,
				false));
		errorList.addIfNotNull(checkFormat(&quot;Date of Death&quot;, p.getDateOfDeathStr(), ValidationFormat.DATE,
				true));
		try {
			if (p.getDateOfDeath() == null &amp;&amp; &quot;&quot;.equals(p.getDateOfDeathStr())){
				if( p.getDateOfBirth().after(new Date())){
					errorList.addIfNotNull(&quot;Birth date cannot be in the future!&quot;);
				}
			}
			if (p.getDateOfDeath().before(p.getDateOfBirth()))
				errorList.addIfNotNull(&quot;Death date cannot be before birth date!&quot;);
			if( p.getDateOfDeath().after(new Date())){
				errorList.addIfNotNull(&quot;Death date cannot be in the future!&quot;);
			}
			if( p.getDateOfBirth().after(new Date())){
				errorList.addIfNotNull(&quot;Birth date cannot be in the future!&quot;);
			}
		} catch (NullPointerException e) {
			// ignore this
		}
		
		
		
			
		boolean deathCauseNull = (null == p.getDateOfDeathStr() || p.getDateOfDeathStr().equals(&quot;&quot;));
		errorList.addIfNotNull(checkFormat(&quot;Cause of Death&quot;, p.getCauseOfDeath(), ValidationFormat.ICD9CM,
				deathCauseNull));
		errorList.addIfNotNull(checkFormat(&quot;Email&quot;, p.getEmail(), ValidationFormat.EMAIL, false));
		errorList.addIfNotNull(checkFormat(&quot;Street Address 1&quot;, p.getStreetAddress1(),
				ValidationFormat.ADDRESS, false));
		errorList.addIfNotNull(checkFormat(&quot;Street Address 2&quot;, p.getStreetAddress2(),
				ValidationFormat.ADDRESS, true));
		errorList.addIfNotNull(checkFormat(&quot;City&quot;, p.getCity(), ValidationFormat.CITY, false));
		errorList.addIfNotNull(checkFormat(&quot;State&quot;, p.getState(), ValidationFormat.STATE, false));
		errorList.addIfNotNull(checkFormat(&quot;Zip Code&quot;, p.getZip(), ValidationFormat.ZIPCODE, false));
		errorList
				.addIfNotNull(checkFormat(&quot;Phone Number&quot;, p.getPhone(), ValidationFormat.PHONE_NUMBER, false));
		errorList.addIfNotNull(checkFormat(&quot;Emergency Contact Name&quot;, p.getEmergencyName(),
				ValidationFormat.NAME, false));
		errorList.addIfNotNull(checkFormat(&quot;Emergency Contact Phone&quot;, p.getEmergencyPhone(),
				ValidationFormat.PHONE_NUMBER, false));
		errorList.addIfNotNull(checkFormat(&quot;Insurance Company Name&quot;, p.getIcName(), ValidationFormat.NAME,
				false));
		errorList.addIfNotNull(checkFormat(&quot;Insurance Company Address 1&quot;, p.getIcAddress1(),
				ValidationFormat.ADDRESS, false));
		errorList.addIfNotNull(checkFormat(&quot;Insurance Company Address 2&quot;, p.getIcAddress2(),
				ValidationFormat.ADDRESS, true));
		errorList.addIfNotNull(checkFormat(&quot;Insurance Company City&quot;, p.getIcCity(), ValidationFormat.CITY,
				false));
		errorList.addIfNotNull(checkFormat(&quot;Insurance Company State&quot;, p.getIcState(), ValidationFormat.STATE,
				false));
		errorList.addIfNotNull(checkFormat(&quot;Insurance Company Zip&quot;, p.getIcZip(), ValidationFormat.ZIPCODE,
				false));
		errorList.addIfNotNull(checkFormat(&quot;Insurance Company Phone&quot;, p.getIcPhone(),
				ValidationFormat.PHONE_NUMBER, false));
		errorList.addIfNotNull(checkFormat(&quot;Insurance Company ID&quot;, p.getIcID(),
				ValidationFormat.INSURANCE_ID, false));
		errorList.addIfNotNull(checkFormat(&quot;Mother MID&quot;, p.getMotherMID(), ValidationFormat.MID, true));
		errorList.addIfNotNull(checkFormat(&quot;Father MID&quot;, p.getFatherMID(), ValidationFormat.MID, true));
		errorList
				.addIfNotNull(checkFormat(&quot;Topical Notes&quot;, p.getTopicalNotes(), ValidationFormat.NOTES, true));
		
		/* This block was added for Theme 5 by Tyler Arehart */
		
		if (!(p.getCreditCardNumber().equals(&quot;&quot;) &amp;&amp; p.getCreditCardType().equals(&quot;&quot;))) {
		
			String s = null;
			CreditCardValidator c;
			int type = -1;
			if (p.getCreditCardType().equals(&quot;VISA&quot;)) type = CreditCardValidator.VISA;
			if (p.getCreditCardType().equals(&quot;MASTERCARD&quot;)) type = CreditCardValidator.MASTERCARD;
			if (p.getCreditCardType().equals(&quot;DISCOVER&quot;)) type = CreditCardValidator.DISCOVER;
			if (p.getCreditCardType().equals(&quot;AMEX&quot;)) type = CreditCardValidator.AMEX;
			
			if (type != -1) {	
				c = new CreditCardValidator(type);
				if (!c.isValid(p.getCreditCardNumber())) {
					s = &quot;Credit Card Number&quot;;
				}
			}
			else {
				s = &quot;Credit Card Type&quot;;
			}
			errorList.addIfNotNull(s);
		}
		
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PersonnelValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.EditPersonnelAction;
import edu.ncsu.csc.itrust.beans.PersonnelBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validates a personnel bean, from {@link EditPersonnelAction}
 * 
 * @author Andy
 * 
 */
public class PersonnelValidator extends BeanValidator&lt;PersonnelBean&gt; {
	/**
	 * The default constructor.
	 */
	public PersonnelValidator() {
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(PersonnelBean p) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;First name&quot;, p.getFirstName(), ValidationFormat.NAME, false));
		errorList.addIfNotNull(checkFormat(&quot;Last name&quot;, p.getLastName(), ValidationFormat.NAME, false));
		errorList.addIfNotNull(checkFormat(&quot;Street Address 1&quot;, p.getStreetAddress1(),
				ValidationFormat.ADDRESS, false));
		errorList.addIfNotNull(checkFormat(&quot;Street Address 2&quot;, p.getStreetAddress2(),
				ValidationFormat.ADDRESS, true));
		errorList.addIfNotNull(checkFormat(&quot;City&quot;, p.getCity(), ValidationFormat.CITY, false));
		errorList.addIfNotNull(checkFormat(&quot;State&quot;, p.getState(), ValidationFormat.STATE, false));
		errorList.addIfNotNull(checkFormat(&quot;Zip Code&quot;, p.getZip(), ValidationFormat.ZIPCODE, false));
		errorList
				.addIfNotNull(checkFormat(&quot;Phone Number&quot;, p.getPhone(), ValidationFormat.PHONE_NUMBER, false));
		errorList
		.addIfNotNull(checkFormat(&quot;Email&quot;, p.getEmail(), ValidationFormat.EMAIL, true));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ProcedureBeanValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.UpdateNDCodeListAction;
import edu.ncsu.csc.itrust.beans.ProcedureBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validates an ND code, from {@link UpdateNDCodeListAction}
 * 
 * @author Andy
 * 
 */
public class ProcedureBeanValidator extends BeanValidator&lt;ProcedureBean&gt; {
	/**
	 * The default constructor.
	 */
	public ProcedureBeanValidator() {
	}

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(ProcedureBean p) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;CPT Code&quot;, p.getCPTCode(), ValidationFormat.CPT, false));
		errorList.addIfNotNull(checkFormat(&quot;Description&quot;, p.getDescription(),
				ValidationFormat.CPT_CODE_DESCRIPTION, false));
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_RemoteMonitoringDataBeanValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.AddRemoteMonitoringDataAction;
import edu.ncsu.csc.itrust.beans.RemoteMonitoringDataBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validator used to validate adding new remote monitoring data in {@link AddRemoteMonitoringDataAction}
 * 
 */
public class RemoteMonitoringDataBeanValidator extends BeanValidator&lt;RemoteMonitoringDataBean&gt; {
	/**
	 * The default constructor.
	 */
	public RemoteMonitoringDataBeanValidator() {
	}
	
	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(RemoteMonitoringDataBean m) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;Systolic Blood Pressure&quot;, &quot;&quot; + m.getSystolicBloodPressure(),
				ValidationFormat.SYSTOLIC_BLOOD_PRESSURE, false));
		errorList.addIfNotNull(checkFormat(&quot;Diastolic Blood Pressure&quot;, &quot;&quot; + m.getDiastolicBloodPressure(),
				ValidationFormat.DIASTOLIC_BLOOD_PRESSURE, false));
		errorList.addIfNotNull(checkFormat(&quot;Glucose Level&quot;, &quot;&quot; + m.getGlucoseLevel(),
				ValidationFormat.GLUCOSE_LEVEL, false));
		if (errorList.hasErrors()){
			throw new FormValidationException(errorList);
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SecurityQAValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.action.SetSecurityQuestionAction;
import edu.ncsu.csc.itrust.beans.SecurityQA;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validates the security question and answer. This doesn't follow the same format as the others because this
 * validator is used for the various states of reset password, {@link SetSecurityQuestionAction}
 * 
 * @author Andy
 * 
 */
public class SecurityQAValidator extends BeanValidator&lt;SecurityQA&gt; {
	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(SecurityQA bean) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		if (null == bean)
			throw new FormValidationException(&quot;Null form&quot;);

		if (null == bean.getConfirmAnswer())
			throw new FormValidationException(&quot;Confirm answer cannot be empty&quot;);

		if (!bean.getAnswer().equals(bean.getConfirmAnswer()))
			throw new FormValidationException(&quot;Security answers do not match&quot;);

		errorList.addIfNotNull(checkFormat(&quot;Security Question&quot;, bean.getQuestion(),
				ValidationFormat.QUESTION, false));
		errorList.addIfNotNull(checkFormat(&quot;Security Answer&quot;, bean.getAnswer(), ValidationFormat.ANSWER,
				false));

		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SurveySearchValidator</id>
            <content>package edu.ncsu.csc.itrust.validate;

import edu.ncsu.csc.itrust.beans.SurveyResultBean;
import edu.ncsu.csc.itrust.exception.ErrorList;
import edu.ncsu.csc.itrust.exception.FormValidationException;

/**
 * Validator for zip code that is entered when a user searches for HCP survey results.
 */
public class SurveySearchValidator extends BeanValidator&lt;SurveyResultBean&gt;{

	/**
	 * Performs the act of validating the bean in question, which varies depending on the
	 * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.
	 * 
	 * @param p A bean of the type to be validated.
	 */
	@Override
	public void validate(SurveyResultBean bean) throws FormValidationException {
		ErrorList errorList = new ErrorList();
		errorList.addIfNotNull(checkFormat(&quot;Zip Code&quot;, bean.getHCPzip(), ValidationFormat.ZIPCODE, false));
		
		if (errorList.hasErrors())
			throw new FormValidationException(errorList);
	}

}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ValidationFormat</id>
            <content>package edu.ncsu.csc.itrust.validate;

import java.util.regex.Pattern;

/**
 * Enum with all of the validation formats that fit into a regex.
 * 
 * @author Andy
 * 
 *
 */


public enum ValidationFormat {
	NAME(&quot;[\\sa-zA-Z'-]{1,20}&quot;, &quot;Up to 20 Letters, space, ' and -&quot;), DATE(&quot;[\\d]{2}/[\\d]{2}/[\\d]{4}&quot;,
			&quot;MM/DD/YYYY&quot;),
			PHONE_NUMBER(&quot;[\\d]{3}-[\\d]{3}-[\\d]{4}&quot;, &quot;xxx-xxx-xxxx&quot;),
			MID(&quot;[\\d]{1,10}&quot;,
			&quot;Between 1 and 10 digits&quot;), ROLE(&quot;^(?:admin|hcp|uap|test)$&quot;,
			&quot;must be one of {admin, hcp, uap, test}&quot;),
			EMAIL(&quot;^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*((\\.[A-Za-z]{2,}){1}$)&quot;,
					&quot;Up to 30 alphanumeric characters and symbols . and _ @&quot;), 
	QUESTION(&quot;[a-zA-Z0-9?\\-'.\\s]{1,50}&quot;, &quot;Up to 50 alphanumeric characters and symbols ?-'.&quot;),
	ANSWER(&quot;[a-zA-Z0-9\\s]{1,30}&quot;, &quot;Up to 30 alphanumeric characters&quot;),
	ADDRESS(&quot;[a-zA-Z0-9.\\s]{1,30}&quot;, &quot;Up to 30 alphanumeric characters, and .&quot;),
	APPT_COMMENT(&quot;[0-9a-zA-Z\\s'\&quot;?!:;\\-._\n\t]{1,1000}&quot;, &quot;Between 0 and 1000 alphanumerics with space, and other punctuation&quot;),
	APPT_TYPE_NAME(&quot;[a-zA-Z ]{1,30}&quot;, &quot;Between 1 and 30 alpha characters and space&quot;),
	APPT_TYPE_DURATION(&quot;[0-9]{1,5}&quot;, &quot;Between 1 and 5 numberics&quot;),
	CITY(&quot;[a-zA-Z\\s]{1,15}&quot;, &quot;Up to 15 characters&quot;),
	STATE(&quot;[A-Z]{2}&quot;, &quot;Two capital letters&quot;),
	ZIPCODE(&quot;([0-9]{5})|([0-9]{5}-[0-9]{4})&quot;, &quot;xxxxx or xxxxx-xxxx&quot;), // ^[0-9]{5}(?:-[0-9]{4})?$
	BLOODTYPE(&quot;((O)|(A)|(B)|(AB))([+-]{1})&quot;, &quot;Must be [O,A,B,AB]+/-&quot;), // ^(?:O|A|B|AB)[+-]$
	GENDER(&quot;(Male)|(Female)&quot;, &quot;Only Male or Female&quot;), // ^(?:Male|Female)$
	NOTES(&quot;[a-zA-Z0-9\\s'\&quot;?!:;\\-._\n\t]{1,300}&quot;,
			&quot;Up to 300 alphanumeric characters, with space, and other punctuation&quot;),
	MESSAGES_BODY(&quot;[a-zA-Z0-9\\s'\&quot;?!:;\\-.,_\n\t()]{1,1000}&quot;,
			&quot;Up to 1000 alphanumeric characters, with space, and other punctuation&quot;),
	MESSAGES_SUBJECT(&quot;[a-zA-Z0-9\\s'\&quot;?!:;\\-._\n\t()]{1,100}&quot;,
			&quot;Up to 100 alphanumeric characters, with space, and other punctuation&quot;),
	PASSWORD(&quot;[a-zA-Z0-9]{8,20}&quot;, &quot;8-20 alphanumeric characters&quot;),
	INSURANCE_ID(&quot;[\\s\\da-zA-Z'-]{1,20}&quot;, &quot;Up to 20 letters, digits, space, ' and -&quot;),
	HOSPITAL_ID(&quot;[\\d]{1,10}&quot;, &quot;Between 1 and 10 digits&quot;),
	HOSPITAL_NAME(&quot;[0-9a-zA-Z' .]{1,30}&quot;, &quot;Between 1 and 30 alphanumerics, space, ', and .&quot;),
	ND_CODE_DESCRIPTION(&quot;[a-zA-Z0-9\\s]{1,100}&quot;, &quot;Up to 100 characters, letters, numbers, and a space&quot;),
	DRUG_INT_COMMENTS(&quot;[a-zA-Z0-9.\\-',!;:()?\\s]{1,500}&quot;, &quot;Up to 500 alphanumeric characters and .-',!;:()?&quot;),
	EMAILS(&quot;[a-zA-Z0-9.\\-',!;:()?\\s]{1,500}&quot;, &quot;Up to 500 alphanumeric characters and .-',!;:()?&quot;),
	ADVERSE_EVENT_COMMENTS(&quot;[a-zA-Z0-9.\\-',!;:()?\\s]{1,2000}&quot;, &quot;Up to 2000 alphanumeric characters and .-',!;:()?&quot;),
	ICD_CODE_DESCRIPTION(&quot;[a-zA-Z0-9\\s]{1,30}&quot;, &quot;Up to 30 characters, letters, numbers, and a space&quot;),
	CPT_CODE_DESCRIPTION(&quot;[a-zA-Z0-9\\s]{1,30}&quot;, &quot;Up to 30 characters, letters, numbers, and a space&quot;),
	ALLERGY_DESCRIPTION(&quot;[a-zA-Z0-9\\s]{1,30}&quot;, &quot;Up to 30 characters, letters, numbers, and a space&quot;),
	ICD9CM(&quot;([\\d]{1,3})|([\\d]{1,3}\\.[\\d]{0,2})&quot;, &quot;xxx.xx&quot;),
	CPT(&quot;[\\d]{1,4}[A-Za-z0-9]&quot;, &quot;Up to four digit integer plus a letter or digit&quot;),
	Height(&quot;[\\d]{0,3}(\\.(\\d){0,1}){0,1}&quot;, &quot;Up to 3-digit number + up to 1 decimal place&quot;),
	Weight(&quot;[\\d]{0,4}(\\.(\\d){0,1}){0,1}&quot;, &quot;Up to 4-digit number + up to 1 decimal place&quot;),
	YEAR(&quot;[\\d]{4}&quot;, &quot;Must be 4 digits&quot;), 
	GENDERCOD(&quot;(Male)|(Female)|(Not Specified)&quot;, &quot;Only Male, Female, or All Patients&quot;),
	ND(&quot;[\\d]{1,9}&quot;, &quot;Up to nine digit integer&quot;),
	LOINC(&quot;[\\d]{5}[-]{1}[\\d]{1}&quot;, &quot;Must be in format nnnnn-n&quot;),
	LOINC_ITEM(&quot;[a-zA-Z0-9\\s]{1,100}&quot;, &quot;Up to 100 characters, letters, numbers, and a space&quot;),
	COMMENTS(&quot;[a-zA-Z0-9.\\s]{1,500}&quot;, &quot;Up to 500 alphanumeric characters&quot;),
	LAB_STATUS(&quot;(NOT YET RECEIVED)|(PENDING)|(COMPLETED)&quot;, &quot;Only NOT YET RECEIVED, PENDING, or COMPLETED&quot;),
	LAB_RIGHTS(&quot;(ALLOWED)|(RESTRICTED)&quot;, &quot;Only ALLOWED, or RESTRICTED&quot;),
	SYSTOLIC_BLOOD_PRESSURE(&quot;^([4-9][0-9]|1[0-9][0-9]|2[0-3][0-9]|240)$&quot;, &quot;Must be between 40 and 240&quot;),
	DIASTOLIC_BLOOD_PRESSURE(&quot;^([4-9][0-9]|1[0-4][0-9]|150)$&quot;, &quot;Must be between 40 and 150&quot;),
	GLUCOSE_LEVEL(&quot;^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|250)$&quot;, &quot;Must be between 0 and 250&quot;);
	

	private Pattern regex;
	private String description;

	ValidationFormat(String regex, String errorMessage) {
		this.regex = Pattern.compile(regex);
		this.description = errorMessage;
	}

	public Pattern getRegex() {
		return regex;
	}

	public String getDescription() {
		return description;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ICD9CMLink</id>
            <content>package edu.ncsu.csc.itrust.tags;

import java.io.IOException;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.JspWriter;
import javax.servlet.jsp.PageContext;
import javax.servlet.jsp.tagext.Tag;

/**
 * JSP tag used as a utility to link to the actual ICD9CM site
 * 
 * @author Andy
 * 
 */
public class ICD9CMLink implements Tag {
	private PageContext pageContext;
	private Tag parent;
	private String code;

	public ICD9CMLink() {
		super();
	}

	public int doStartTag() throws JspException {
		try {
			JspWriter out = pageContext.getOut();
			out.write(&quot;&lt;a href=\&quot;http://icd9cm.chrisendres.com/2007/index.php?srchtype=diseases&amp;srchtext=&quot;
					+ code + &quot;&amp;Submit=Search&amp;action=search\&quot;&gt;&quot; + code + &quot;&lt;/a&gt;&quot;);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return SKIP_BODY;
	}

	public int doEndTag() throws JspException {
		return SKIP_BODY;
	}

	public void release() {
	}

	public void setPageContext(PageContext pageContext) {
		this.pageContext = pageContext;
	}

	public void setParent(Tag parent) {
		this.parent = parent;
	}

	public Tag getParent() {
		return parent;
	}

	public String getCode() {
		return code;
	}

	public void setCode(String code) {
		this.code = code;
	}

	public void setCode(double code) {
		this.code = String.valueOf(code);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PatientNavigation</id>
            <content>package edu.ncsu.csc.itrust.tags;

import java.io.IOException;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.JspWriter;
import javax.servlet.jsp.PageContext;
import javax.servlet.jsp.tagext.Tag;

/**
 * JSP tag that is used as the patient navigation bar at the bottom of the screen.
 * 
 * To add a new page, add to the two arrays, and make sure that the page accepts PID
 * 
 * @author Andy
 * 
 */
public class PatientNavigation implements Tag {
	private PageContext pageContext;
	private Tag parent;
	// A more elegant solution here would be to use enums and have a displayName, a name, and url
	private String pageTitles[] = { &quot;Health Records&quot;, &quot;Basic Health History&quot;, &quot;Demographics&quot;,
			&quot;Document Office Visit&quot;, &quot;Risk Factors&quot;, &quot;Prescriptions&quot; };
	private String pageURLs[] = { &quot;editPHR.jsp&quot;, &quot;editBasicHealth.jsp&quot;, &quot;editPatient.jsp&quot;,
			&quot;documentOfficeVisit.jsp&quot;, &quot;chronicDiseaseRisks.jsp&quot;, &quot;getPrescriptionReport.jsp&quot; };
	private String thisTitle;

	public PatientNavigation() {
		super();
	}

	public int doStartTag() throws JspException {
		try {
			JspWriter out = pageContext.getOut();
			out.write(&quot;&lt;span class=\&quot;navigation\&quot;&gt;&quot;);
			for (int i = 0; i &lt; pageTitles.length; i++) {
				if (pageTitles[i].equals(thisTitle)) {
					out.write(pageTitles[i]);
				} else
					out.write(&quot;&lt;a href=\&quot;/iTrust/auth/hcp-uap/&quot; + pageURLs[i] + &quot;\&quot;&gt;&quot;
							+ pageTitles[i] + &quot;&lt;/a&gt;&quot;);
				out.write(&quot; | &quot;);
			}
			out.write(&quot;&lt;a href=\&quot;/iTrust/auth/hcp-uap/editPHR.jsp?switch=true\&quot;&gt;Switch Patient&lt;/a&gt;&quot;);
			out.write(&quot;&lt;br /&gt;&lt;/span&gt;&quot;);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return SKIP_BODY;
	}

	public int doEndTag() throws JspException {
		return SKIP_BODY;
	}

	public void release() {
	}

	public void setPageContext(PageContext pageContext) {
		this.pageContext = pageContext;
	}

	public void setParent(Tag parent) {
		this.parent = parent;
	}

	public Tag getParent() {
		return parent;
	}

	public String getThisTitle() {
		return thisTitle;
	}

	public void setThisTitle(String thisPage) {
		this.thisTitle = thisPage;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_StateSelect</id>
            <content>package edu.ncsu.csc.itrust.tags;

import java.io.IOException;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.JspWriter;
import javax.servlet.jsp.PageContext;
import javax.servlet.jsp.tagext.Tag;
import edu.ncsu.csc.itrust.enums.State;

/**
 * JSP tag that adds an HTML select for states, from the enum.
 * 
 * @see {@link State}
 * 
 * Also selects the current state
 * @author Andy
 * 
 */
public class StateSelect implements Tag {
	private PageContext pageContext;
	private Tag parent;
	private String name;
	private String value;

	public StateSelect() {
		super();
	}

	public int doStartTag() throws JspException {
		try {
			JspWriter out = pageContext.getOut();
			out.write(&quot;&lt;select name=\&quot;&quot; + getName() + &quot;\&quot; &gt;&quot;);
			if (name == null || &quot;&quot;.equals(name))
				out.write(&quot;&lt;option value=\&quot;\&quot;&gt;Select State&lt;/option&gt;&quot;);
			for (State state : State.values()) {
				String selected = state.toString().equals(getValue()) ? &quot;selected=selected&quot; : &quot;&quot;;
				out.write(&quot;&lt;option value=\&quot;&quot; + state.toString() + &quot;\&quot; &quot; + selected + &quot;&gt;&quot; + state.getName()
						+ &quot;&lt;/option&gt;&quot;);
			}
			out.write(&quot;&lt;/select&gt;&quot;);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return SKIP_BODY;
	}

	public int doEndTag() throws JspException {
		return SKIP_BODY;
	}

	public void release() {
	}

	public void setPageContext(PageContext pageContext) {
		this.pageContext = pageContext;
	}

	public void setParent(Tag parent) {
		this.parent = parent;
	}

	public Tag getParent() {
		return parent;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getValue() {
		return value;
	}

	public void setValue(String value) {
		this.value = value;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_BloodType</id>
            <content>package edu.ncsu.csc.itrust.enums;

/**
 * All possible blood types
 * 
 * @author Andy
 * 
 */
public enum BloodType {
	APos(&quot;A+&quot;), ANeg(&quot;A-&quot;), BPos(&quot;B+&quot;), BNeg(&quot;B-&quot;), ABPos(&quot;AB+&quot;), ABNeg(&quot;AB-&quot;), OPos(&quot;O+&quot;), ONeg(&quot;O-&quot;), NS(
			&quot;N/S&quot;);
	private String name;

	private BloodType(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	@Override
	public String toString() {
		return getName();
	}

	public static BloodType parse(String bloodTypeStr) {
		for (BloodType type : BloodType.values()) {
			if (type.getName().equals(bloodTypeStr)) {
				return type;
			}
		}
		return NS;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_Ethnicity</id>
            <content>package edu.ncsu.csc.itrust.enums;

/**
 * All possible ethnicities represented in iTrust.
 */
public enum Ethnicity {
	Caucasian(&quot;Caucasian&quot;), AfricanAmerican(&quot;African American&quot;), Hispanic(&quot;Hispanic&quot;), AmericanIndian(
			&quot;American Indian&quot;), Asian(&quot;Asian&quot;), NotSpecified(&quot;Not Specified&quot;);
	private String name;

	private Ethnicity(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	@Override
	public String toString() {
		return getName();
	}

	public static Ethnicity parse(String input) {
		for (Ethnicity ethnicity : Ethnicity.values()) {
			if (ethnicity.name.equals(input))
				return ethnicity;
		}
		return NotSpecified;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_Gender</id>
            <content>package edu.ncsu.csc.itrust.enums;

/**
 * Male or Female.  Not specified is provided as well, for incomplete forms or patient's discretion.
 */
public enum Gender {
	Male(&quot;Male&quot;), Female(&quot;Female&quot;), NotSpecified(&quot;Not Specified&quot;);
	private String name;

	private Gender(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	@Override
	public String toString() {
		return getName();
	}

	public static Gender parse(String input) {
		for (Gender gender : Gender.values()) {
			if (gender.name.equals(input))
				return gender;
		}
		return NotSpecified;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PrescriptionAlerts</id>
            <content>package edu.ncsu.csc.itrust.enums;

/**
 * Every prescription that should be alerted for emergency reports - in the future, this should be abstracted
 * out to a database table so it can be changed at runtime.
 * 
 * @author Andy
 * 
 */
public enum PrescriptionAlerts {
	Tetracycline(&quot;Tetracycline&quot;, &quot;009042407&quot;), Prioglitazone(&quot;Prioglitazone&quot;, &quot;647641512&quot;);

	private String name;
	private String NDCode;

	private PrescriptionAlerts(String rName, String rNDCode) {
		this.name = rName;
		this.NDCode = rNDCode;
	}

	public String getName() {
		return name;
	}

	public String getNDCode() {
		return this.NDCode;
	}

	public static boolean isAlert(String code) {
		for (PrescriptionAlerts thisone : values()) {
			if (thisone.getNDCode().equals(code))
				return true;
		}
		return false;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_Role</id>
            <content>package edu.ncsu.csc.itrust.enums;

/**
 * The iTrust user roles: Patient, ER, HCP, UAP, PHA, Administrator and Tester.
 * Consult the requirements for the contextual meanings of these individual choices.
 */
public enum Role {
	PATIENT(&quot;patient&quot;, &quot;Patients&quot;), 
	ER(&quot;er&quot;, &quot;Personnel&quot;), 
	HCP(&quot;hcp&quot;, &quot;Personnel&quot;), 
	UAP(&quot;uap&quot;, &quot;Personnel&quot;), 
	ADMIN(&quot;admin&quot;, &quot;Personnel&quot;),
	PHA(&quot;pha&quot;, &quot;Personnel&quot;),
	TESTER(&quot;tester&quot;, &quot;&quot;);
	
	private String userRolesString;
	private String dbTable;

	Role(String userRolesString, String dbTable) {
		this.userRolesString = userRolesString;
		this.dbTable = dbTable;
	}

	public String getDBTable() {
		return dbTable;
	}

	public String getUserRolesString() {
		return userRolesString;
	}

	public static Role parse(String str) {
		for (Role role : values()) {
			if (role.userRolesString.equals(str))
				return role;
		}
		throw new IllegalArgumentException(&quot;Role &quot; + str + &quot; does not exist&quot;);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_State</id>
            <content>package edu.ncsu.csc.itrust.enums;

/**
 * All of our wonderful states.
 * 
 * @author Andy
 * 
 */
public enum State {
	AL(&quot;Alabama&quot;), AK(&quot;Alaska&quot;), AZ(&quot;Arizona&quot;), AR(&quot;Arkansas&quot;), CA(&quot;California&quot;), CO(&quot;Colorado&quot;), CT(
			&quot;Connecticut&quot;), DE(&quot;Delaware&quot;), DC(&quot;District of Columbia&quot;), FL(&quot;Florida&quot;), GA(&quot;Georgia&quot;), HI(
			&quot;Hawaii&quot;), ID(&quot;Idaho&quot;), IL(&quot;Illinois&quot;), IN(&quot;Indiana&quot;), IA(&quot;Iowa&quot;), KS(&quot;Kansas&quot;), KY(&quot;Kentucky&quot;), LA(
			&quot;Louisiana&quot;), ME(&quot;Maine&quot;), MD(&quot;Maryland&quot;), MA(&quot;Massachusetts&quot;), MI(&quot;Michigan&quot;), MN(&quot;Minnesota&quot;), MS(
			&quot;Mississippi&quot;), MO(&quot;Missouri&quot;), MT(&quot;Montana&quot;), NE(&quot;Nebraska&quot;), NV(&quot;Nevada&quot;), NH(&quot;New Hampshire&quot;), NJ(
			&quot;New Jersey&quot;), NM(&quot;New Mexico&quot;), NY(&quot;New York&quot;), NC(&quot;North Carolina&quot;), ND(&quot;North Dakota&quot;), OH(
			&quot;Ohio&quot;), OK(&quot;Oklahoma&quot;), OR(&quot;Oregon&quot;), PA(&quot;Pennsylvania&quot;), RI(&quot;Rhode Island&quot;), SC(
			&quot;South Carolina&quot;), SD(&quot;South Dakota&quot;), TN(&quot;Tennessee&quot;), TX(&quot;Texas&quot;), UT(&quot;Utah&quot;), VT(&quot;Vermont&quot;), VA(
			&quot;Virginia&quot;), WA(&quot;Washington&quot;), WV(&quot;West Virginia&quot;), WI(&quot;Wisconsin&quot;), WY(&quot;Wyoming&quot;);
	private String name;

	private State(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public String getAbbrev() {
		return toString();
	}

	// Just to show that this is intentional
	@Override
	public String toString() {
		return super.toString();
	}

	public static State parse(String state) {
		State[] values = State.values();
		for (State myState : values) {
			if (myState.getName().equals(state) || myState.getAbbrev().equals(state))
				return myState;
		}
		return State.NC;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_TransactionType</id>
            <content>package edu.ncsu.csc.itrust.enums;

/**
 * All of the possible transaction types, in no particular order, used in producing the operational profile.
 */
public enum TransactionType {
	ENTER_EDIT_DEMOGRAPHICS(1, &quot;Enter/Edit patient/personnel demographics&quot;),
	DECLARE_HCP(2, &quot;View HCP / Change designation&quot;),
	ALLOW_DISALLOW_ACCESS(3, &quot;Allow/Disallow access to patient diagnosis&quot;),
	VIEW_ACCESS_LOG(4, &quot;View patient's record access log&quot;),
	VIEW_RECORDS(5, &quot;View patient's medical records&quot;),
	AUTHENTICATE_USER(6, &quot;Authenticate user&quot;),
	ENTER_EDIT_PHR(7, &quot;Enter/Edit Personal Health Information&quot;),
	DOCUMENT_OFFICE_VISIT(8, &quot;Document an office visit&quot;),
	CREATE_DISABLE_PATIENT_HCP(9, &quot;Create or disable a patient or hcp&quot;),
	MANAGE_DIAGNOSIS_CODE(10, &quot;Manage ICD9CM diagnosis codes&quot;),
	REQUEST_BIOSURVEILLANCE(11, &quot;Request biosurveillance&quot;),
	MANAGE_PROCEDURE_CODE(12, &quot;Manage CPT Procedure Codes&quot;),
	MANAGE_DRUG_CODE(13, &quot;Manage ND Drug Codes&quot;),
	IDENTIFY_RISK_FACTORS(14, &quot;Identify risk factors for chronic diseases&quot;),
	CAUSE_OF_DEATH(15, &quot;Examine cause-of-death trends&quot;),
	DECLARE_REPRESENTATIVE(16, &quot;Declare Personal Health Representative&quot;),
	PATIENT_REMINDERS(17, &quot;Proactively determine necessary patient care&quot;),
	MAINTAIN_HOSPITALS(18, &quot;Maintain hospital listing&quot;),
	VIEW_PRESCRIPTION_REPORT(19, &quot;View prescription report&quot;),
	VIEW_HOSPITAL_STATS(20, &quot;View hospital statistics&quot;),
	VIEW_COMPREHENSIVE_RECORD(21, &quot;View comprehensive patient report&quot;),
	VIEW_EMERGENCY_REPORT(22, &quot;View emergency patient report&quot;),
	COMPREHENSIVE_REPORT_REQUEST(28, &quot;Comprehensive patient report&quot;),
	VIEW_LAB_PROCEDURE(29, &quot;View lab procedure&quot;),
	ENTER_EDIT_LAB_PROCEDURE(30, &quot;Enter/Edit lab procedure&quot;),
	MANAGE_LOINC(31, &quot;Enter/Edit LOINC Code&quot;),
	ADD_PATIENT_SURVEY(32, &quot;Added Patient Survey&quot;),
	View_HCP_SURVEY_RESULTS(33, &quot;View HCP survey results&quot;),
	VIEW_PATIENT_LIST(34, &quot;View Patient List&quot;),
	FIND_HCPS_WITH_EXP(35, &quot;Find LHCPs with experience with a diagnosis&quot;),
	VIEW_HEALTH_RECORDS(36, &quot;View Patient Health Records&quot;),
	VIEW_OFFICE_VISIT(37, &quot;View Office Visit&quot;),
	ADD_PRESCRIPTION(38, &quot;Add Prescription&quot;),
	UPDATE_OFFICE_VISIT(39, &quot;Update an Office Visit&quot;),
	SEND_MESSAGE(40, &quot;Send a Message&quot;),
	VIEW_RENEWAL_NEEDS_PATIENTS(41, &quot;View renewal needs patients&quot;),
	SEND_REFERRAL(42, &quot;Refer patient to hcp&quot;),
	CREATE_DISABLE_ER(43, &quot;Create/disable emergency responder&quot;),
	TELEMEDICINE_MONITORING(45, &quot;Telemedicine monitoring&quot;),
	CREATE_DISABLE_PHA(47, &quot;Create/disable public health agent&quot;),
	DRUG_INTERACTION(48, &quot;Drug Interaction&quot;),
	ADVERSE_EVENT(49, &quot;Adverse Event Report&quot;),
	LOGIN_FAILURE(50, &quot;Login Failure&quot;),
	UPDATE_APPT_TYPE(51, &quot;Update an Appointment Type&quot;),
	ADD_APPT_TYPE(52, &quot;Add an Appointment Type&quot;),
	ADD_APPT(53, &quot;Appointment Added&quot;),
	SEND_REMINDERS(54, &quot;Reminders Sent&quot;);


	
	// S1, S3, S5, S7, S8, S14, S16, S19, S21, S22.
	public static final String patientViewableStr = &quot;1,3,5,7,8,14,16,19,21,22,30,39,45&quot;;
	public static final int[] patientViewable = { 1, 3, 5, 7, 8, 14, 16, 19, 21, 22, 30, 39, 45 };

	private TransactionType(int code, String description) {
		this.code = code;
		this.description = description;
	}

	private int code;
	private String description;

	public int getCode() {
		return code;
	}

	public String getDescription() {
		return description;
	}

	public static TransactionType parse(int code) {

		for (TransactionType type : TransactionType.values()) {
			if (type.code == code)
				return type;
		}
		throw new IllegalArgumentException(&quot;No transaction type exists for code &quot; + code);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ChronicDiseaseMediator</id>
            <content>package edu.ncsu.csc.itrust.risk;

import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.NoHealthRecordsException;

/**
 * Figures out which risk checker strategy to use
 * 
 * @author Andy
 * 
 */
public class ChronicDiseaseMediator {
	private List&lt;RiskChecker&gt; riskCheckers;

	/**
	 * Given a factory and patient ID, and sets up a list of all risk checkers
	 * 
	 * @param factory The DAOFactory to be used in creating the necessary DAOs to perform the checks.
	 * @param pid The MID of the patient in question.
	 * @throws DBException
	 * @throws NoHealthRecordsException
	 */
	public ChronicDiseaseMediator(DAOFactory factory, long pid) throws DBException, NoHealthRecordsException {
		riskCheckers = new ArrayList&lt;RiskChecker&gt;();
		riskCheckers.add(new HeartDiseaseRisks(factory, pid));
		riskCheckers.add(new Type1DiabetesRisks(factory, pid));
		riskCheckers.add(new Type2DiabetesRisks(factory, pid));
	}

	/**
	 * @return A list of diseases that this patient is at risk for
	 */
	public List&lt;RiskChecker&gt; getDiseaseAtRisk() {
		List&lt;RiskChecker&gt; diseases = new ArrayList&lt;RiskChecker&gt;();
		for (RiskChecker diseaseChecker : riskCheckers) {
			if (diseaseChecker.isAtRisk())
				diseases.add(diseaseChecker);
		}
		return diseases;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_HeartDiseaseRisks</id>
            <content>package edu.ncsu.csc.itrust.risk;

import static edu.ncsu.csc.itrust.enums.Ethnicity.AfricanAmerican;
import static edu.ncsu.csc.itrust.enums.Ethnicity.AmericanIndian;
import static edu.ncsu.csc.itrust.enums.Ethnicity.Hispanic;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.enums.Gender;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.NoHealthRecordsException;
import edu.ncsu.csc.itrust.risk.factors.AgeFactor;
import edu.ncsu.csc.itrust.risk.factors.CholesterolFactor;
import edu.ncsu.csc.itrust.risk.factors.EthnicityFactor;
import edu.ncsu.csc.itrust.risk.factors.FamilyHistoryFactor;
import edu.ncsu.csc.itrust.risk.factors.GenderFactor;
import edu.ncsu.csc.itrust.risk.factors.HypertensionFactor;
import edu.ncsu.csc.itrust.risk.factors.PatientRiskFactor;
import edu.ncsu.csc.itrust.risk.factors.PriorDiagnosisFactor;
import edu.ncsu.csc.itrust.risk.factors.SmokingFactor;
import edu.ncsu.csc.itrust.risk.factors.WeightFactor;

/**
 * Checks to see if the given patient is at risk for Heart Disease
 * For details on what each method does, see {@link RiskChecker}
 * @author Andy
 * 
 */
public class HeartDiseaseRisks extends RiskChecker {
	public HeartDiseaseRisks(DAOFactory factory, long patientID) throws DBException, NoHealthRecordsException {
		super(factory, patientID);
	}

	@Override
	public boolean qualifiesForDisease() {
		return true;
	}

	@Override
	protected List&lt;PatientRiskFactor&gt; getDiseaseRiskFactors() {
		List&lt;PatientRiskFactor&gt; factors = new ArrayList&lt;PatientRiskFactor&gt;();
		factors.add(new GenderFactor(patient, Gender.Male));
		factors.add(new AgeFactor(patient, 45));
		factors.add(new EthnicityFactor(patient, Hispanic, AfricanAmerican, AmericanIndian));
		factors.add(new WeightFactor(currentHealthRecord, 30));
		factors.add(new HypertensionFactor(currentHealthRecord));
		factors.add(new CholesterolFactor(currentHealthRecord));
		factors.add(new SmokingFactor(factory, patient.getMID()));
		factors.add(new PriorDiagnosisFactor(factory, patient.getMID(), 250.0, 251.0));
		factors.add(new FamilyHistoryFactor(factory, patient.getMID(), 350.0, 460.0));
		return factors;
	}

	@Override
	public String getName() {
		return &quot;Heart Disease&quot;;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_RiskChecker</id>
            <content>package edu.ncsu.csc.itrust.risk;

import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.beans.HealthRecord;
import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.dao.mysql.HealthRecordsDAO;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.NoHealthRecordsException;
import edu.ncsu.csc.itrust.risk.factors.PatientRiskFactor;

/**
 * An abstract class which has a number of utlity methods for checking risks.
 * 
 * When extending this class, use the methods to fill in all of the necessary information. Then use isAtRisk
 * and getPatientRiskFactors to get the actual risks. See the known subclasses for an example
 * 
 * @author Andy
 * 
 */
abstract public class RiskChecker {
	private static final int RISK_THRESHOLD = 3;
	protected PatientBean patient;
	protected HealthRecord currentHealthRecord;
	protected DAOFactory factory;

	public RiskChecker(DAOFactory factory, long patientID) throws DBException, NoHealthRecordsException {
		this.factory = factory;
		HealthRecordsDAO hrDAO = factory.getHealthRecordsDAO();
		List&lt;HealthRecord&gt; records = hrDAO.getAllHealthRecords(patientID);
		if (records.size() &gt; 0)
			currentHealthRecord = records.get(0);
		else
			throw new NoHealthRecordsException();

		patient = factory.getPatientDAO().getPatient(patientID);
	}

	/**
	 * @return The name of the disease being checked.
	 */
	abstract public String getName();

	/**
	 * @return A java.util.List of the risk factors increasing this patients disease risk.
	 */
	abstract protected List&lt;PatientRiskFactor&gt; getDiseaseRiskFactors();

	/**
	 * @return A boolean indicating whether the patient is at increased risk.
	 */
	abstract public boolean qualifiesForDisease();

	/**
	 * This method exists purely for performance - just stop once you hit the threshold. &lt;br /&gt;
	 * &lt;br /&gt;
	 * Also, the risk factors should be cached in the RiskFactor implementors - in getPatientRiskFactors there
	 * should be no double-querying
	 * 
	 * @return isAtRisk
	 */
	public boolean isAtRisk() {
		if (qualifiesForDisease()) {
			int numRisks = 0;
			List&lt;PatientRiskFactor&gt; diseaseRiskFactors = getDiseaseRiskFactors();
			for (PatientRiskFactor factor : diseaseRiskFactors) {
				if (factor.hasRiskFactor())
					numRisks++;
				if (numRisks &gt;= RISK_THRESHOLD)
					return true;
			}
		}
		return false; // both an else from qualifies or NOT over the threshold
	}

	/**
	 * @return A java.util.List of patient risk factors associated with this disease.
	 */
	public List&lt;PatientRiskFactor&gt; getPatientRiskFactors() {
		List&lt;PatientRiskFactor&gt; patientRiskFactors = new ArrayList&lt;PatientRiskFactor&gt;();
		List&lt;PatientRiskFactor&gt; diseaseRiskFactors = getDiseaseRiskFactors();
		for (PatientRiskFactor factor : diseaseRiskFactors) {
			if (factor.hasRiskFactor()) {
				patientRiskFactors.add(factor);
			}
		}
		return patientRiskFactors;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_Type1DiabetesRisks</id>
            <content>package edu.ncsu.csc.itrust.risk;

import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.enums.Ethnicity;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.NoHealthRecordsException;
import edu.ncsu.csc.itrust.risk.factors.ChildhoodInfectionFactor;
import edu.ncsu.csc.itrust.risk.factors.EthnicityFactor;
import edu.ncsu.csc.itrust.risk.factors.FamilyHistoryFactor;
import edu.ncsu.csc.itrust.risk.factors.PatientRiskFactor;

/**
 * Checks to see if the given patient is at risk for Type 1 Diabetes.
 * For details on what each method does, see {@link RiskChecker}
 * 
 * @author Andy
 * 
 */
public class Type1DiabetesRisks extends RiskChecker {
	public Type1DiabetesRisks(DAOFactory factory, long patientID) throws DBException,
			NoHealthRecordsException {
		super(factory, patientID);
	}

	@Override
	public boolean qualifiesForDisease() {
		return patient.getAge() &lt; 12;
	}

	@Override
	protected List&lt;PatientRiskFactor&gt; getDiseaseRiskFactors() {
		List&lt;PatientRiskFactor&gt; factors = new ArrayList&lt;PatientRiskFactor&gt;();
		factors.add(new EthnicityFactor(patient, Ethnicity.Caucasian));
		factors.add(new FamilyHistoryFactor(factory, patient.getMID(), 250.0, 251.0));
		factors.add(new ChildhoodInfectionFactor(factory, patient.getMID(), 79.30));
		return factors;
	}

	@Override
	public String getName() {
		return &quot;Type 1 Diabetes&quot;;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_Type2DiabetesRisks</id>
            <content>package edu.ncsu.csc.itrust.risk;

import static edu.ncsu.csc.itrust.enums.Ethnicity.AfricanAmerican;
import static edu.ncsu.csc.itrust.enums.Ethnicity.AmericanIndian;
import static edu.ncsu.csc.itrust.enums.Ethnicity.Asian;
import static edu.ncsu.csc.itrust.enums.Ethnicity.Hispanic;
import java.util.ArrayList;
import java.util.List;
import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;
import edu.ncsu.csc.itrust.exception.NoHealthRecordsException;
import edu.ncsu.csc.itrust.risk.factors.AgeFactor;
import edu.ncsu.csc.itrust.risk.factors.CholesterolFactor;
import edu.ncsu.csc.itrust.risk.factors.EthnicityFactor;
import edu.ncsu.csc.itrust.risk.factors.FamilyHistoryFactor;
import edu.ncsu.csc.itrust.risk.factors.HypertensionFactor;
import edu.ncsu.csc.itrust.risk.factors.PatientRiskFactor;
import edu.ncsu.csc.itrust.risk.factors.PriorDiagnosisFactor;
import edu.ncsu.csc.itrust.risk.factors.WeightFactor;

/**
 * Checks to see if the given patient is at risk for Type II Diabetes.
 * For details on what each method does, see {@link RiskChecker}
 * 
 * @author Andy
 * 
 */
public class Type2DiabetesRisks extends RiskChecker {
	public Type2DiabetesRisks(DAOFactory factory, long patientID) throws DBException,
			NoHealthRecordsException {
		super(factory, patientID);
	}

	@Override
	public boolean qualifiesForDisease() {
		return patient.getAge() &gt;= 12;
	}

	@Override
	protected List&lt;PatientRiskFactor&gt; getDiseaseRiskFactors() {
		List&lt;PatientRiskFactor&gt; factors = new ArrayList&lt;PatientRiskFactor&gt;();
		factors.add(new AgeFactor(patient, 45));
		factors.add(new EthnicityFactor(patient, Hispanic, AfricanAmerican, AmericanIndian, Asian));
		factors.add(new WeightFactor(currentHealthRecord, 25));
		factors.add(new HypertensionFactor(currentHealthRecord));
		factors.add(new CholesterolFactor(currentHealthRecord));
		factors.add(new PriorDiagnosisFactor(factory, patient.getMID(), 250.0, 251.0));
		factors.add(new FamilyHistoryFactor(factory, patient.getMID(), 250.0, 251.0));
		return factors;
	}

	@Override
	public String getName() {
		return &quot;Type 2 Diabetes&quot;;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_AgeFactor</id>
            <content>package edu.ncsu.csc.itrust.risk.factors;

import edu.ncsu.csc.itrust.beans.PatientBean;

/**
 * The risk factor associated with checking if a person is over a particular age
 * See {@link PatientRiskFactor} for details on what each method typically does.
 * @author Andy
 */
public class AgeFactor extends PatientRiskFactor {
	private PatientBean patient;
	private int age;

	public AgeFactor(PatientBean patient, int age) {
		this.age = age;
		this.patient = patient;
	}

	public String getDescription() {
		return &quot;Patient is over &quot; + age;
	}

	public boolean hasFactor() {
		return patient.getAge() &gt; age;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_ChildhoodInfectionFactor</id>
            <content>package edu.ncsu.csc.itrust.risk.factors;

import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Checks if the patient had the given diagnoses during childhood.
 * See {@link PatientRiskFactor} for details on what each method typically does.
 * 
 * @author Andy
 * 
 */
public class ChildhoodInfectionFactor extends PatientRiskFactor {
	private final double[] icdCodes;
	private final long patientID;
	private final DAOFactory factory;

	public ChildhoodInfectionFactor(DAOFactory factory, long mid, double... icdCodes) {
		this.factory = factory;
		this.patientID = mid;
		this.icdCodes = icdCodes.clone();
	}

	public String getDescription() {
		return &quot;This patient had a viral infection during their childhood that would increase the risk for this diesease&quot;;
	}

	public boolean hasFactor() {
		try {
			return factory.getRiskDAO().hadChildhoodInfection(patientID, icdCodes);
		} catch (DBException e) {
			System.err.println(&quot;DBException on Childhood Infection Risk, giving no risk&quot;);
			return false;
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_CholesterolFactor</id>
            <content>package edu.ncsu.csc.itrust.risk.factors;

import edu.ncsu.csc.itrust.beans.HealthRecord;

/**
 * Checks if cholesterol is over a given threshold for a given patient
 * See {@link PatientRiskFactor} for details on what each method typically does.
 * 
 * @author Andy
 * 
 */
public class CholesterolFactor extends PatientRiskFactor {
	private static final int hdlThreshold = 35;
	private static final int ldlThreshold = 240;
	private static final int triThreshold = 250;
	private HealthRecord record;

	public CholesterolFactor(HealthRecord currentHealthRecord) {
		this.record = currentHealthRecord;
	}

	public String getDescription() {
		return &quot;Patient has bad cholesterol&quot;;
	}

	public boolean hasFactor() {
		return (record.getCholesterolHDL() &lt; hdlThreshold) || (record.getCholesterolLDL() &gt; ldlThreshold)
				|| (record.getCholesterolTri() &gt; triThreshold);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_EthnicityFactor</id>
            <content>package edu.ncsu.csc.itrust.risk.factors;

import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.enums.Ethnicity;

/**
 * Checks if the ethnicity of a patient matches the one at risk
 * See {@link PatientRiskFactor} for details on what each method typically does.
 * 
 * @author Andy
 * 
 */
public class EthnicityFactor extends PatientRiskFactor {
	private Ethnicity[] atRisk;
	private PatientBean patient;

	public EthnicityFactor(PatientBean patient, Ethnicity... atRisks) {
		this.atRisk = atRisks.clone();
		this.patient = patient;
	}

	public String getDescription() {
		return &quot;Patient's ethnicity is &quot; + patient.getEthnicity();
	}

	public boolean hasFactor() {
		for (Ethnicity ethnicity : atRisk) {
			if (patient.getEthnicity().equals(ethnicity) &amp;&amp; !Ethnicity.NotSpecified.equals(ethnicity))
				return true;
		}
		return false;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_FamilyHistoryFactor</id>
            <content>package edu.ncsu.csc.itrust.risk.factors;

import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Checks if a patient has a family history of a given diagnosis range. Delegates straight to the DAO.
 * See {@link PatientRiskFactor} for details on what each method typically does.
 * 
 * @author Andy
 * 
 */
public class FamilyHistoryFactor extends PatientRiskFactor {
	private long patientID;
	private DAOFactory factory;
	private double icdUpper;
	private double icdLower;

	public FamilyHistoryFactor(DAOFactory factory, long patientID, double icdLower, double icdUpper) {
		this.factory = factory;
		this.patientID = patientID;
		this.icdLower = icdLower;
		this.icdUpper = icdUpper;
	}

	public String getDescription() {
		return &quot;Patient has a family history of this disease&quot;;
	}

	public boolean hasFactor() {
		try {
			return factory.getRiskDAO().hasFamilyHistory(patientID, icdLower, icdUpper);
		} catch (DBException e) {
			e.printStackTrace();
			return false;
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_GenderFactor</id>
            <content>package edu.ncsu.csc.itrust.risk.factors;

import edu.ncsu.csc.itrust.beans.PatientBean;
import edu.ncsu.csc.itrust.enums.Gender;

/**
 * Checks if the patient's gender matches the given at-risk one.
 * See {@link PatientRiskFactor} for details on what each method typically does.
 * 
 * @author Andy
 * 
 */
public class GenderFactor extends PatientRiskFactor {
	private PatientBean patient;
	private Gender gender;

	public GenderFactor(PatientBean patient, Gender gender) {
		this.patient = patient;
		this.gender = gender;
	}

	public String getDescription() {
		return &quot;Patient is &quot; + patient.getGender().toString().toLowerCase();
	}

	public boolean hasFactor() {
		return gender.equals(patient.getGender()) &amp;&amp; !gender.equals(Gender.NotSpecified);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_HypertensionFactor</id>
            <content>package edu.ncsu.csc.itrust.risk.factors;

import edu.ncsu.csc.itrust.beans.HealthRecord;

/**
 * Checks if the patient's blood pressure is above a given threshold.
 * See {@link PatientRiskFactor} for details on what each method typically does.
 * 
 * @author Andy
 * 
 */
public class HypertensionFactor extends PatientRiskFactor {
	private static final int systolicThreshold = 240;
	private static final int diastolicThreshold = 120;
	private HealthRecord record;

	public HypertensionFactor(HealthRecord currentHealthRecord) {
		this.record = currentHealthRecord;
	}

	public String getDescription() {
		return &quot;Patient has hypertension&quot;;
	}

	public boolean hasFactor() {
		return (record.getBloodPressureSystolic() &gt; systolicThreshold)
				|| (record.getBloodPressureDiastolic() &gt; diastolicThreshold);
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PatientRiskFactor</id>
            <content>package edu.ncsu.csc.itrust.risk.factors;

/**
 * Abstract class for risk factors, the hasRiskFactor delegates to the protected version. Caches the result in
 * case it gets checked more than once.
 * 
 * @author Andy
 * 
 */
abstract public class PatientRiskFactor {
	private Boolean hasRisk = null;

	/**
	 * @return A textual description of what the patient's status is that's causing the risk.
	 */
	abstract public String getDescription();

	/**
	 * @return A boolean indicating whether the patient has the increased risk.
	 */
	abstract protected boolean hasFactor();

	/**
	 * @return A boolean indicating whether the patient has the increased risk.
	 */
	public boolean hasRiskFactor() {
		if (hasRisk == null)
			hasRisk = hasFactor();
		return hasRisk;
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_PriorDiagnosisFactor</id>
            <content>package edu.ncsu.csc.itrust.risk.factors;

import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Checks for prior diagnoses by delegatin to the DAO
 * See {@link PatientRiskFactor} for details on what each method typically does.
 * 
 * @author Andy
 * 
 */
public class PriorDiagnosisFactor extends PatientRiskFactor {
	private long patientID;
	private DAOFactory factory;
	private double lowerICDCode;
	private double upperICDCode;

	public PriorDiagnosisFactor(DAOFactory factory, long patientID, double lowerICDCode, double upperICDCode) {
		this.factory = factory;
		this.patientID = patientID;
		this.lowerICDCode = lowerICDCode;
		this.upperICDCode = upperICDCode;
	}

	public String getDescription() {
		return &quot;Patient has had related diagnoses&quot;;
	}

	public boolean hasFactor() {
		try {
			return factory.getRiskDAO().hadPriorDiagnoses(patientID, lowerICDCode, upperICDCode);
		} catch (DBException e) {
			e.printStackTrace();
			return false;
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_SmokingFactor</id>
            <content>package edu.ncsu.csc.itrust.risk.factors;

import edu.ncsu.csc.itrust.dao.DAOFactory;
import edu.ncsu.csc.itrust.exception.DBException;

/**
 * Risk factor delegates to the DAO to see if a patient has ever smoked in their life
 * See {@link PatientRiskFactor} for details on what each method typically does.
 * 
 * @author Andy
 * 
 */
public class SmokingFactor extends PatientRiskFactor {
	private long patientID;
	private DAOFactory factory;

	public SmokingFactor(DAOFactory factory, long patientID) {
		this.factory = factory;
		this.patientID = patientID;
	}

	public String getDescription() {
		return &quot;Patient is or was a smoker&quot;;
	}

	public boolean hasFactor() {
		try {
			return factory.getRiskDAO().hasSmoked(patientID);
		} catch (DBException e) {
			e.printStackTrace();
			return false;
		}
	}
}</content>
            <parent_id/>
        </artifact>
        <artifact>
            <id>CC_WeightFactor</id>
            <content>package edu.ncsu.csc.itrust.risk.factors;

import edu.ncsu.csc.itrust.beans.HealthRecord;

/**
 * Checks the patient's body mass index over the given threshold
 * See {@link PatientRiskFactor} for details on what each method typically does.
 * 
 * @author Andy
 * 
 */
public class WeightFactor extends PatientRiskFactor {
	private HealthRecord currentHealthRecord;
	private int bmiThreshold;

	public WeightFactor(HealthRecord currentHealthRecord, int bmiThreshold) {
		this.currentHealthRecord = currentHealthRecord;
		this.bmiThreshold = bmiThreshold;
	}

	public String getDescription() {
		return &quot;Patient's body mass index is over &quot; + bmiThreshold;
	}

	public boolean hasFactor() {
		double bmi = currentHealthRecord.getBodyMassIndex();
		return bmi &gt; bmiThreshold &amp;&amp; !Double.isInfinite(bmi);
	}
}</content>
            <parent_id/>
        </artifact>
    </artifacts>
</artifacts_collection>
